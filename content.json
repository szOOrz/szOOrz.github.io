{"meta":{"title":"Emoairx","subtitle":null,"description":"OI Lover","author":"EMOAIRX","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2017-08-29T05:49:28.211Z","updated":"2017-08-29T05:49:28.211Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"USACO/月赛/USACO 2008 January/src/cqz/result","date":"2017-09-17T08:59:35.371Z","updated":"2017-03-05T03:00:50.000Z","comments":true,"path":"2017/09/17/USACO/月赛/USACO 2008 January/src/cqz/result/","link":"","permalink":"http://yoursite.com/2017/09/17/USACO/月赛/USACO 2008 January/src/cqz/result/","excerpt":"","text":"cqz的测评结果 总分: 300 cowrun: 100 1 10 时间: 0.00s 内存: 33.48MB 2 10 时间: 0.00s 内存: 33.48MB 3 10 时间: 0.00s 内存: 33.49MB 4 10 时间: 0.00s 内存: 33.48MB 5 10 时间: 0.00s 内存: 33.49MB 6 10 时间: 0.00s 内存: 33.48MB 7 10 时间: 0.03s 内存: 33.49MB 8 10 时间: 0.05s 内存: 33.49MB 9 10 时间: 0.08s 内存: 33.49MB 10 10 时间: 0.08s 内存: 33.48MB phoneline: 0 无测评结果 alake: 100 1 7 时间: 0.00s 内存: 4.25MB 2 7 时间: 0.00s 内存: 4.26MB 3 7 时间: 0.00s 内存: 4.25MB 4 7 时间: 0.00s 内存: 4.25MB 5 7 时间: 0.00s 内存: 4.25MB 6 7 时间: 0.01s 内存: 4.25MB 7 7 时间: 0.06s 内存: 4.25MB 8 7 时间: 0.14s 内存: 4.25MB 9 7 时间: 0.19s 内存: 4.25MB 10 7 时间: 0.22s 内存: 4.26MB 11 7 时间: 0.19s 内存: 4.25MB 12 7 时间: 0.38s 内存: 4.25MB 13 8 时间: 0.33s 内存: 4.25MB 14 8 时间: 0.47s 内存: 4.25MB icow: 100 1 10 时间: 0.00s 内存: 0.45MB 2 10 时间: 0.01s 内存: 0.45MB 3 10 时间: 0.00s 内存: 0.45MB 4 10 时间: 0.00s 内存: 0.46MB 5 10 时间: 0.00s 内存: 0.45MB 6 10 时间: 0.00s 内存: 0.45MB 7 10 时间: 0.00s 内存: 0.45MB 8 10 时间: 0.01s 内存: 0.45MB 9 10 时间: 0.00s 内存: 0.45MB 10 10 时间: 0.01s 内存: 0.45MB 本文件由 CCR Plus 测评器生成，如有疑问和建议请致信 equation618@gmail.com 绍兴一中 贾越凯","categories":[],"tags":[]},{"title":"","slug":"USACO/月赛/USACO 2007 Open/src/cqz/result","date":"2017-09-17T08:59:29.325Z","updated":"2017-03-05T07:05:12.000Z","comments":true,"path":"2017/09/17/USACO/月赛/USACO 2007 Open/src/cqz/result/","link":"","permalink":"http://yoursite.com/2017/09/17/USACO/月赛/USACO 2007 Open/src/cqz/result/","excerpt":"","text":"cqz的测评结果 总分: 100 horizon: 100 1 10 时间: 0.00s 内存: 5.02MB 2 10 时间: 0.00s 内存: 5.02MB 3 10 时间: 0.00s 内存: 5.02MB 4 10 时间: 0.01s 内存: 5.02MB 5 10 时间: 0.01s 内存: 5.02MB 6 10 时间: 0.00s 内存: 5.02MB 7 10 时间: 0.01s 内存: 5.02MB 8 10 时间: 0.03s 内存: 5.02MB 9 10 时间: 0.19s 内存: 5.02MB 10 10 时间: 0.14s 内存: 5.02MB 本文件由 CCR Plus 测评器生成，如有疑问和建议请致信 equation618@gmail.com 绍兴一中 贾越凯","categories":[],"tags":[]},{"title":"","slug":"Codeforces/348/C/prob","date":"2017-09-10T05:00:55.765Z","updated":"2017-09-10T05:01:46.702Z","comments":true,"path":"2017/09/10/Codeforces/348/C/prob/","link":"","permalink":"http://yoursite.com/2017/09/10/Codeforces/348/C/prob/","excerpt":"","text":"window.standaloneContest = false; function adjustViewport() { var screenWidthPx = Math.min($(window).width(), window.screen.width); var siteWidthPx = 1100; // min width of site var ratio = Math.min(screenWidthPx / siteWidthPx, 1.0); var viewport = \"width=device-width, initial-scale=\" + ratio; $('#viewport').attr('content', viewport); var style = $('html * { max-height: 1000000px; }'); $('html > head').append(style); } if ( /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent) ) { adjustViewport(); } Problem - C - Codeforces &nbsp; var queryMobile = Codeforces.queryString.mobile; if (queryMobile === \"true\" || queryMobile === \"false\") { Codeforces.putToStorage(\"useMobile\", queryMobile == \"true\"); } else { var useMobile = Codeforces.getFromStorage(\"useMobile\"); if (useMobile === true || useMobile === false) { if (useMobile != false) { Codeforces.redirect(Codeforces.updateUrlParameter(document.location.href, \"mobile\", useMobile)); } } } if (window.parent.frames.length > 0) { window.stop(); } window.fbAsyncInit = function() { FB.init({ appId : '554666954583323', xfbml : true, version : 'v2.8' }); FB.AppEvents.logPageView(); }; (function(d, s, id){ var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) {return;} js = d.createElement(s); js.id = id; js.src = \"//connect.facebook.net/en_US/sdk.js\"; fjs.parentNode.insertBefore(js, fjs); }(document, 'script', 'facebook-jssdk')); $(document).ready(function () { (function () { jQuery.expr[':'].containsCI = function(elem, index, match) { return !match || !match.length || match.length < 4 || !match[3] || ( elem.textContent || elem.innerText || jQuery(elem).text() || '' ).toLowerCase().indexOf(match[3].toLowerCase()) >= 0; } }(jQuery)); $.ajaxPrefilter(function(options, originalOptions, xhr) { var csrf = Codeforces.getCsrfToken(); if (csrf) { var data = originalOptions.data; if (originalOptions.data !== undefined) { if (Object.prototype.toString.call(originalOptions.data) === '[object String]') { data = $.deparam(originalOptions.data); } } else { data = {}; } options.data = $.param($.extend(data, { csrf_token: csrf })); } }); window.getCodeforcesServerTime = function(callback) { $.post(\"/data/time\", {}, callback, \"json\"); } window.updateTypography = function () { $(\"div.ttypography code\").addClass(\"tt\"); $(\"div.ttypography pre>code\").addClass(\"prettyprint\").removeClass(\"tt\"); $(\"div.ttypography table\").addClass(\"bordertable\"); prettyPrint(); } $.ajaxSetup({ scriptCharset: \"utf-8\" ,contentType: \"application/x-www-form-urlencoded; charset=UTF-8\", headers: { 'X-Csrf-Token': Codeforces.getCsrfToken() }}); window.updateTypography(); Codeforces.signForms(); setTimeout(function() { $(\".second-level-menu-list\").lavaLamp({ fx: \"backout\", speed: 1000 }); }, 0); Codeforces.countdown(); $(\"a[rel='photobox']\").colorbox(); function showAnnouncements(json) { //info(\"j=\" + JSON.stringify(json)); if (json.t != \"a\") { return; } // console.log(\"Got announcement from channel\"); setTimeout(function() { Codeforces.showAnnouncements(json.d, \"en\"); }, Math.random() * 500); } if (Codeforces.getParticipantChannel()) { Codeforces.subscribe(Codeforces.getParticipantChannel(), function(json) { showAnnouncements(json); }); } if (Codeforces.getContestChannel()) { Codeforces.subscribe(Codeforces.getContestChannel(), function(json) { showAnnouncements(json); }); } if (Codeforces.getGlobalChannel()) { Codeforces.subscribe(Codeforces.getGlobalChannel(), function(json) { showAnnouncements(json); }); } if (Codeforces.getUserChannel()) { Codeforces.subscribe(Codeforces.getUserChannel(), function(json) { showAnnouncements(json); }); } $(\".clickable-title\").click(function() { Codeforces.alert($(this).attr(\"title\")); }).css(\"position\", \"relative\").css(\"bottom\", \"3px\"); Codeforces.reformatTimes(); Codeforces.initializePubSub(); Codeforces.setupSpoilers(); Codeforces.setupTutorials(\"/data/problemTutorial\"); }); var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-743380-5']); _gaq.push(['_trackPageview']); (function () { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = (document.location.protocol == 'https:' ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); Enter | Register &nbsp; &nbsp; &nbsp; &nbsp; Home Contests Gym Problemset Groups Rating API RCC AIM Tech Round Calendar $(document).ready(function () { $(\"input.search\").focus(function () { if ($(this).attr(\"data-isPlaceholder\") === \"true\") { $(this).val(\"\"); $(this).removeAttr(\"data-isPlaceholder\"); } }); }); &nbsp; &nbsp; &rarr; Attention Package for this problem was not updated by the problem writer or Codeforces administration after we��ve upgraded the judging servers. To adjust the time limit constraint, solution execution time will be multiplied by 2. For example, if your solution works for 400 ms on judging servers, then value 800 ms will be displayed and used to determine the verdict. &nbsp; &nbsp; Codeforces Round #202 (Div. 1) Finished &nbsp; &nbsp; &rarr; Practice? Want to solve the contest problems after the official contest ends? Just register for practice and you will be able to submit solutions. &nbsp; &nbsp; &rarr; Virtual participation Virtual contest is a way to take part in past contest, as close as possible to participation on time. It is supported only ACM-ICPC mode for virtual contests. If you've seen these problems, a virtual contest is not for you - solve these problems in the archive. If you just want to solve some problem from a contest, a virtual contest is not for you - solve this problem in the archive. Never use someone else's code, read the tutorials or communicate with other person during a virtual contest. &nbsp; &nbsp; &rarr; Problem tags &nbsp; &nbsp; &nbsp; &nbsp; brute force &nbsp; &nbsp; &nbsp; &nbsp; data structures No tag edit access $(\".tag-box img\").click(function () { var tagName = $(this).attr(\"value\"); Codeforces.confirm(\"Are you sure you want to remove this tag?\", function () { $(\"#removeTagForm input[name=tagName]\").val(tagName); $(\"#removeTagForm\").submit(); }, function () { }, \"Yes\", \"No\"); }); $(\"#addTagLink\").click(function () { $(this).hide(); $(\"#addTagLabel\").show(); return false; }); $(\"#addTagSelect\").change(function () { var tagName = $(this).val(); if (tagName === \"\") { $(\"#addTagLabel\").hide(); $(\"#addTagLink\").show(); } else { $(\"#addTagForm input[name=tagName]\").val(tagName); $(\"#addTagForm\").submit(); } }); #new-resource-form tr td { padding-top: 0.5em; } #new-resource-form input:not([type=\"submit\"]) { font-size: 0.8em; } #new-resource-form select { font-size: 0.8em; } &nbsp; &nbsp; &rarr; Contest materials Announcement Tutorial Problems Submit Code My Submissions Status Hacks Room Standings Custom Invocation C. Subset Sumstime limit per test3 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputYou are given an array a1,?a2,?...,?an and m sets S1,?S2,?...,?Sm of indices of elements of this array. Let's denote Sk?=?{Sk,?i} (1?��?i?��?|Sk|). In other words, Sk,?i is some element from set Sk.In this problem you have to answer q queries of the two types: Find the sum of elements with indices from set Sk: . The query format is &quot;? k&quot;. Add number x to all elements at indices from set Sk: aSk,?i is replaced by aSk,?i?+?x for all i (1?��?i?��?|Sk|). The query format is &quot;+ k x&quot;. After each first type query print the required sum.InputThe first line contains integers n,?m,?q (1?��?n,?m,?q?��?105). The second line contains n integers a1,?a2,?...,?an (|ai|?��?108) �� elements of array a. Each of the following m lines describes one set of indices. The k-th line first contains a positive integer, representing the number of elements in set (|Sk|), then follow |Sk| distinct integers Sk,?1,?Sk,?2,?...,?Sk,?|Sk| (1?��?Sk,?i?��?n) �� elements of set Sk.The next q lines contain queries. Each query looks like either &quot;? k&quot; or &quot;+ k x&quot; and sits on a single line. For all queries the following limits are held: 1?��?k?��?m, |x|?��?108. The queries are given in order they need to be answered.It is guaranteed that the sum of sizes of all sets Sk doesn't exceed 105.OutputAfter each first type query print the required sum on a single line.Please, do not write the %lld specifier to read or write 64-bit integers in ��++. It is preferred to use the cin, cout streams or the %I64d specifier.ExamplesInput5 3 55 -5 5 1 -42 1 24 2 1 4 52 2 5? 2+ 3 4? 1+ 2 1? 2Output-349 $(document).ready(function () { function endsWith(string, suffix) { return string.indexOf(suffix, string.length - suffix.length) !== -1; } var inputFileDiv = $(\"div.input-file\"); var inputFile = inputFileDiv.text(); var outputFileDiv = $(\"div.output-file\"); var outputFile = outputFileDiv.text(); if (!endsWith(inputFile, \"standard input\") && !endsWith(inputFile, \"standard input\")) { inputFileDiv.attr(\"style\", \"font-weight: bold\"); } if (!endsWith(outputFile, \"standard output\") && !endsWith(outputFile, \"standard output\")) { outputFileDiv.attr(\"style\", \"font-weight: bold\"); } var titleDiv = $(\"div.header div.title\"); }); Codeforces (c) Copyright 2010-2017 Mike Mirzayanov The only programming contests Web 2.0 platform Server time: Sep/10/2017 08:00:45 (p1). Desktop version, switch to mobile version. Privacy Policy $(function() { $(\".switchToMobile\").click(function() { Codeforces.redirect(Codeforces.updateUrlParameter(document.location.href, \"mobile\", \"true\")); return false; }); $(\".switchToDesktop\").click(function() { Codeforces.redirect(Codeforces.updateUrlParameter(document.location.href, \"mobile\", \"false\")); return false; }); }); $(document).ready(function () { if ($(window).width() < 1600) { $('.button-up').css('width', '30px').css('line-height', '30px').css('font-size', '20px'); } if ($(window).width() >= 1200) { $ (window).scroll (function () { if ($ (this).scrollTop () > 100) { $ ('.button-up').fadeIn(); } else { $ ('.button-up').fadeOut(); } }); $('.button-up').click(function () { $('body,html').animate({ scrollTop: 0 }, 500); return false; }); $('.button-up').hover(function () { $(this).animate({ 'opacity':'1' }).css({'background-color':'#e7ebf0','color':'#6a86a4'}); }, function () { $(this).animate({ 'opacity':'0.7' }).css({'background':'none','color':'#d3dbe4'});; }); } Codeforces.focusOnError(); }); &nbsp; &nbsp; &nbsp; &nbsp; User lists &nbsp; &nbsp; Name $(document).ready(function () { // Create new ':containsIgnoreCase' selector for search jQuery.expr[':'].containsIgnoreCase = function(a, i, m) { return jQuery(a).text().toUpperCase() .indexOf(m[3].toUpperCase()) >= 0; }; if (window.updateDatatableFilter == undefined) { window.updateDatatableFilter = function(i) { var parent = $(i).parent().parent().parent().parent(); $(\"tr.no-items\", parent).remove(); $(\"tr\", parent).hide().removeClass('visible'); var text = $(i).val(); if (text) { $(\"tr\" + \":containsIgnoreCase('\" + text + \"')\", parent).show().addClass('visible'); } else { parent.find(\".rowCount\").text(\"\"); $(\"tr\", parent).show().addClass('visible'); } var found = false; var visibleRowCount = 0; $(\"tr\", parent).each(function () { if (!found) { if ($(this).find(\"th\").size() > 0) { $(this).show().addClass('visible'); found = true; } } if ($(this).hasClass('visible')) { visibleRowCount++; } }); if (text) { parent.find(\".rowCount\").text(\"Matches: \" + (visibleRowCount - (found ? 1 : 0))); } if (visibleRowCount == (found ? 1 : 0)) { $(\"No items\").appendTo($(parent).find('table')); } $(parent).find(\"tr td\").removeClass(\"dark\"); $(parent).find(\"tr.visible:odd td\").addClass(\"dark\"); } $(\".datatable .closed\").click(function () { var parent = $(this).parent(); $(this).hide(); $(\".filter\", parent).fadeIn(function () { $(\"input\", parent).val(\"\").focus().css(\"border\", \"1px solid #aaa\"); }); }); $(\".datatable .opened\").click(function () { var parent = $(this).parent().parent(); $(\".filter\", parent).fadeOut(function () { $(\".closed\", parent).show(); $(\"input\", parent).val(\"\").each(function () { window.updateDatatableFilter(this); }); }); }); $(\".datatable .filter input\").keyup(function(e) { window.updateDatatableFilter(this); e.preventDefault(); e.stopPropagation(); }); $(\".datatable table\").each(function () { var found = false; $(\"tr\", this).each(function () { if (!found && $(this).find(\"th\").size() == 0) { found = true; } }); if (!found) { $(\"No items\").appendTo(this); } }); // Applies styles to datatables. $(\".datatable\").each(function () { $(this).find(\"tr:first th\").addClass(\"top\"); $(this).find(\"tr:last td\").addClass(\"bottom\"); $(this).find(\"tr:odd td\").addClass(\"dark\"); $(this).find(\"tr td:first-child, tr th:first-child\").addClass(\"left\"); $(this).find(\"tr td:last-child, tr th:last-child\").addClass(\"right\"); }); $(\".datatable table.tablesorter\").each(function () { $(this).bind(\"sortEnd\", function () { $(\".datatable\").each(function () { $(this).find(\"th, td\") .removeClass(\"top\").removeClass(\"bottom\") .removeClass(\"left\").removeClass(\"right\") .removeClass(\"dark\"); $(this).find(\"tr:first th\").addClass(\"top\"); $(this).find(\"tr:last td\").addClass(\"bottom\"); $(this).find(\"tr:odd td\").addClass(\"dark\"); $(this).find(\"tr td:first-child, tr th:first-child\").addClass(\"left\"); $(this).find(\"tr td:last-child, tr th:last-child\").addClass(\"right\"); }); }); }); } }); $(function() { $(\".userListMarker\").click(function() { $.post(\"/data/lists\", {action: \"findTouched\"}, function(json) { Codeforces.facebox(\".userListsFacebox\"); var tbody = $(\"#facebox tbody\"); tbody.empty(); for (var i in json) { tbody.append( $(\"\").append( $(\"\").attr(\"data-readKey\", json[i].readKey).text(json[i].name) ) ); } Codeforces.updateDatatables(); tbody.find(\"td\").css(\"cursor\", \"pointer\").click(function() { document.location = Codeforces.updateUrlParameter(document.location.href, \"list\", $(this).attr(\"data-readKey\")); }); }, \"json\"); }); });","categories":[],"tags":[]},{"title":"codeforces刷题记录——初三上","slug":"Codeforces/题解：初三上/codeforces","date":"2017-08-31T13:43:09.283Z","updated":"2017-09-02T02:02:23.820Z","comments":true,"path":"2017/08/31/Codeforces/题解：初三上/codeforces/","link":"","permalink":"http://yoursite.com/2017/08/31/Codeforces/题解：初三上/codeforces/","excerpt":"","text":"Codeforces Round #430 (Div. 2) CF843C:这题我们考虑第一个节点，那么结果就是：要么什么都不删除（可以$O(n)$求解），可以只删除第一个（也是$O(n)$）求解$\\Large _{注意到，不要忘记把vis[1]赋值成true，不然会往父亲走!}$，要么是不修改第一个节点。注意到，既然不修改第一个节点，那么最后的$gcd$必然是1的因子！那么我们可以$O(sqrt(n))$来枚举所有可能的$Ans$，然后判断是否需要修改一个以上。 CF843D:这题只需要对所有的$x$求一个前缀$xor$，然后在一棵$trie$树上贪心。注意要记录这个以下的种类。 Codeforces Round #431 (Div. 2) CF849B:注意到，只有2个前缀，如果存在，那么1和2不是同一组，1和3也不是同一组，那么2和3一定是同一组。同理，可以得到1和2，2和3，1和3其中必然有一组是其中一个等差数列的开头，那么O(3)枚举，然后O(n)判断即可。 CF849C:注意到，数字先后是无关的，只需要逐个添加就行了，所以就是找到满足一些$\\sum _nn*(n-1)\\div 2$的n，然后输出。然后位数是不用考虑的，其实长度(&amp;码量)很短。 CF172D:给定a,n，求[a,a+n-1]所有数的贡献总和。一个数的贡献是其除掉所有平方因子后的部分。 ​ 考虑用类似筛法的除去所有的因子，然后暴力求解。 CF451E:有$n$种颜色的❀，第$i$种❀有$f_i$朵。求选出$s$朵❀的不同方案数。$n&lt;=20,s&lt;=1e14,f_i&lt;=1e12$ ​ CF448E:给出一个x,k，每次操作都会将x分解因数，得到新的序列，然后每次再分解序列中的每一个数，按照每一个数分解因数从小到大排，整体顺序不做调整。（如果躲过1e5个，只输出1e5个）$x&lt;=1e12, k&lt;=1e18$ ​ 考虑每次递归处理。每次到k次，然后$cnt++$，直到完了或者到了1e5个。 CF216E:给定一个进制k和一位数b。以及长度为n的序列（均小于k）求这个序列存在多少子序列，能通过变换变为d？这里的变换指的是，每次将k进制数x的每一位相加（k进制加法）得到一个新的数x’，直到最后得到一个一位数。$b&lt;k&lt;=1e9, n&lt;=100000$","categories":[],"tags":[]},{"title":"UOJ刷题记录——做了一题也算做了。","slug":"UOJ/UOJ","date":"2017-08-27T12:36:02.669Z","updated":"2017-08-29T06:42:34.248Z","comments":true,"path":"2017/08/27/UOJ/UOJ/","link":"","permalink":"http://yoursite.com/2017/08/27/UOJ/UOJ/","excerpt":"#1. A + B Problem ​ 考虑先输入两个正整数，然后输出它们的和。","text":"#1. A + B Problem ​ 考虑先输入两个正整数，然后输出它们的和。 #2【NOI2014】起床困难综合症 ​ 注意到，因为是位运算，每一位都是独立的，因此从高位贪心，如果0比1赚（或者相同），一定选0，否则就选1，注意到复杂度是$O(n log n)$ #127. 【NOI2015】程序自动分析 ​ 对于本题，考虑用并查集，先把所有相等的关系合并在一起，再判断不想等的关系是否矛盾——因为不想等是不具有传递性的，而相等具有。注意到数据范围比较大，用一个Map来保存。 ​ 另外，如果说A不等于A，也是错的。 ​ 时间复杂都$O(n\\times log_2n+n\\times α(n))$","categories":[],"tags":[]},{"title":"CF动态规划相关——2017暑假","slug":"Codeforces/题解：2017暑假/动态规划相关","date":"2017-08-27T08:47:15.261Z","updated":"2017-08-29T13:15:29.820Z","comments":true,"path":"2017/08/27/Codeforces/题解：2017暑假/动态规划相关/","link":"","permalink":"http://yoursite.com/2017/08/27/Codeforces/题解：2017暑假/动态规划相关/","excerpt":"规划？ 还是动态的？","text":"规划？ 还是动态的？ CF762D你有一个3*n的格子，每个格子都有权值，问从(1,1)除法，到(3,n)，路上经过的权值最大是多少。 ——听说有一种做法叫做插头DP？划掉。 考虑不会超过2次往后移动。只可能这样 ，而不可能 而且只有第二行可能往后走。 CF67D两条直线，各有n(1≤n≤10^6)个点,每个上面的点会和下面的一个点相连，构成一条线段，共n条线段，问这 n 条线段中，最多有多少线段，它们两两相交？ ——把问题转换为求LIS。然后$n log n$求解 CF41D给你一个N*M的矩阵，其中每个格点中包含0-9中一个数字，问从最下边那一层找到一个起点，一直向上走（向上走只有两种方式，要么斜左上，要么斜右上），询问一个最大值，其走到最上边一层之后，其和为k+1的倍数。并且输出起点位子，以及路径怎样走的。 CF398B给出n和m，表示在一个$n\\times n$的平面上有$n\\times n$个瓷砖，其中有$m$块已经涂色。现在随机选中一块进行涂色（如果已经涂色跳过，也消耗时间），消耗$1$个步骤。终止条件为每行每列都有至少有一块瓷砖被涂色。问说涂成满意的情况需要时间的期望。 考虑用dp[i,j]表示剩下i行，j列需要的答案。记忆化DFS转移一下。 CF317D ​ 网上的题解抄了一下QAQ。 ​ 假设 x 不是任何其它数的正整数次幂，把 x 和它的正整数次幂分成一类，显然一个数不可能同时属于两类，于是整个游戏就被分成了若干个互不干扰的子游戏，且每个子游戏的规模不超过 $log_2N$ ，打表求出 SG 函数异或起来即可，但这样时间复杂度为 $O(\\sqrt N)$ 。 CF54C给出[L,R]区间，区间里的每个数出现的概率是1/(R-L+1)，现给出n个区间[Li,Ri]现在从每个区间选取一个数，这n个数中至少百分之K的数前缀为1的概率。 ​ 考虑先得到每一个区间开头为1的概率，然后用概率DP，表示前i个中，有j个区间开头为1的概率。转移一下，最后用ceil函数得到应该至少多少个区间，累加一下。","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}]},{"title":"CF图论简单题","slug":"Codeforces/题解：2017暑假/图论相关","date":"2017-08-27T00:05:43.829Z","updated":"2017-08-29T06:38:33.863Z","comments":true,"path":"2017/08/27/Codeforces/题解：2017暑假/图论相关/","link":"","permalink":"http://yoursite.com/2017/08/27/Codeforces/题解：2017暑假/图论相关/","excerpt":"","text":"CF208C给定一个有n个节点的无向图。选一个点成为特殊点，与特殊点相连的边称之为特殊边。求，对于所有1~n的最短路，经过的特殊边数量的平均值的最大值。$n&lt;=100, m&lt;=n(n-1)/2$ DP(2A)——注意LL ​ 对于特殊在1或者n，答案是边数/总路劲。否则就是经过某个点的边数*2/总路径。 ​ 考虑首先一次$bfs$，求出源点到某个点的距离 ​ 考虑第二次$bfs$，求出源点到某个点有多少次条路 ​ 考虑第三次$bfs$，在枚举出点的情况下，求出有多少最短路经过该点 CF154C有一个n个节点,m条边的无向图，问有多少个点对，使得除了它们之间的边之外，其他的连接方式相同$(1 ≤ n ≤ 10^6, 0 ≤ m ≤ 10^6)$","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"}]},{"title":"CF简单数据结构","slug":"Codeforces/题解：2017暑假/数据结构相关","date":"2017-08-25T08:17:54.491Z","updated":"2017-08-29T06:39:00.283Z","comments":true,"path":"2017/08/25/Codeforces/题解：2017暑假/数据结构相关/","link":"","permalink":"http://yoursite.com/2017/08/25/Codeforces/题解：2017暑假/数据结构相关/","excerpt":"听说数据结构不能吃","text":"听说数据结构不能吃 CF538F：题意见： 12&gt; http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1533&gt; 树状数组 ​ 注意到，每个点作为父亲，最多只有n log n个父亲（调和级数）。那么我们要得到快速计算结果。 ​ 考虑把所有数排序，然后逐个加入到树状数组原来的位置里面。 同时计算它作为k（枚举）叉堆的父亲的时候其子节点的贡献。 ——当然，为了不重复计数，在值相同的情况下，我们先把上面的数据处理，再处理下面的数据，然后树状数组计算当前节点对k叉堆的贡献。 ​ $O(n log^2 n)$ CF101B:给定n,m。需要从0到n，有m种公交车。第i辆公交车从si走到ti，问有多少种方案可以选择。注意人只能坐车，不可以走。$m&lt;=100000$ DP ​ $DP[i]$表示$i$结束的种类，树状数组区间求和即可。 CF372C:给定一个n*m的地图，标有数字1~p。需要从1出发，依次经过2,3,4…直到p（至少一次）。求最少所需要的步数。$n,m&lt;=300$ DP ​ 考虑用$dp[i,j]$表示在第$i$个行，第$j$个位置的答案。——分组DP。那么对于$dp[i,j]$，设这个是x，那么从周围的x转移过来，可以拆分成左上角，右上角，左下角，右下角转移过来。 ​ 考虑把哈密顿距离分开来，对于4个方向分别用二维树状数组维护。 ​ 每次做完一组，把前一组的位置赋值成$oo$。然后把树状数组赋值成这一组的$dp$值加上一些值。 ​ 注意括号别匹配错。","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"CF543D && CF369C","slug":"Codeforces/题解：2017暑假/CF543D && CF369C","date":"2017-08-25T02:30:25.509Z","updated":"2017-08-29T13:16:16.441Z","comments":true,"path":"2017/08/25/Codeforces/题解：2017暑假/CF543D && CF369C/","link":"","permalink":"http://yoursite.com/2017/08/25/Codeforces/题解：2017暑假/CF543D && CF369C/","excerpt":"树是什么？能吃吗","text":"树是什么？能吃吗 CF543D输入给出N和一些边的关系$(p2，p3，p4……pn）$表示$i$和$p_i$有连边.对于以i为根时，把树边黑白染色，使得任意点走到根的路径上不超过一条黑边，输出染色的方案数(mod 1e9+7) ​ 考虑树形DP，在以1为根的前提下，设$f[i]$表示以i为根的子树的$Ans$。容易得到 ​ $\\Large f[i] = \\prod _{j}^{}(f[j]+1)$ ​ 那么我们第二次DFS的时候，得到一个节点在以1为根的大树中，上面连通的哪些的$Ans$。注意到，要处理逆元。但是，可能出现0，但是不能算无解。应该重新跑一遍去算。 CF369C:给出一棵以1为根的树，形式是从节点2开始给出每个节点的父亲节点；然后是$q$次操作，操作分为两种，$1$,$v$,$x$,$k$，表示在以v为根的子树上添加，对于所有其它与$v$节点的距离为$i$的点$v$节点的后代，加上$x-ik$；$2$,$v$查询节点v的值(对1e9+7取模)。一开始都是0,$n,q&lt;=310^5$","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"tree","slug":"tree","permalink":"http://yoursite.com/tags/tree/"}]},{"title":"Codeforces-Educational-Round","slug":"Codeforces/题解：2017暑假/教育场相关","date":"2017-08-24T06:48:58.885Z","updated":"2017-08-29T06:35:43.443Z","comments":true,"path":"2017/08/24/Codeforces/题解：2017暑假/教育场相关/","link":"","permalink":"http://yoursite.com/2017/08/24/Codeforces/题解：2017暑假/教育场相关/","excerpt":"这是用来教人怎么做人的。","text":"这是用来教人怎么做人的。 Educational Codeforces Round 1 CF598A：求数字之和，但是要不算2的倍数 模拟(1A) ​ 等差数列求和公式，再减去2次倍数即可。$log$的复杂度 CF598B：给定一个字符串s，下标从1 - |s|。有m次操作，L R k - 表示讲[L, R]里面的字符右移k次，第R位右移一次到达第L位。问你经过m次变化后的字符串。 模拟(1A) ​ 考虑把k先对长度取模，然后用一个辅助数组直接暴力O(len)移动再代入。 CF598C：找到两个向量间夹角最小的那两个向量的位置; 精度(N A) ​ 要用atan2高精度做，用long double做，极角排序后求角度即可。 CF598D：给定一个$n \\times m$的地图，有k次查询。每次查询，询问位置（x,y）的点连通块周围有多少个 flood fill(2A) ​ 先$N \\times M$把所有位置的答案算出来，然后询问直接做 CF598E：一个n*m大的巧克力，你要吃k个单元的巧克力。每次切分都会有切的那条边长度平方的代价。问最小代价。 DP(4A) ​ 考虑直接用$dp[i,j,k]$表示状态为i,j,k的时候的答案，那么只需要暴力枚举分割线，以及左边多少，右边多少，取max。注意不要数组越界 Educational Codeforces Round 3 CF609A:给你一个m大的总内存和n个USB快闪驱动器，问你至少需要多少个USB快闪驱动器才能装满或者超过总内存。 贪心(1A) ​ 排个序，然后贪心贪大的，看减多少次小于等于0即可。 CF609B:给你一堆书和他们的种类，然后要挑两本书，他们不能是相同的种类，求有多少种挑法 容斥(1A) ​ 考虑所有情况，减去2本数在一起的情况，注意到m&lt;=10，比较容易。 CF609C:给你n个元素的序列a[]，每次可以任选两个元素使得其中一个减1，另一个加1，付出代价为1。问你最小的代价使得序列最平衡。 贪心(1A) ​ 考虑直接贪心做，把最后得到的那个序列通过总和，余数等算出来，然后考虑把当前排序，贪心地得到两者之间的绝对值的sum，那么最后答案就是这个sum/2 CF609D:给定m个物品（编号从1-m）以及它们的种类和价格（美元和英镑），其中种类1意味着购买该物品需要美元，反之需要英镑。已知在n天里，每天都会有美元和英镑的兑换率a[i]和b[i]，意味着用a[i]个burle可以换取1美元，英镑的兑换同理。现在你手上只有s个burle，你需要在n天里购买k个物品，要求每个物品只能买一次，问你最早在第几天可以完成任务，并输出购买方案。 二分答案，贪心(1A) ​ 考虑每种货币都在最小的同一天进行购买——在最便宜的一天购买，这样是最赚的。 ​ 那么我们首先二分答案，那么接下来的事情就是枚举多少个英镑去买，多少个美元去买。那么同时我们之前预处理出一个前缀Min，那么$O(1)$得到在这种情况下，要花费多少burle，如果够的，那么就返回true。 ​ 注意要保存一下ID。因为答案要输出购买方案。 CF609E：给你一幅图，问对于每条边，包含这条边的最小生成树。 并查集按秩合并(5A) ​ 倍增写挂了，发现这个好写多了。 ​ 考虑先求出原图的最小生成树——按秩合并（用$m log m$的那个算法)，考虑到边权是递增的，那么每次加入一条边，这条边连接的两个联通块，那么联通块两边的点一定会经过这条边——这是有保证的。而Max也能保证。 ​ 而按秩合并，可以保证树高不会超过log，所以复杂度是$O(m log m)$级别的。 ​ 如果不是原图的边，然后就相当于去掉路劲上最大边权的点，然后加上这条边的边权。 Educational Codeforces Round 4 CF612C：给你一个只含有括号的字符串，你可以将一种类型的左括号改成另外一种类型，右括号改成另外一种右括号。问你最少修改多少次，才能使得这个字符串匹配，输出次数。 栈(1A) ​ 手工模拟一个栈，如果遇到不匹配的，那么就$Ans+1$. CF612D：给出n个区间$[li,ri]$以及一个整数k，称一个数的令人满意的如果它至少被这n个区间中的k个区间覆盖，输出所有令人满意的数构成的区间 差分(4A) ​ 运用差分思想，考虑$l[i]$的时候+1，$r[i]$的时候-1。注意到，一个点也算是一段，所以不能所谓的离散化之类的，考虑把所有读入之后按照位置排序，在位置相同的情况下，先排加，后排减。然后前缀和一发。 CF612E：定义置换的平方为1~n的排列做两次该置换得到的结果。已知一个置换的平方，求该置换。 构造(问$XZA$大佬的) ​ 大佬说，先找循环，分成不同的循环联通块。 ​ 大佬还说，对于元素个数是奇数的，只需要往后移2位就行了，对于元素个数是偶数的，把相同元素个数的两两组合在一起，轮换着放——大佬说这是参考样例1的。","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"CF组合计数相关","slug":"Codeforces/题解：2017暑假/组合计数相关","date":"2017-08-24T06:46:42.456Z","updated":"2017-08-29T06:36:20.078Z","comments":true,"path":"2017/08/24/Codeforces/题解：2017暑假/组合计数相关/","link":"","permalink":"http://yoursite.com/2017/08/24/Codeforces/题解：2017暑假/组合计数相关/","excerpt":"我为我听说过排列组合而感到高兴。","text":"我为我听说过排列组合而感到高兴。 CF57C:给你一个数n，表示有n个数的序列，每个数范围为[1,n]，叫你求所有非降和非升序列的个数。 ​ 考虑到答案是$\\large 2\\times C(2\\times n-1,n)-n$。 ​ 引用一段网上的：我们在满足条件的n个数之前加一个虚节点1，在第n个数之后加一个虚节点n，那么考虑这n+2个数组成的非降序列：假设序列里的第i个数为a[i]，我们设$\\large xi=a[i+1]-a[i]+1$，$\\large 1&lt;=i&lt;=n+1$，则满足每个数&gt;=1,且$\\Large \\sum_{i=1}^{n+1}x[i]=2\\times n$；那么相当于求将2*n分成n个部分，且每个部分的值大于等于1，则易得非降序列总数为：$(\\Large_n^{2\\times n-1})（2\\times n-1 选 n）$ ​ 以后慢慢看吧。（估计不会来看了） CF40E:给出一个n×m的矩阵，每个元素都是1或−1，其中有k个位置元素已经确定，并且这个矩阵满足每一行、每一列元素的乘积都是−1，问有多少种不同的矩阵。$1≤n,m≤1000,0≤k&lt;max(n,m)。$，答案对$P$取模。 ​ 首先，行的1要满足$(-1)^n$和$(-1)^m$是相等的（所有的格子的乘积）——所以当n和m不是同奇偶的时候，就无解。 ​ 注意到$0&lt;=k&lt;max(n,m)$，说明必然有一行（或者一列）是空的。（我们只讨论行是空的，列的不管，转化就行了）那么这一行有什么用的? ​ 如果我们考虑到，其它行的原先是-1还是1能算出来，然后得到满足每一行的情况。（通过组合），那么这个空的行一定是固定的——用来满足列的需求。 ​ 所以答案是除了这个空行，剩下的每一行独立的情况乘起来。 CF830D:给定n，现有深度为n的满二叉树，对于一个节点，给它与它的所有父亲连一条边。 问：得到的新的图有多少条不同的简单路径（1-&gt;2和2-&gt;1算不同路径）答案$$\\mod (1,000,000,007) n≤400$$ ​ fi,j表示从i-house中选出j条不相交的路径的方案数，那么答案就是fk,1​ i-house可以从两个i-1-house中转移过来​ 枚举fi−1,j和fi−1,k​ 如果让根成为单独的一条路径，那么fi,j+k+1+=fi−1,j×fi−1,k​ 如果不选根，那么fi,j+k+=fi−1,j×fi−1,k​ 让根与左儿子中的一条路径结合或和右儿子中的一条路径结合，那么fi,j+k+=fi−1,j×fi−1,k×2×(j+k)​ 从j+k条边中选出两条，让这两条边与根结合形成新的一条边，那么$f{i,j+k−1}+=f{i−1,j}×{fi−1,k}×C^2{j+k}\\times2$ ​ 然后因为答案是$f_{k,1}$切每次转移第二位最多减一，所以$j$,$k$只要枚举到$k$就行了。这样复杂度是$n^3$的。","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"组合计数","slug":"组合计数","permalink":"http://yoursite.com/tags/组合计数/"}]},{"title":"CF数论简单题","slug":"Codeforces/题解：2017暑假/数论相关","date":"2017-08-22T07:22:50.728Z","updated":"2017-08-29T13:16:43.381Z","comments":true,"path":"2017/08/22/Codeforces/题解：2017暑假/数论相关/","link":"","permalink":"http://yoursite.com/2017/08/22/Codeforces/题解：2017暑假/数论相关/","excerpt":"数论只会GCD……","text":"数论只会GCD…… http://codeforces.com/problemset/problem/222/C ​ 给出两个集合，第一个集合数的乘积是分子，第二个集合的数的乘积是分母，要求够造一个同样大小的集合，但是得到的分数是化简过的。 ​ 考虑先用线性筛求出素数(1e7)，然后跑质因数分解，保存在数组中，取出gcd——然后对于a和b，贪心的除去gcd。 http://codeforces.com/problemset/problem/446/C ​ 给定n个元素的数组a[]. ​ 操作1, l, r。要求对于l&lt;=i&lt;=r,a[i]] += f[i-l+1] ​ 询问2, l, r。范围Σa[i] (l&lt;=i&lt;=r) ​ $n,m&lt;=300000$ ​ 其中$f[i]$为斐波那契数列，$f[1]=1,f[2]=1$ 斐波那契数列 ​ 据说这是通项公式$\\Large fib(i)=\\frac{1}{\\sqrt 5}((\\frac{1+\\sqrt 5}{2})^n+(\\frac{1−\\sqrt 5}{2}) ^n)$ ​ 然后有一个神奇的事情是，$\\sqrt 5$在Mod$1e9+7$意义下的逆元是有解的！ ​ $sqrt(5)=383008016$ ​ $sqrt(5)/5=276601605$​ $(1+sqrt(5))/2=691504013$​ $(1-sqrt(5))/2=308495997$​ 利用公式​ 注意本题$q-1$的逆元为$q$​ 所以， $q\\times (q^n-1)/(q-1)=q^2(q^n-1)=q^(n+2)-q^2$ ​ 注意用线段树维护等比数列 http://codeforces.com/problemset/problem/711/E ​ 给定N,K，已知一年有2^N天，选取K个人，两个人的生日是在同一天的的概率要求，$1&lt;=n,k&lt;=1e18$，答案作为分数，对$1e6+3$取模——在取模之前约分！ ​ 考虑当$2^N&lt;K$的时候，显然是1,1。否则答案就是$(1- A_{2^n}^{k}) \\div (2^{nk})$，考虑如何化简这个式子。 ​ 首先，$A(2^n,k) = (2^n)∗(2^n−1)∗(2^n−2)∗ … ∗(2^n−k+1)$那么在把一个2^n约掉之后，考虑到他们的$gcd$一定也是2的幂次，显然分母所包含的2比分子包含的多所以只要看分子还有多少2即可。注意到，如果$k$是$2^m$的倍数，那么$2^n-k$也是$2^m$的倍数。所以只要看$(k-1)!$有多少个因子2即可。这个很好解决。 ​ 那么分子其实不会超过1e6+3次运算，因为可能出现0。 http://codeforces.com/problemset/problem/121/C ​ 对于一个数，如果它仅包含4或7，则称之为幸运数。求1~n的第K个置换，有多少幸运数位于的位置也是幸运数。$(n,k&lt;=1e9)$ ​ 考虑到，$13!$已经超过1e9了，所以事实上前面好多位都是不会变的。那么只要暴力加上去，再暴力算出后面的就行了。 http://codeforces.com/problemset/problem/772/C ​ 给定n个0~m-1内的数和m，构造一个尽可能长的所有元素都在0~m-1内的数列，并且使所有前缀积模m不相同且不在n个数中出现过。 ​ 考虑到所有的$gcd$都是非递减的。那么考虑小的$gcd$一定能通过乘上某个数变成其倍数的$gcd$，因此，把不同的$gcd$的个数求出来，跑一个$DP$（类似$DAG$最长路），然后可以得到一系列的前缀和。再通过前缀和，解同余方程得到最后的$Ans$。 ​ 为什么是非递减的？因为如果当前数a和$m​$的$gcd​$是x的话，那么对于1到m-1的任何一个数b，因为满足它们$gcd(a,m)=x​$，也就是要知道$gcd(ab,m) = y​$,首先，因为a和m都有公因数x，所以$\\large y=gcd(\\frac{ab}{x},\\frac{m}{x}) * x​$,这时候已经可以发现$y&gt;=x​$了。 ​ 考虑为什么一定有解？因为最终我们得到了前缀积。我们要做的是通过前缀积算出结果，设前面一个的前缀积是$a$，后面一个是$b$，那么目的是要找出满足$ax \\equiv b \\pmod {m}$，因为我们知道,$gcd(a,m)&lt;=gcd(b,m)$，所以设$gcd(a,m) = d$，$a=a/d$,$b=b/d$，那么现在还是找出$ax \\equiv b(mod m/gcd(a,b))$，那么我们要知道a关于m的逆元即可。而此时a和m已经互质，逆元可以通过$ex_gcd$求出。 http://codeforces.com/contest/396/problem/B 定义函数v(n)为不大于n的最大素数。定义函数u(n)为大于n的最小素数。求Σ1/(v(i)*u(i))(2&lt;=i&lt;=n)。$T&lt;=500,n&lt;=1e9$ ​ 裂项：这样假设有$n$，$v = v(n), u = u(n)； $ ​ $1/(23) + 1/(35) (5-3) + …… + 1/(vu) * (n-v+1) (注意最后不是u-v个）$ ​ $= 1/2 - 1/3 + 1/3 - 1/5 + …….. -1/v + 1/(vu) (n-v+1)$ ​ $= 1/2 - 1/v + 1/(vu)(n-v+1)$ ​ $p = uv + 2(n-v-u+1); q = 2uv;$","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"}]},{"title":"atcoder","slug":"Atcoder/atcoder","date":"2017-08-20T13:53:20.000Z","updated":"2017-08-29T06:42:24.889Z","comments":true,"path":"2017/08/20/Atcoder/atcoder/","link":"","permalink":"http://yoursite.com/2017/08/20/Atcoder/atcoder/","excerpt":"","text":"AtCoder Regular Contest 081 arc081C(2提交) 贪心 ​ 考虑找出可以两两配对的棒子，取最大的贪心即可 arc081D(1提交) 递推先把最左边的特殊考虑，然后分成4份： $*^{|– }{|–}$，那么右边的乘2；$^{|| }{||}$，那么右边的乘2；$^{—- }{– –}$，那么右边的乘3；$^{–| }{–|}$，那么右边的乘1 agc019C(4提交) DP考虑找到从起点到终点（每次只能往两个方向走）的最多的圆盘的个数，然后如果个数刚好等于行差+1或者列差+1,那么表示有一个圆盘要直接走过去，剩下的都是可以转弯的时候绕过的。","categories":[],"tags":[]},{"title":"想想","slug":"想想","date":"2017-08-19T11:48:55.000Z","updated":"2017-08-19T11:48:55.325Z","comments":true,"path":"2017/08/19/想想/","link":"","permalink":"http://yoursite.com/2017/08/19/想想/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"codeforces——2017暑假","slug":"Codeforces/题解：2017暑假/codeforces2017暑假","date":"2017-08-19T05:10:03.000Z","updated":"2017-08-29T13:14:17.869Z","comments":true,"path":"2017/08/19/Codeforces/题解：2017暑假/codeforces2017暑假/","link":"","permalink":"http://yoursite.com/2017/08/19/Codeforces/题解：2017暑假/codeforces2017暑假/","excerpt":"乱作一波题。 感觉无法忍受 不贴代码Orz","text":"乱作一波题。 感觉无法忍受 不贴代码Orz Codeforces Round #308 (Div. 2) CF552A给出一些矩阵，问这些矩阵覆盖的面积之和（不是并，重叠算多次） 模拟(1A) ​ 考虑直接把每个矩形的面积算出来，做一个和即可。 CF662B给你一个数字N，问$1$到$N$这些数字数码的长度之和是多少，1234的长度是4. 模拟(1A) ​ 分别考虑是否包含一位数，是否包含2位数……如果包含，直接求解，否则相当于剩余的有多少个x位数求解。 CF552C给你一个W和M，问是否用一些W^0,W^1,W^2……放在天平的两侧，构成M 进制转换(2A) ​ 从后到前处理每一位,如果某一位是0，不用动;如果某一位是1,那么表示右边要有这样一个砝码；如果某一位是m-1，说明左边要有这样一个砝码，但是加了左边的砝码之后，事实上相当于m加了这个值；其它情况都是无解。 CF552D给你一些点，问能构成多少个三角形。$N&lt;=2000$ 计算几何(1A) ​ 虽然$N&lt;=2000$，但是不知道为什么$O(N^3)$暴力+计算几何判断能过。 CF552E给你一些由1~9的数字，以及数字之间的’+’,’*’构成的表达式，在其中加入一个括号，使得表达式的值最大。 思维，暴力(1A) ​ 考虑到所有数都是大于等于1的，所以括号在乘法的两旁一定比在加法的两边要赚。考虑枚举所有括号，再暴力判断即可。 Codeforces Round #327 (Div. 1) CF590A:给你一个只有0和1组成的序列A，每次可以对序列A进行操作，每次操作是把A的每一个元素变成上一个序列的它，它左边，它右边3个数的中位数，其中1和n不变。问几次操作后会变成稳定——不会再改变，然后稳定时候的状态是怎么样的。 划分 ​ 对于中间的元素，只有一种情况会使得其改变：010或者101——其中它在中间。考虑可以把整个序列划分成一些稳定的两端构成的序列 如，把1010101010111010101划分成10101010101|1|1010101这3部分，然后每一部分最终都会变成4种形态:11110000或者00001111或者11111111或者00000000这种。 既然这样，就可以处理，然后答案对操作数取一个Max即可。线性O(n)扫描。 CF590B:您要从(x1,y1)到(x2,y2)，一开始风速为(vx,vy)，t秒后(wx,wy)，您的速度不超过Vmax，求最少到终点的时间，保证风速小于您的速度，风速和您的速度都是向量 二分答案 ​ 二分答案，然后假设人不动，判断是否可行。 CF590C:给定一个N*M的矩阵，这个矩阵里面有’1’,’2’,’3’,’.’,’#’,你可以把’.’改成桥，使得所有1,2,3四联通，问最少把多少个’.’改变，其中‘#’不能改变，如果不能输出-1。——其中’1’,’2’,’3’本身是连续的 BFS ​ 注意到，桥一定会在一个点交汇——这个点可能在某个国家里面，也可能在’.’位置。我们可以考虑枚举这个交汇点的位置，然后把3个国家到这个点的Dis全部加起来，取Min就是结果为什么是对的呢？这个不会有重复吗？会的。不过必然有一个点没有，那就是交汇点。我们可以预处理出某一个国家到一个点路上最少经过的’.’的个数——我用循环入队一直T，后来改成优先队列做的——事实上还有更好的方法。然后枚举每一个点，当然，如果这个点是’.’会被计算3次，要减去。 CF590D:n个数，求最多相邻两两交换S次，使前K个数的和最小 DP ​ 注意到，N*(N-1)/2&lt;=S的时候，S的大小已经没有什么用途了考虑用dp[i,j,k]表示处理到前i个数字，其中已经交换了j次的，前k个已经确定的最小数字之和考虑把第i个交换到第k个位置——或者不交换。不交换的话$dp[i,j,k] = dp[i-1,j,k]$交换的话$dp[i,j,k] = dp[i-1,j - (i-k) , k-1] + a[i]$用滚动数组优化一下答案就是$dp[N,X,K] (X&lt;=S)$ Codeforces Round #330 (Div. 1) CF594A:数轴上有N个点，N是偶数。有两个人，依次取走一个点，直到最后剩下2个点，其中第一个人（先取要最后剩下的点的距离最大），第二个人要使得距离最小，问距离最小是多少。 博弈 ​ 如果您作为第二个人，您一定会去取两端的。如果存在答案区间L,R。显然，第二个人一定会取L,R以外的。 ​ 相反，第一个人会取L,R以内的，因为L,R以外的第二个人会去取。所以答案就是在其中找一段区间，使得内部有(N-2)/2个点，然后区间最小。 CF594C平面上，给你n个点，然后你可以删除k个点然后让你用一个两边平行于坐标轴的矩形，去围住这n-k个点，问这个矩形的面积，最小可以是多少$(K&lt;=10)$ ​ 暴力，考虑到只会删除上下左右4个方向的点，先暴力得到上下删除哪些点，然后再暴力得到左右删了哪些点，用一个标记数组维护。 CF594D:给你n个数(n&lt;=200000)，每个数&lt;=1e6，给出Q个询问，每个询问给出l,r,问的值是多少。 ​ 回顾一下欧拉函数的求法 $$\\large \\varphi[n] =n* \\prod_p^{p是n的质因数}(p-1) / p$$ ​ 同样的，扩展到区间 $$\\large \\varphi[Π(A[L]-A[R])] = \\prod_{i=L}^{R}(A[i]) * \\prod_p^{p是这些乘积的质因数}(p-1)/p$$ ​ 这题没有修改操作，一切都是询问，可以考虑离线处理。我们把所有询问按照右端点排序。那么如何处理(L~R)这一段的乘积的欧拉函数呢？事实上，L~R中间的数的乘积我们可以通过前缀$O(1)$得出来，我们需要的就是L~R这一段所有数包含的质因数(p)的(p-1) / p，当然，在Mod意义下是逆元。这里，我们先假设每个数出现不同的质因数。计$Xi = (p1-1) / (p1) * (p2-1) / p2$……，其中p1,p2是ai的质因数同样的，我们可以保存前缀，算得$X1$~$Xr$的乘积，然后再算得到$X1$~$X_(l-1) $的乘积，然后可以O1求解。然而，我们要知道，每个数可能拥有同样的质因数。显然，由于我们已经按照右端点排序 ​ 我们可以把所有可能的质因子保存在最右边出现质因子的地方。用一棵树状数组维护前缀Xi的乘积。对于新加入的一个数$Ai$，考虑得到它的所有质因数，如果这些质因数还没有出现过，那么把(p-1)/p弄上去，否则，不但要把(p-1)/p弄到这个节点上，还要把p / (p-1)弄到前面出现p的节点上，以消除p的重复影响。 Codeforces Round #333 (Div. 1) CF601A有个地方有些城镇，城镇与城镇间如果有铁路相连，就不会有公路相连，没有铁路连接的城镇就会有公路相连。给你n个城镇数目，m铁路线，问同时从1出发，分别坐火车和坐汽车到达n点，两者都到达的时候最少的用时。其中火车和汽车不能同时到达中间点。 ​ 跑2次最短路即可。 CF601B给定n个hi，然后定义·if n &lt; 2, ·if n ≥ 2, over all 1 ≤ i &lt; j ≤ n 给出区间L,R，问区间L,R的所有子段的L函数之和。 脑洞，单调栈 ​ 把$i$看成横坐标，$h[i]$看作纵坐标，那么$L(h)$其实就是一个区间中的某两点之间的斜率绝对值，从而可以证明$L(h)$一定是坐标相邻的点的斜率的绝对值$L(h) = abs(h[i+1] - h[i]) ——1&lt;=i&lt; n$设$D[i] = h[i] - h[i-1].$那么答案就是各个$f[i]$的贡献和，这个可以通过单调栈做出来。通过单调栈，可以得到这个位置向左严格最大到哪边，向右不严格最大到哪边——主要是为了让每个区间都加入计数。 CF601C有$n$场比赛，每一场比赛都有$m$人参与。每场比赛的得分都是这个人的排名（没有相等的）总分是$n$场比赛的分数之和。总排名定义为：总分严格小于他的人数$+1$。已知小K在$n$场比赛中的排名。所有人的水平相同，求小K的期望总排名。 DP ​ 考虑到直接计算排名比较麻烦，设$f[i,j]$表示$i$场比赛之后，总分为$j$的期望人数，那么可以得到一个转移方程：$\\large f[i,j] = \\sum\\frac{f[i-1][j-k]}{m-1}(i&lt;=k&lt;=m,k≠a[i])$，通过这个式子观察之后我们可以发现，可以前缀和优化转移，于是采用差分方法实现。 Codeforces Round #334 (Div. 1) CF603A有一个长度为n的1,0组成的串，可以将其中连续一段翻转，使得剩下的1010交替出现的子序列最长。 DP(1A) ​ 考虑用$f[i]$,$g[i]$,$h[i]$分别表示还没有翻转，正在翻转，翻转完了的$ans$，最后取一个$max$即可。 CF603C，有n堆石子，如果某一个石子是偶数，可以选择得到k堆石子数/2个，奇偶都可以得到石子数-1个石子。没法操作者败 博弈(3A) ​ 考虑SG函数打表找规律，当i为奇数的时候，$SG[i] = mex SG[i-1]$，当i为偶数的时候,能执行第二种操作，所以$SG[i] = mex(SG[i-1],SG[i/2] xor SG[i/2]……共k个)$，由此可以得到，答案之和$k$的奇偶有关，当$k$是奇数的时候，$SG[i] = mexSG[i-1],0$，所以往后一定是01交替出现，当$k$是偶数的时候，SG当$i$是奇数的时候为0，否则只需要$SG[i/2]$递归调用，取$mex$即可，注意到，不会超过$log$次调用。 Codeforces Round #335 (Div. 1) CF605A给定$n$的一个排列，每次可以把一个数放到开头或末尾，求变为升序的最少步骤 DP(1A)​ 考虑就是寻找到一个每位都递增1的最长上升子序列，然后这些不动，其它改变。用DP求即可。 CF605B有一个$n$个点，$m$条边的图，然后$m$条边中有$n−1$条边构成了最小生成树，然后边权与是否作为$MST$的边告诉你，要构造出这个图。 构造(2A) ​ 逐个添加，如果应该作为最小生成树的，考虑可以把1和这个节点连接，如果不应该作为最小生成树的，考虑把剩下可以用的边连接，如果无法连接，就是无解。当加入一个新节点，可以用的边加入这个点到前面非1的位置的。新节点只有当最小生成树的边加入时才增加。 CF605C有$n$项工作，第ii项工作每天可以带来$ai$的经验，$bi$的钱。问最少几天可以得到$p$的经验和$q$的钱。工作天数可以是小数，每次只能进行一种工作。 二分答案，凸包(10A)——注意LL ​ 考虑把(ai,bi)看作平面上的一个点，注意到，一个点可行，当且仅当这个点是平面的凸包上的点——否则一定有2个点比这个点优。进一步，一定是凸包一个点，或者相邻两个点组合得到的。 ​ 考虑二分答案，然后用类似解二元一次方程的方法，把凸包相邻2个点，或者凸包上的一个点组合得到的算出来，输出解即可。 CF605D玩家有两个属性$x,y$，有$n$个魔法。对于第$i$个魔法，用$(ai,bi,ci,di)$描述。当$ai&lt;=x,bi&lt;=y$时，玩家能使用这个魔法。之后玩家的属性$x=ci,y=di$。求施展第n个魔法最少需要多少次。输出方案，答案不唯一。 BFS，树状数组，set(2A) ​ 相当于一个二维平面，因为是最小步数，很容易想到$BFS$，但是$BFS$的扩展节点只能扩展这个的左下方的，为了快速扩展（线段树套线段树显然可行）——用一个更容易实现的，考虑树状数组（离散化后的x坐标）套$set$，来快速维护下一个应该扩展的点，那么就是在左下角寻找一个满足条件的，（用树状数组），然后用$set$的lower_ bound快速寻找，然后扩展。时间复杂度$O(n log(n) log(n) )$ Codeforces Round #336 (Div. 1) CF607A点有位置和能量，ii个点被选择，那么在ii左边它这个能量的位置内的所有点都不能选择，如果现在从右到左依次选择点。现在可以在最右边放置一个点，能量和距离随意，问各种情况下最小摧毁的点的个数。$N&lt;=100000,ai&lt;=1000000$ DP(1A) ​ 坐标范围比较小，考虑用f[i]表示到i位置最多能放的点，简单转移一下即可。 CF607B长度为$n$的字符串，每次消去一段连续的回文串，剩下的两端重新拼接成一个新的串，问最少需要消去多少次。$n&lt;=500$ DP(1A) ​ 考虑用$dp[i,j]$表示从i到j，最多要消几次。如果$(i,j)$的长度大于2，并且$a[i]$ = $a[j]$，那么这两个可以等下并到里面去消，所以 $dp[i,j] = dp[i+1,j-1]$。或者从中间某个k，使得左右分别消， ​ $dp[i,j] = min(dp[i,k]+dp[k+1,j])$ CF607C有两个独立的坑道，由$“NSWE”$表示。两个球在各自坑道的起点。之后对两个球做相同的操作，上下左右。保证两个小球保持一致的动作，其中一个撞墙的话不用管。问能不能保证两个小球都能从起点到达终点。到达终点后，还有可能因为操作而退出。 脑洞，哈希(1A) ​ 考虑依次让两个球分别到达终点，可以猜测一个结论，无法到达当且仅当第一个球达终点后，第二个球需要到达终点的步骤，恰好使得第一个球退出（证明有些困难）。于是可以改变第一个球轨道的方向，就变成字符串匹配的问题。从而用hash使得前一个串的后缀对称后得到后一个串的后缀，那么就无解。 Good Bye 2015 CF611C:题意：有一个$n×m$的网格，‘#’不能摆。有$Q$个询问，每个询问$(r1,c1,r2,c2)$求出这个子矩形内可以有多少种方式放一个$1×2$的骨牌。$n,m&lt;=500,Q&lt;=100000$ 容斥 ​ 考虑得到$a[i,j]$，表示询问为$(1,1,i,j)$的答案。 ​ 那么对于询问，可以拆分成总的减去两个，再加上一个小的。这样还不够，因为类似的一个里面一个外面的多余了，得$O(n)$扫一遍判断。 CF611D:把一个长为$n$的数字串拆成多个串，要求这些串的数值递增的，并且没有前缀0，问有多少种分法。$n&lt;=5000$ DP，LCP。定义状态$f[i][j]$表示$[1,i]$中划分了最后$j$个的方案数。发现状态难以优化，考虑从加速转移入手。假设前一段划分的长度为$k$，注意到当$k&lt;=j−1$时，显然能够转移，即$f[i][j]=\\sum ^{j−1}_{k=1}f[i−j][k]$，这一部分可以前缀和优化。还有可能是从$f[i−j][j]$转移到$f[i][j]$，就需要比较$[i−2j+1,i−j],[i−j+1,i]$的大小。由于长度相等，实际上就是在比较字典序。而比较字典序有一个常用的方法，可以求出以$i,j$开头的最长公共前缀，记为$lcp(i,j)$，这样预处理后就可以$O(1)$转移了。 Wunder Fund Round 2016 (Div. 1 + Div. 2 combined) CF618C给定n个点$(xi,yi)$，求一个三角形ABC，满足其它的点都在三角形的外面，输出任意一个三角形三个点的下标，n&lt;=100000。 构造，计算几何 ​ 考虑排序之后，最前面的3个点一定的是满足条件的，否则如果3点共线，只需要把第3个点继续往后找即可， CF618E原来有一个N个段的长度为1的段，然后有m个操作，操作1是给定第X段，然后把第X段延长，变成多少Y，然后操作2是把某一个段按照原先的左端点旋转α°，每次操作完了询问原先最右边的端。 $n,m&lt;=300 000$ 线段树 可以用线段树维护两个点之间的相对位移这里有一些公式：假设任意点(x,y)，绕一个坐标点(rx0,ry0)逆时针旋转a角度后的新的坐标设为(x0, y0)： $x0= (x - rx0) \\times cos(a) - (y - ry0)\\times sin(a) + rx0 ;$ $y0= (x - rx0)\\times sin(a) + (y - ry0)\\times cos(a) + ry0 ;$ 显然，延长操作只是单点修改。——保存位移之后只要同比例缩放就行了.那么旋转呢？这是一个区间修改。对于后面全部整段，都是需要绕着某个点进行旋转的。其实，角度是可以叠加的:___大家可以自己画图，然后用延长用四点共圆证明……角度竟然是可以叠加的! 然后就好做多了……QAQ。——本来还想着用矩阵结合律。。。 CF618F:给定两个多重集$A,B$，每个数$∈[1,n]$。在$A$中选取一个含$Ka$个元素的非空子集。在$B$中也是如此（有$Kb$个元素）。要求使得两个子集之和相等。$n&lt;=100000$。 构造 ​ 注意，每个数是在1~n之间的。考虑把条件加强，如果只是寻找连续上面一段和下面连续一段，使得和相同。 ​ 设$SA[i]$，$SB[i]$为A串的前缀和，B串的前缀和。不妨设$SA[n] &gt;= SB[n]$——否则可以交换，那么对于每个SA，我们找到在第二个序列中，找到满足SA[i] &gt;= SB[j]的最大的j。不难发现，$0&lt;=SA[i]-SB[j]&lt;=n-1$。而算上第0项，i总共有n+1种情况，所以一定能通过连续一段来构造。 ​ 这样，我们可以通过上述策略去构造。 AIM Tech Round (Div. 1) CF623A:一个由$a,b,c$组成的字符串，可以这样生成一张图，当$s[i]$与$s[j]$不是一个$a$一个$c$时，$i$与$j$连一条边。给定生成的图，求是否存在字符串能生成这张图。$n&lt;=500$ ​ 考虑把所有和其它所有点连边的赋值成b，然后剩余的，随便选一个赋值成a，将和他有连边剩余的赋值成c，然后验证答案是否矛盾。 CF623B:有一个数列，可以删除其中一段，删一个代价为$a$。也可以选择对其中一些数进行增加或者减少1，每次代价为$b$，问最后使得所有的$gcd$比1大，最小代价是多少。 DP ​ 注意到，最后$a1$，或者$an$一定是剩余的——可能进行一些操作。所以答案的$gcd$一定是$a1-1,a1,a1+1,an-1,an,an+1$这些数的质因子中的某一个。考虑枚举出质因子后，用3个DP分别表示还删，删完了，还在删的状态。 CF623C:平面上有$n$个点$(xi,yi)$。每个点可以变成$(xi,0)$，或$(0,yi)$。所有的点变换之后，两点最大距离的平方的最小值是多少。n&lt;=100000 二分答案 ​ Codeforces Round #342 (Div. 2) CF625A你有n元，有2种包装的物品，一种是a元，一种是b元，但是花了b元能反c元，问最多能获得多少武平$(1&lt;=n&lt;=10^18)$ 模拟，贪心(1A) ​ 考虑如果b-c比a要赚，那么先选择一个b，然后加上c……最后再去选a。模拟一下就行了。 CF625B在第一个串中最少把多少个字符修改为#，才能第一个串不包含第二个串。 贪心，KMP(3A) ​ 考虑一定是越后面修改越好的，所以贪心，同时跑的时候来一发KMP加速——其实也不需要。 CF625C让你用$1-n \\times n​$这些数填充$n\\times n​$矩阵，要求每行的数字严格递增、每个数字只能用一次且保证第k列的数字和最大。 贪心(1A) ​ 考虑把小的都放在左边，那么然后能往右边再往右边，贪心选数即可。 VK Cup 2016 - Round 1 CF639B：构造一棵树，使得树有n个节点，直径是D，树高是H，不存在输出-1 构造 显然，D&gt;2*H无解。否则，考虑先把直径画好。 ​ 直径分为两部分，两部分分别画好，然后再把剩下的点弄到1号那里 ​ D=H要特殊处理。 CF639C：定义一个合法的n次多项式f(x)，满足最高项系数an!=0，所有系数ai都是整数，且绝对值不超过K。 现在给您一个合法的n次多项式P(x)，但P(2)!=0。您需要改变其中一个系数，仍然得到一个n次多项式Q(x)。满足Q(2)=0。求方案数。$n&lt;=200000$ 多项式 ​ 考虑把系数转化成二进制，除了最高位。 ​ 那么要使得可以消掉，必然是满足当前的系数左边没有1或者-1。 ​ 那么考虑把系数转化成二进制后，倒着把系数推回来，得到右边一段的系数相当于是多少，记为sum ​ sum的求值可以每次 2+当前元素得到。那么如果i左边的系数（小的系数）满足都是0，那么我们知道，当前这个Q的值显然就是$sum 2^i$。所以只要把这一位的系数减去这个sum，就能保证整个$Q(2) = 0$。 ​ 因此，我们只需要先正着扫一遍，得到最低的非0位的位置。 ​ 然后倒着扫一遍，得到sum，并统计。 ​ 注意的是，当sum&gt;2*k的时候，已经没有必要继续统计了。 CF639D：有n个人，每个人都有自己的贡献ti（任意整数）可以花费b，使得某个人的贡献+5,花费c，使得某个人的贡献+1.求至少使得k个人的贡献相等，最少需要的花费。$k&lt;=n&lt;=200000,$$1&lt;=b,c&lt;=1000$ $|t_i|&lt;=1e9$ 优先队列维护前k小的数的和 ​ 考虑首先对于输入的数排序。同时如果$b=min(b,c\\times 5)$，那么得到所有可能最后的相同的那个数（一定不会超过某个数+0,1,2,3,4,5这个范围），然后考虑枚举所有的Ans，下一步的操作是要在所有数中寻找满足条件的最小花费的k个数。可以把花费看作一些数，先变成对应的mod 5=r的数，然后再一直加上b。考虑到我们已经排序了，所以这个右指针（哪些是包含的）是会单调递增的。设x mod 5 = r;考虑预处理出每一个数到mod 5 = r的数值为t[i,r]，那么最后的最小花费必然是选出一些i，使得$min(∑(t[i,r] - a[i]) \\times c + ∑(x - t[i,r]) / 5 \\times b)$，考虑到x[i]和t[i,r]的余数是一样的，可以化简为 $$\\large k \\times （x / 5 \\times b） + \\sum _{i}^{t[i,r]&lt;=x}(t[i,r] \\times c - a[i] \\times c - t[i,r] / 5 \\times b)$$ 考虑维护5个堆，得到这5个堆中元素和，压入一个元素，加上这个sum，如果元素个数超过k，将大的弹出来，减去这个sum。 VK Cup 2016 - Round 2 CF641B原来有一个N*M的矩阵，要求满足一些操作(q个）：循环左移，循环上移，在给定位置加数，给你最后的矩阵，问最初的矩阵是？？ 模拟(1A) ​ 考虑把操作倒着执行，当然，左移变成右移，上变成下，然后就可以了。 CF641C给定n个数，1, 2, 3, 4, 5, 6,…, n。有两种操作，第一个操作是所有数向右边移动x个位置，第二个操作奇数和偶数的位置互换。$n &lt;= 1,000,000$ $q &lt;= 2,000,000$ 模拟 ​ 考虑到，比如说有序列12345678，那么不管怎么操作，1357，2468的相对位置是不变的（循环一下），所以我们只需要知道1和2的位置，就能确定所有的位置。而1和2的位置可以通过模拟出来。 CF641D:有两个不同的骰子，点数为$1~n$。得到每个点数的概率可能不同（总和一定是$1$）。掷出这两个骰子，得到点数$a$，$b$。取$max(a,b)$, $min(a,b)$。给出$max(a,b)=c$的概率分布，和min(a,b)=c的概率分布。还原两个骰子点数的概率分布。所有概率之和为$1$。$n&lt;=100,000$ 概率(1A) ​ 注意到，我们可以列出这样2个方程：​ $sumy x[p] + sumx y[p] + x[p] y[p] = Pmax$​ $x[p] + y[p] = Pmax + Pmin$​ 然后解这两个方程​ $y[p] = Pmax + Pmin - x[p]$​ $sumy x[p] + sumx (Pmax + Pmin - x[p]) + x[p] (Pmax + Pmin - x[p]) = Pmax$ ​ $p[x]^2 + (Pmax + Pmin + sumy - sumx) x[p] + ((Pmax + Pmin )sumx - Pmax) = 0$​ 注意，当b^2-4ac几乎等于0的时候(可能小于0），那么不妨让b^2-4ac等于0 CF641E:有三个操作:$1$ $x$ $y$，在第$x$秒插入一个$y$；$2$ $x$ $y$，在第$x$秒移走一个$y$ ；$3$ $x$ $y$, 问第$x$秒有多少个$y$ $(1 ≤ n ≤ 100 000) $ 树状数组，MAP(2A) ​ $multiset$的$count$复杂度竟然不是$log$的……好吧，这题把时间离散化，然后用树状数组，每个节点保存一个$MAP$，复杂度是$log^2$的，然后就可以过了。 Codeforces Round #345 (Div. 1) CF650D给定一个长度为n的数列，和m个询问，每个询问给出Ai,Bi表示把第Ai个数改成Bi之后，这个数列的最长上升子序列（严格大于,询问相互独立） 线段树 ​ 具体做法分成2部分。一方面，我们要求得改过之后经过改过的点的LIS。这个比较好实现，离散化之后排个序离线用两棵线段树正反两次扫描维护。另一方面，我们要求得不经过这个点的LIS我们再把这个分为两部分。如果原来的LIS（至少有一条）不包括那个点，那么答案就是原来的LIS。如果所有的LIS都包括那个点，那么答案就是原来的LIS-1。一个点如何可能是LIS中的一个呢？注意到，当他的前缀LIS加上后缀LIS等于总的LIS+1的时候。那么我们只需要统计，这个点是不是唯一的这个位置。怎么样算唯一呢？就是它的前缀LIS（或者后缀）长度，除了它，没有别的点了。因此，我们只需要满足2个条件，这个点就是原来的LIS-1了。 ​ $1、L(LIS)_i+R(LIS)_i=Lis+1$ $2、there.is.only.one.L(LIS)_i$ ​ 还是通过正反两次扫描实现。 IndiaHacks 2016 - Online Edition CF653E:n个点，m条不能相连的边，点1的度为k（相连的边有且仅有k条）。问是否能构成一棵树。 set维护BFS ​ 考虑将1除去之后，得到剩下的联通块，其中有一个联通块没有向1的边，说明impossible，否则，如果联通块的数量大于等于k，说明无解。——因为联通块里面是可以随意连的。那么如何求联通块呢，考虑BFS。但是普通的BFS的复杂度会到$O(N^2)$，而这题的N比较大，是撑不住的，注意到，选取点有很大的冗余——因为每个点最多只会被访问1次，那么如何选点的？考虑用一个set维护还没有被访问过的点，访问一个点，将这个点从set中删去。对于某个点开始，寻找set中的元素，如果可以访问，那么访问，同时删去。 ​ 注意到，这个时间复杂度只有$O((n+m)log n)$。 Codeforces Round #347 (Div. 1) CF663B:给定一些类似$?+?-?=n$表达式，然后知道最后一个数字为n（给定），然后在前面填（1~n)的数，问可不可能有满足条件的等式，可能输出Possible并给出一组解。给定n个数，1, 2, 3, 4, 5, 6,…, n。有两种操作，第一个操作是所有数向右边移动x个位置，第二个操作奇数和偶数的位置互换。$n &lt;= 1,000,000$ $q &lt;= 2,000,000$ 脑洞(2A) ​ 考虑对于使得表达式最小的式子，加是+1，减是-n，再考虑使得表达式最大的式子，加是+n，减是-1，那么如果n在两者之间，这个式子一定可以通过一定的改变得到，否则就是不行。 ​ 为了实现简单，只要统计加法有多少，减法有多少就可以得到了。构造主要可以这样实现，对于每一个位置，找到一个最小的使得后面依旧可以填的(这个值不会很大)。这样好实现很多。然后n去掉这个值，继续处理。虽然可以二分，但是麻烦。注意如果你是改变n的，记得保存一个n的镜像。 CF663B:给出了一个数字的后缀，要求最终这个数字大于等于1989，并且在最小的情况下，这个数字之前没有被占用过。求最终拼凑的数字。 不会QAQ CF663C:有一个n个点，m条边的无向图，一开始，每条边的颜色都是给定的，然后玩家选择一个顶点，把相邻的边的颜色反转一下，问使得所有边颜色相同最少反转几下，输出那些反转的顶点，不可以输出-1.$(1 ≤ n, m ≤ 100 000)$ 并查集(6A) ​ 不失一般性，考虑把所有边的颜色变成红色，那么可以把整个图分成不同的联通块，每个联通块分别处理。如果有一条边是蓝色的，说明这条边的左右两端的状态是不同的，如果是红色的，说明状态是相同的。对于一个联通块，显然只有2类。那么我们只需要在2类中取较小的一类即可。 ​ 考虑用2个并查集，分别维护相同类和不同类。 CF663D: 不会QAQ CF663E:有一个n*m的表格，包含0或1.每一次可以选择一行，或一列翻转(0&lt;-&gt;1)。求一些操作后，1的个数的最小值。$n&lt;=20, m&lt;=100000 $ FWT优化(4A) ​ 很容易想到一个暴力，是枚举行变化$O(2^n)$，然后贪心验证$O(n*m)$，然后利用位运算，可以通过预处理先得到$v_i$表示$i$，或者$i$的翻转包含的最少的1的个数($i$是一状压二进制)，$v_i = min(|i|,n-|i|)$，那么设某一列状压之后是$A_i$，当前枚举到行变化是$s$，那么如果用$Ans[s]$表示在s状态能够获得的最大$Ans$，用$cnt[i]$表示所有列中$i$出现了几次可以得到， $$\\large Ans[s] =\\sum{i=0}^{2^n-1} v{s⊕i} * cnt_i$$ ————然后，上面这个式子是可以通过FWT优化的，因为这个等价于存在两个向量$cnt$和$v$，然后要求它们的亦或卷积得到的另一个向量。 $$\\large Ans[s] = \\sum_{j⊕k =i}cnt_j*v_k$$ 因此，跑一个 $$FWT(A) = (FWT(A0)+FWT(A1),FWT(A0)-FWT(A1))$$ $$IFWT(A)=IFWT((A0+A1) \\div2,(A0-A1)\\div2)$$ 最后来一个统计就有结果了——虽然我也不知道怎么构造，我也不知道怎么证明。 Codeforces Round #349 (Div. 1) CF666A给一个字符串，然后你你需要切一个长度至少为5的前缀下来，然后剩下的都得切成是长度为2或者3的字符串你需要连续的切出来的字符串都不一样，问你能够切出多少不同的块 DP(1A) ​ DP，考虑后面相邻的即可。 CF666B给定一个有向图，请您选择4个不同的节点，使得从第一个点出发，经过第2，3个点，最后到达第4个点。最短路之和最大。n&lt;=3000, m&lt;=5000。按照顺序输出选择的节点。 CF666C DP(抄题解1A) ​ 首先需要看出方案数只和模式串的长度有关，和具体的字符无关。 ​ 由于模式串的长度和规模为$10^5$，则不同长度模式串最多有$\\sqrt {2*10^5}$种，因而如果如果我们若能在线性时间内推出某长度下的结果，复杂就会变成$O(n\\sqrt n)$。 ​ 具体记数的过程比较复杂，需要考虑枚举模式串为第一次匹配的情况。 ​ 若$S$为主串，模式串为$P$，$a_i$为$|S|=i$时的方案数。 ​ $ai = 0$——$i&lt;|P|$ ​ $ai=26\\times a_{i−1} + C(n−1,i−1)\\times25^{i−|P|}$—–$i⩾|P|$ ​ $26a_{i−1}$包含了第一次匹配在$S1⋯Si−1$出现的情况，最后一个位置放啥都行。 ​ $C(n−1,i−1)\\times25^{i−|P|}$ 是在$S_i$才出现第一次匹配的情况。$S1⋯S{i−1}$能匹配$P1⋯P{|P|−1}$且$Si=P|P|$。最后一位确定，然后在$S1⋯S{i−1}$选择$Pi⋯P{|P|−1}$的匹配，即$C(n−1,i−1)$，剩余的位置每个位置都含有$25$种可能，因为不能是它之后第一个确定的位置的字符。 VK Cup 2016 - Round 3 CF643B给定$N$,$K$和$a$,$b$,$c$,$d$，问是否存在这样两条路劲，使得这两条路劲经过所有城市，并且从a到b，和从c到d，长度为N，整个边数不超过K。$(4 ≤ n ≤ 1000, n - 1 ≤ k ≤ 2n - 2) $ 构造（4A） ​ 考虑分类讨论，能公用的尽量公用，注意到n=4的时候，a,b,c,d互不相同是不行的 CF643C要把1～n分成k组，每组内的数必须连续，组与组不相交且每个数必须属于一个组，并且任意i有一个参数$ti$。 如果$[l,r]$为一组，那么从l走到l+1的概率是$tl$，从$l+1$走到$l+2$的概率是$\\frac{tl+tl+1}{tl+1}$，依次类推，从$l$要么走到$l+1$，要么原地不动，那么组$[l,r]$的费用就是从$l$走到$r$的期望次数。现在要分成k组，让总费用最小，每个数仅能属于一个组。","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"USACO5.4","slug":"USACO/training/Section5/USACO5.4/USACO5-4","date":"2017-08-18T08:43:25.000Z","updated":"2017-08-20T14:51:00.695Z","comments":true,"path":"2017/08/18/USACO/training/Section5/USACO5.4/USACO5-4/","link":"","permalink":"http://yoursite.com/2017/08/18/USACO/training/Section5/USACO5.4/USACO5-4/","excerpt":"[TOC]","text":"[TOC] USACO5.4.1题意给定一个图，问一条从起点到终点，再从终点到起点，除了起点和终点外，不能经过重复节点的路劲，这条路劲最长有多长。（节点&lt;=100) 而且，是东西方向的，所以不存在类似1–&gt;3–&gt;2–&gt;4的，只有1–&gt;2–&gt;3–&gt;4的。 原题USACO5.4.1-Canada Tour Canada Tour You have won a contest sponsored by an airline. The prize is a ticket to travel around Canada, beginning in the most western point served by this airline, then traveling only from west to east until you reach the most eastern point served, and then coming back only from east to west until you reach the starting city. No city may be visited more than once, except for the starting city, which must be visited exactly twice (at the beginning and the end of the trip). You are not allowed to use any other airline or any other means of transportation. Given a list of cities served by the airline and a list of direct flights between pairs of cities, find an itinerary which visits as many cities as possible and satisfies the above conditions beginning with the first city and visiting the last city on the list and returning to the first city. PROGRAM NAME: tour INPUT FORMAT Line 1: The number N of cities served by the airline and the number V of direct flights that will be listed. N will be a positive integer not larger than 100. V is any positive integer. Lines 2..N+1: Each line contains a name of a city served by the airline. The names are ordered from west to east in the input file. There are no two cities in the same meridian. The name of each city is a string of, at most, 15 digits and/or characters of the Latin alphabet; there are no spaces in the name of a city. Lines N+2..N+2+V-1: Each line contains two names of cities (taken from the supplied list), separated by a single blank space. This pair is connected by a direct, two-way airline flight. SAMPLE INPUT (file tour.in) 8 9VancouverYellowknifeEdmontonCalgaryWinnipegTorontoMontrealHalifaxVancouver EdmontonVancouver CalgaryCalgary WinnipegWinnipeg TorontoToronto HalifaxMontreal HalifaxEdmonton MontrealEdmonton YellowknifeEdmonton Calgary OUTPUT FORMAT Line 1: The number M of different cities visited in the optimal itinerary. Output 1 if no itinerary is possible. SAMPLE OUTPUT (file tour.out) 7 Namely: Vancouver, Edmonton, Montreal, Halifax, Toronto, Winnipeg, Calgary, and Vancouver (but that’s not a different city). 做法这是一个无向图——至于字符串可以用Map来解决。 那么不能经过重复节点的，要到终点的2条路。 考虑用$f[i,j]$表示2条路劲，其中一条到了i，第二条到了j最多经过的城市 考虑对于一个城市k$$f[i,j] = max(f[i,k] + 1，f[k,j]+1);$$如果j到k右边，那么左边的是可行的，如果k到j有边，那么k到j是有边的 这样是不会重复的。 可以用归纳法解决，如果f[i,k]或者f[k,j]没有重复，那么加上只有一个城市到了j，所以也是不会有重复的。 把f函数改改 可以得到这些： ​ 1、$f[i,j] = f[j,i]$ 因此只要考虑把第二个k改变即可。 $f[i,j] = max(f[i,k] + 1)$ 百度到的做法Orz 相当于（除了1和n）每个点内部有容量为1，费用为1的边，外部是容量为1费用为0的边。跑最大费用最大流$Orz$ 好了，不管下面的做法。 给出DP代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*ID:cqz15311LANG:C++PROG:tour*/#include&lt;bits/stdc++.h&gt; using namespace std;string a,b;map&lt;string,int&gt; Name; const int inf = 0x3fffffff;bool g[105][105];int f[105][105],n,m,ans;char s[105],t[105];int main()&#123; freopen(\"tour.in\",\"r\",stdin); freopen(\"tour.out\",\"w\",stdout); cin &gt;&gt; n &gt;&gt; m; for (int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; s; Name[s] = i; &#125; memset(g,false,sizeof(g)); for (int i=1;i&lt;=m;i++)&#123; cin &gt;&gt; s &gt;&gt; t; g[Name[s]][Name[t]] = true; g[Name[t]][Name[s]] = true; &#125; f[1][1] = 1; for (int i=1;i&lt;=n;i++)&#123; for (int j=i+1;j&lt;=n;j++)&#123; f[i][j] = -inf; for (int k=1;k&lt;j;k++) if (g[k][j] &amp;&amp; f[i][k]&gt;0 &amp;&amp; f[i][k]&gt;f[i][j]) f[i][j] = f[i][k]; f[j][i] = ++f[i][j];// printf(\"%d %d:%d\\n\",i,j,f[i][j]); &#125; &#125; ans = 1; for (int i=1;i&lt;=n;i++) if (g[i][n] &amp;&amp; f[i][n] &gt; ans) ans = f[i][n]; cout &lt;&lt; ans &lt;&lt; endl; fclose(stdin); fclose(stdout); return 0;&#125;/*Executing... Test 1: TEST OK [0.000 secs, 4236 KB] Test 2: TEST OK [0.000 secs, 4236 KB] Test 3: TEST OK [0.000 secs, 4236 KB] Test 4: TEST OK [0.000 secs, 4236 KB] Test 5: TEST OK [0.000 secs, 4236 KB] Test 6: TEST OK [0.000 secs, 4236 KB] Test 7: TEST OK [0.000 secs, 4236 KB] Test 8: TEST OK [0.000 secs, 4236 KB] Test 9: TEST OK [0.000 secs, 4236 KB] Test 10: TEST OK [0.000 secs, 4236 KB] Test 11: TEST OK [0.000 secs, 4236 KB]All tests OK.YOUR PROGRAM ('tour') WORKED FIRST TIME! That's fantastic-- and a rare thing. Please accept these special automatedcongratulations.*/ USACO5.4.2题意图像识别：给定_,a,b,……z的完整图像，然后给出一个破损的图像 每个完整字符长 20 行。 输入文件包含一个或多个可能损坏的字符图案。一个字符图案可能以这些方式被损坏。 最多有一行可能被复制了（就接在原来那一行的下面） 最多有一行可能丢失了 有些“0”可能被改成“1” 有些“1”可能被改成“0” 不会有任何一个字符图案既多余了一行并且又丢失了一行。在测试数据的任何一个字符图案中，“0”和“1”的被改变率不超过 30%。 原题USACO5.4.2-Character Recognition 给出输入问题http://train.usaco.org/usaco/font.in 做法​ 一脸懵逼Orz ​ 第一次接触到类似的题目Orz ​ 可不可以枚举每一个答案 ​ 然后枚举是哪一行删除，哪一行复制，然后计算匹配率QAQ ​ 这样的话 ​ 复杂度是$O(2727272020)$……好像不会超 ​ 可是怎么根据匹配率搞？ ​ 说真的我只会暴力模拟 ​ 事实上我题目都错了：不会有任何一个字符图案既多余了一行并且又丢失了一行QAQ ​ 吓得我感觉百度。 ​ 下面复述一下百度到的结果。++DP ​ 说真的，看了好几天还没懂QAQ。 ​ 设$b[i]$表示给定图从第$i$行开始匹配所能得到的最小差距 ​ $c[i,j]$表示给定图从第$i$行开始连续匹配$j$行所能得到的最小差距 ​ $dif[i,j,k]$表示第$i$个字符图的第j行与给定图的第k行的差距 ​ $b[i]:=min(b[i+19]+c[i,19],b[i+20]+c[i,20],b[i+21]+c[i,21])$ ​ j=19：枚举字母。设表示字符图前行匹配的差距，表示后行匹配的差距，则$c[i,j]:=min(pre[k]+tail[19-k]).$ ​ j=20：直接枚举字符，统计即可。 ​ j=21：与j=19相仿。 ​ 对于其中涉及到的统计问题，可以从dif[i,j,k]直接获得，避免了很多重复计算 ​ 应该不会有这么坑的题再出现了吧。 USACO5.4.3题意给定一个无向图，问字典序最小的最小点割集。 原题USACO5.4.3 - Telecowmunication SAMPLE INPUT (file telecow.in) 1233 2 1 21 32 3 SAMPLE OUTPUT (file telecow.out) 1213 做法考虑把每个点拆成2份，中间连一条边，权值为1. 当然，1号点和n号点权值无穷大 对于外面的边，权值为无穷大。 然后跑最小割（SAP）。","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO5.4.2","slug":"USACO/training/Section5/USACO5.4/USACO5.4.2/USACO5-4-2","date":"2017-08-18T06:20:20.000Z","updated":"2017-08-18T06:32:48.721Z","comments":true,"path":"2017/08/18/USACO/training/Section5/USACO5.4/USACO5.4.2/USACO5-4-2/","link":"","permalink":"http://yoursite.com/2017/08/18/USACO/training/Section5/USACO5.4/USACO5.4.2/USACO5-4-2/","excerpt":"","text":"题意图像识别：给定_,a,b,……z的完整图像，然后给出一个破损的图像 每个完整字符长 20 行。 输入文件包含一个或多个可能损坏的字符图案。一个字符图案可能以这些方式被损坏。 最多有一行可能被复制了（就接在原来那一行的下面） 最多有一行可能丢失了 有些“0”可能被改成“1” 有些“1”可能被改成“0” 不会有任何一个字符图案既多余了一行并且又丢失了一行。在测试数据的任何一个字符图案中，“0”和“1”的被改变率不超过 30%。 原题USACO5.4.2-Character Recognition 给出输入问题http://train.usaco.org/usaco/font.in 做法一脸懵逼Orz 第一次接触到类似的题目Orz 可不可以枚举每一个答案 然后枚举是哪一行删除，哪一行复制，然后计算匹配率QAQ 这样的话 复杂度是$O(2727272020)$……好像不会超 可是怎么根据匹配率搞？","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO5.3","slug":"USACO/training/Section5/USACO5.3/USACO5.3","date":"2017-08-17T04:41:43.000Z","updated":"2017-08-19T05:09:47.438Z","comments":true,"path":"2017/08/17/USACO/training/Section5/USACO5.3/USACO5.3/","link":"","permalink":"http://yoursite.com/2017/08/17/USACO/training/Section5/USACO5.3/USACO5.3/","excerpt":"[TOC]","text":"[TOC] USACO5.3.2window你刚刚接手一项窗体界面工程。窗体界面还算简单，而且幸运的是，你不必显示实际的窗体。有 5 种基本操作： 创建一个新窗体 将窗体置顶 将窗体置底 删除一个窗体 输出窗体可见部分的百分比（就是，不被其它窗体覆盖的部分）。 原题USACO5.3.2-Window 做法这题采用模拟大法 如何模拟 我们可以用一个链表存储QAQ。 保存底窗体，顶窗体。 同时保存前面的那个窗体，后面的那个窗体。 支持这些操作。 1、Remove 删除其中一个窗体 1234567void remove(int x)&#123; if (x == -1) return; if (x != tail) pre[nxt[x]] = pre[x]; if (x != head) nxt[pre[x]] = nxt[x]; if (x == tail) tail = pre[x]; if (x == head) head = nxt[x];&#125; 2、Addhead 在头加上一个窗体（用于置底操作） 1234567void Addhead(int x)&#123; pre[x] = -1; nxt[x] = head; if (head!=-1) pre[head] = x; head = x; if (tail==-1) tail = x;&#125; 3、Addtail 在尾部加上一个窗体（用于置顶操作） 1234567void Addtail(int x)&#123; nxt[x] = -1; pre[x] = tail; if (tail!=-1) nxt[tail] = x; tail = x; if (head==-1) head = x;&#125; ★顺着next指针寻找，利用漂浮法，矩阵切割，从而得到可以见到的面积。 12345678910111213141516171819202122int dfs(int l,int r,int u,int d,int n)&#123; while ((n != -1) &amp;&amp; ((l &gt;= R[n]) || (r &lt;= L[n]) || (u &gt;= D[n]) || (d &lt;= U[n]))) n = nxt[n]; if (n == -1) return (r-l) * (d-u); int rec = 0; if (l &lt; L[n])&#123; rec += dfs(l,L[n],u,d,nxt[n]); l = L[n]; &#125; if (r &gt; R[n])&#123; rec += dfs(R[n],r,u,d,nxt[n]); r = R[n]; &#125; if (u &lt; U[n])&#123; rec += dfs(l,r,u,U[n],nxt[n]); u = U[n]; &#125; if (d &gt; D[n])&#123; rec += dfs(l,r,D[n],d,nxt[n]); d = D[n]; &#125; return rec;&#125; USACO5.3.3题意给定一个有向图，然后在一些点上立flag，这些flag可以通过有向边传递 1、问使得所有点都被弄上flag最少要立多少flag 2、问最少加多少边使得这个图强连通 原题USACO5.3.3-schlnet 做法很显然的做法 先强连通分量缩点，缩完点后，求有多少个没有入度，那么就是结果1 第二问显然就是没有出度的分量和没有入度的分量之中取一个较大的。 注意只有一个强连通分量的特判QAQ 1A USACO5.3.4题意一个N N的矩阵中有T个点有树，(xi,yi)有一棵树，然后在NN的范围内，问最大的没有树的正方形的边长是多少。(N&lt;=1000,T&lt;=10000) 原题USACO5.3.4-bigbrn Big BarnA Special TreatFarmer John wants to place a big square barn on his square farm. He hates to cut down trees on his farm and wants to find a location for his barn that enables him to build it only on land that is already clear of trees. For our purposes, his land is divided into N x N parcels. The input contains a list of parcels that contain trees. Your job is to determine and report the largest possible square barn that can be placed on his land without having to clear away trees. The barn sides must be parallel to the horizontal or vertical axis. EXAMPLE Consider the following grid of Farmer John’s land where .&#39; represents a parcel with no trees and#’ represents a parcel with trees: 123456789 1 2 3 4 5 6 7 81 . . . . . . . .2 . # . . . # . .3 . . . . . . . .4 . . . . . . . .5 . . . . . . . .6 . . # . . . . .7 . . . . . . . .8 . . . . . . . . The largest barn is 5 x 5 and can be placed in either of two locations in the lower right part of the grid. PROGRAM NAME: bigbrn INPUT FORMAT Line 1: Two integers: N (1 &lt;= N &lt;= 1000), the number of parcels on a side, and T (1 &lt;= T &lt;= 10,000) the number of parcels with treesLines 2..T+1: Two integers (1 &lt;= each integer &lt;= N), the row and column of a tree parcelSAMPLE INPUT (file bigbrn.in) 8 32 22 66 3OUTPUT FORMAT The output file should consist of exactly one line, the maximum side length of John’s barn. SAMPLE OUTPUT (file bigbrn.out) 5 做法考虑枚举每一个点作为右下角的点，然后看能往左上角扩展多少。 考虑用f[i,j]表示第i行，第j列的答案 如果(i,j)是’#’，那么f[i,j] = 0 否则 f[i,j] = min( f[i,j-1],f[i-1,j],f[i-1,j-1]) + 1 为什么是这样的呢？ 首先f[i-1,j-1]是比较好理解的 假设f[i-1,j-1] = x 那么还需要横着和竖着的两条都是x得到。 那么好理解了吧QAQ","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO5.2.1","slug":"USACO/training/Section5/USACO5.2.1/snail","date":"2017-08-14T09:20:40.000Z","updated":"2017-08-18T03:26:29.368Z","comments":true,"path":"2017/08/14/USACO/training/Section5/USACO5.2.1/snail/","link":"","permalink":"http://yoursite.com/2017/08/14/USACO/training/Section5/USACO5.2.1/snail/","excerpt":"题意有一个N*N的方格(N&lt;=120)，上面有B（B&lt;=200）个障碍，你从(1,1)出发，一开始可以向右或下走，一直碰到障碍，然后选择转90度再走，走到障碍，一直走，直到走的过程中经过了原来走过的格子。问最多能走过过多少格子","text":"题意有一个N*N的方格(N&lt;=120)，上面有B（B&lt;=200）个障碍，你从(1,1)出发，一开始可以向右或下走，一直碰到障碍，然后选择转90度再走，走到障碍，一直走，直到走的过程中经过了原来走过的格子。问最多能走过过多少格子 原题Snail TrailsAll Ireland Contest Sally Snail likes to stroll on a N x N square grid (1 &lt;n &lt;= 120). She always starts in the upper left corner of the grid. The grid has empty squares (denoted below by ‘.’) and a number (B) of barriers (denoted below by `#’). Here is a depiction of a grid including a demonstration of the grid labelling algorithm: 123456789 A B C D E F G H1 S . . . . . # .2 . . . . # . . .3 . . . . . . . .4 . . . . . . . .5 . . . . . # . .6 # . . . . . . .7 . . . . . . . .8 . . . . . . . . Sally travels vertically (up or down) or horizontally (left or right). Sally can travel either down or right from her starting location, which is always A1. Sally travels as long as she can in her chosen direction. She stops and turns 90 degrees whenever she encounters the edge of the board or one of the barriers. She can not leave the grid or enter a space with a barrier. Additionally, Sally can not re-cross any square she has already traversed. She stops her traversal altogether any time she can no longer make a move. Here is one sample traversal on the sample grid above: 123456789 A B C D E F G H1 S---------+ # .2 . . . . # | . .3 . . . . . | . .4 . . . . . +---+5 . . . . . # . |6 # . . . . . . |7 +-----------+ |8 +-------------+ Sally traversed right, down, right, down, left, up, and right. She could not continue since she encountered a square already visited. Things might have gone differently if she had chosen to turn back toward our left when she encountered the barrier at F5. Your task is to determine and print the largest possible number of squares that Sally can visit if she chooses her turns wisely. Be sure to count square A1 as one of the visited squares. PROGRAM NAME: snailINPUT FORMATThe first line of the input has N, the dimension of the square, and B, the number of barriers (1 &lt;= B &lt;= 200). The subsequent B lines contain the locations of the barriers. The sample input file below describes the sample grid above. The sample output file below is supposed to describe the traversal shown above. Note that when N &gt; 26 then the input file can not specify barriers to the right of column Z. SAMPLE INPUT (file snail.in)123458 4E2A6G1F5 OUTPUT FORMATThe output file should consist of exactly one line, the largest possible number of squares that Sally can visit. SAMPLE OUTPUT (file snail.out)133 Using this traversal: 123456789 A B C D E F G H1 S . . . . . # .2 | . . . # . . .3 | . . . +-----+4 | . . . | . . |5 +-------+ # . |6 # . . . . . . |7 +------------ |8 +-------------+ 做法这题的做法的本质就是一个DFS的搜索。 走还是转。 然后弄一个数组保存哪些格子走过了。 输入比较繁琐。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*ID:cqz15311LANG:C++PROG:snail*/#include&lt;bits/stdc++.h&gt;const int maxn = 125;using namespace std;const int dx[4] = &#123;-1, 0,0,1&#125;;const int dy[4] = &#123; 0,-1,1,0&#125;;#define UP 0#define LEFT 1#define RIGHT 2#define DOWN 3bool vis[maxn][maxn];bool f[maxn][maxn];char s[5];int n,B,Ans;int getnum()&#123; int a = 0; for (int i=1;s[i];i++) a = a*10+s[i]-48; return a;&#125;void PT()&#123; for (int i=0;i&lt;=n+1;i++)&#123; for (int j=0;j&lt;=n+1;j++)&#123; if (vis[i][j]) putchar('V'); else if (f[i][j]) putchar('#'); else putchar('.'); &#125; puts(\"\"); &#125; puts(\"\");&#125;void dfs(int x,int y,int fx,int cnt)&#123; int _x,_y;// printf(\"X = %d %d %d\\n\",x,y,fx); if (f[x][y] || vis[x][y]) return; if (cnt &gt; Ans) Ans = cnt; vis[x][y] = true;// printf(\"%d %d\\n\",x,y);// PT(); _x = x + dx[fx]; _y = y + dy[fx]; if (f[_x][_y])&#123; for (int d=0;d&lt;4;d++) dfs(x + dx[d ],y+dy[d ],d ,cnt+1); &#125;//前面是障碍 else dfs(x + dx[fx],y+dy[fx],fx,cnt+1); vis[x][y] = false;&#125;int main()&#123; freopen(\"snail.in\",\"r\",stdin); freopen(\"snail.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;B); memset(f,0,sizeof(f)); for (int i=1;i&lt;=n;i++) f[0][i] = f[n+1][i] = 1; for (int i=1;i&lt;=n;i++) f[i][0] = f[i][n+1] = 1; for (int i=1;i&lt;=B;i++)&#123; scanf(\"%s\",&amp;s); f[getnum()][s[0] - 'A' + 1] = 1; &#125; Ans = 0; memset(vis,false,sizeof(vis)); dfs(1,1,RIGHT,1); dfs(1,1,DOWN,1); printf(\"%d\\n\",Ans); fclose(stdin); fclose(stdout);&#125; 速度还是很快的 Executing… Test 1: TEST OK [0.014 secs, 4208 KB] Test 2: TEST OK [0.014 secs, 4208 KB] Test 3: TEST OK [0.014 secs, 4208 KB] Test 4: TEST OK [0.014 secs, 4208 KB] Test 5: TEST OK [0.014 secs, 4208 KB] Test 6: TEST OK [0.014 secs, 4208 KB] Test 7: TEST OK [0.014 secs, 4208 KB] Test 8: TEST OK [0.014 secs, 4208 KB] Test 9: TEST OK [0.014 secs, 4208 KB] Test 10: TEST OK [0.014 secs, 4208 KB] Test 11: TEST OK [0.014 secs, 4208 KB] Test 12: TEST OK [0.112 secs, 4208 KB] All tests OK.YOUR PROGRAM (‘snail’) WORKED FIRST TIME! That’s fantastic– and a rare thing. Please accept these special automatedcongratulations.","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"}]},{"title":"USACO5.1.3","slug":"USACO/training/Section5/USACO5.1.3/theme","date":"2017-08-14T07:10:03.000Z","updated":"2017-08-18T03:26:38.673Z","comments":true,"path":"2017/08/14/USACO/training/Section5/USACO5.1.3/theme/","link":"","permalink":"http://yoursite.com/2017/08/14/USACO/training/Section5/USACO5.1.3/theme/","excerpt":"Musical Themes题意 ​ 给定一个长度为N（N&lt;=5000)的数字串(0~88)，问最长的一个子串，使得除了这个子串外，还有一个与该子串重合位置的另一个长度相同子串的对应位置都是该子串的对应位置增加","text":"Musical Themes题意 ​ 给定一个长度为N（N&lt;=5000)的数字串(0~88)，问最长的一个子串，使得除了这个子串外，还有一个与该子串重合位置的另一个长度相同子串的对应位置都是该子串的对应位置增加 原题Brian Dean A musical melody is represented as a sequence of N (1 &lt;= N &lt;= 5000) notes that are integers in the range 1..88, each representing a key on the piano. It is unfortunate but true that this representation of melodies ignores the notion of musical timing; but, this programming task is about notes and not timings. Many composers structure their music around a repeating “theme”, which, being a subsequence of an entire melody, is a sequence of integers in our representation. A subsequence of a melody is a theme if it: is at least five notes long appears (potentially transposed – see below) again somewhere else in the piece of music is disjoint from (i.e., non-overlapping with) at least one of its other appearance(s) Transposed means that a constant positive or negative value is added to every note value in the theme subsequence. Given a melody, compute the length (number of notes) of the longest theme. One second time limit for this problem’s solutions! PROGRAM NAME: themeINPUT FORMATThe first line of the input file contains the integer N. Each subsequent line (except potentially the last) contains 20 integers representing the sequence of notes. The last line contains the remainder of the notes, potentially fewer than 20. SAMPLE INPUT (file theme.in)1233025 27 30 34 39 45 52 60 69 79 69 60 52 45 39 34 30 26 22 1882 78 74 70 66 67 64 60 65 80 OUTPUT FORMATThe output file should contain a single line with a single integer that represents the length of the longest theme. If there are no themes, output 0. SAMPLE OUTPUT (file theme.out)15 [The five-long theme is the last five notes of the first line and the first five notes of the second] 做法做法很多。 下面给出我的做法。 第一想法是哈希。 从而想到了二分答案。 加入现在知道了长度D，只是问存不存在2个长度为D的串可能。 那么存不存在呢？ 如果简单的哈希，难的就是因为有可能转调 经过思考，查询一些题解，找到了一个好的方法 ——转自nocow—— ​ 这个题考虑到相同的旋律之间的差是常数，可以把读入的序列变换一下。就是每个元素与其前一个元素做差。例如原序列 {3,5,7,3,4,4,6,8,4}，做差后是{2,2,-4,1,0,2,2,-4}。这样就可以在变换后的序列中直接查找最长的重复序列即可。上述例子中是2,2,-4，长度为3，对应原序列中3,5,7,3，长度为4。 上述转化后我们就可以通过寻找最长重复串来做到。 做法1 ​ 可以通过上述转化后，以每一个为截开的位置，跑KMP。(N^2) 做法2 ​ 还是我刚才那个想法，每次二分后O(N)扫描，得到这个点以及这个点一直到前面总D个长度的哈希值——如果哈希值相同，很大可能是和前面的重复的，然后D+1就是最终的答案。(N log N) ​ 我后来写这种做法遇到了好多坑——建议大家多练习一下hash的题目，特别是应该多取几个模数，当然我取了2个bit。具体的细节很繁琐，可以看一下代码。 ​ 虽然速度比较快，但是我不推荐这种做法，更简单的做法往下看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/*ID:cqz15311LANG:C++PROG:theme*/#include&lt;bits/stdc++.h&gt;const int Mod = (1e6+7);//好像1e7就超空间了.const int bit1 = 17;const int bit2 = 23;//但位17好像第八个点过了，第九个点WA了//其实可以多重哈希，多取几个模数。//我弄了2个bit就能过USACO所有数据了——其实最好还是取模数，代码改改少 //其实如果是17，3之类的我试了一下是WA的，懒惰就改数字，其实最好是改模数//这题坑了我好久，但是说到底还是Hash的题目做得少。//或者说，以前做hash的题目都不卡单hash的。const int maxn = 5005;using namespace std;typedef long long LL;int Hash1[Mod],Hash2[Mod];LL f1[maxn],f2[maxn],a[maxn];LL Pow1[maxn],Pow2[maxn];int n,L,R,Mid;bool check(int Len)&#123; LL rec1 = 0,rec2 = 0; for (int i=1;i&lt;=Len;i++) rec1 = (rec1 * bit1 + a[i]) % Mod,rec2 = (rec2 * bit2 + a[i]) % Mod; f1[Len] = rec1; f2[Len] = rec2; for (int i=Len+1;i&lt;=n;i++)&#123; rec1 = (((rec1 - Pow1[Len-1] * a[i - Len]) % Mod + Mod) % Mod * bit1 + a[i]) % Mod; rec2 = (((rec2 - Pow2[Len-1] * a[i - Len]) % Mod + Mod) % Mod * bit2 + a[i]) % Mod; f1[i] = rec1; //注意是Len-1不是Len——卡了N久 f2[i] = rec2; &#125; bool flag = false; for (int i=Len;i&lt;=n;i++)&#123; if (Hash1[f1[i]] == -1) Hash1[f1[i]] = i; if (Hash2[f2[i]] == -1) Hash2[f2[i]] = i; if ((Hash1[f1[i]] &lt; i - Len/*+1*/) &amp;&amp; (Hash2[f2[i]] &lt; i - Len)) flag = true; /*不能加一，因为差分过的最后一个等于前面最前面的一个*/ &#125; for (int i=Len;i&lt;=n;i++)&#123; Hash1[f1[i]] = -1; Hash2[f2[i]] = -1; &#125; if (flag) return true; else return false;&#125;int main()&#123; freopen(\"theme.in\",\"r\",stdin); freopen(\"theme.out\",\"w\",stdout); Pow1[0] = 1,Pow2[0] = 1; memset(Hash1,-1,sizeof(Hash1)); memset(Hash2,-1,sizeof(Hash2)); for (int i=1;i&lt;=5000;i++)Pow1[i] = Pow1[i-1] * bit1 % Mod; for (int i=1;i&lt;=5000;i++)Pow2[i] = Pow2[i-1] * bit2 % Mod; scanf(\"%d\",&amp;n); a[0] = 0; for (int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; for (int i=n-1;i&gt;=1;i--)&#123; a[i] = a[i] - a[i-1]; a[i] = (a[i] % Mod + Mod) % Mod; &#125;//a0没用 n--; L = 1; R = n; while (L &lt; R)&#123; Mid = (L + R + 1) &gt;&gt; 1; if (check(Mid))&#123; L = Mid; &#125; else R = Mid - 1; &#125; if (L+1 &lt; 5) puts(\"0\"); else printf(\"%d\\n\",L + 1); fclose(stdin); fclose(stdout); return 0;&#125; 算法3 考虑用DP[i,j]表示左边匹配到i，右边匹配到j的最大匹配数。——直接跑，都不用转化…… Let theme(i,j) be the length of the longest theme which occurs starting at both note i and j. Note that if note[i+1]-note[i] == note[j+1]-note[j], than theme(i,j) = 1+theme(i+1,j+1). Otherwise, theme(i,j) = 1. Thus, we order the search in such a way that theme(i,j) is tested immediately after theme(i+1,j+1), keeping track of the length of the current theme, as well as the length of the longest theme found so far. http://train.usaco.org/usacoanal2?a=2ocZH3qaoaJ&amp;S=theme 12345678910111213141516171819202122232425262728293031323334353637#include &lt;fstream.h&gt;int n;int note[5000];int main () &#123; ifstream filein (\"theme.in\"); filein &gt;&gt; n; for (int i = 0; i &lt; n; ++i) filein &gt;&gt; note[i]; filein.close (); int longest = 1; for (int i = 1; i &lt; n; ++i) &#123; int length = 1; for (int j = n - i - 1 - 1; j &gt;= 0; --j) &#123; if (note[j] - note[j + 1] == note[j + i] - note[j + i + 1]) &#123; ++length; if (length &gt; i) length = i; if (longest &lt; length) longest = length; &#125; else &#123; length = 1; &#125; &#125; &#125; ofstream fileout (\"theme.out\"); fileout &lt;&lt; ((longest &gt;= 5) ? longest : 0) &lt;&lt; endl; fileout.close (); exit (0);&#125; 算法4+ ​ 一些我听说过的名词：好像也只是听说过——————后缀数组。后缀自动机。……","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"},{"name":"差分","slug":"差分","permalink":"http://yoursite.com/tags/差分/"}]},{"title":"USACO5.1.2","slug":"USACO/training/Section5/USACO5.1.2/starry","date":"2017-08-14T04:49:06.000Z","updated":"2017-08-18T03:26:49.399Z","comments":true,"path":"2017/08/14/USACO/training/Section5/USACO5.1.2/starry/","link":"","permalink":"http://yoursite.com/2017/08/14/USACO/training/Section5/USACO5.1.2/starry/","excerpt":"Starry Night给定H*W的一幅图，让你给图中的一些极大联通快（8联通）编号，已知如果两个联通快经过旋转，对称等可以相同，说明两个联通快是同一个编号的。","text":"Starry Night给定H*W的一幅图，让你给图中的一些极大联通快（8联通）编号，已知如果两个联通快经过旋转，对称等可以相同，说明两个联通快是同一个编号的。 原题：——大家仔细理解一下样例 Starry NightIOI 98 High up in the night sky, the shining stars appear in clusters of various shapes. A cluster is a non-empty group of neighbouring stars, adjacent in horizontal, vertical or diagonal direction. A cluster cannot be a part of a larger cluster. Clusters may be similar. Two clusters are similar if they have the same shape and number of stars, irrespective of their orientation. In general, the number of possible orientations for a cluster is eight, as Figure 1 exemplifies. Figure 1. Eight similar clusters The night sky is represented by a sky map, which is a two-dimensional matrix of 0’s and 1’s. A cell contains the digit 1 if it has a star, and the digit 0 otherwise. Given a sky map, mark all the clusters with lower case letters. Similar clusters must be marked with the same letter; non-similar clusters must be marked with different letters. You mark a cluster with a lower case letter by replacing every 1 in the cluster by that lower case letter. PROGRAM NAME: starryINPUT FORMATThe first two lines contain, respectively, the width W and the height H of a sky map. The sky map is given in the following H lines, of W characters each. SAMPLE INPUT (file starry.in)12345678910111213141516172315100010000000000100000000111110001111100010110101000000010001000111111000000000101010001011110000011101000100000000000001001011111000000000100000010000000000000000010100000011111001000000001000000100010011111000000011101010101000100000010011010001000000000010001110111110000000001000011100000001000000000100010000100010010100000001110001000111000 In this case, the sky map has width 23 and height 15. Just to make it clearer, notice that this input file corresponds to the following picture of the sky. Figure 2. Picture of the sky OUTPUT FORMATThe output file contains the same map as the input file, except that the clusters are marked as described in Task. There will generally be more than one way to label the clusters with letters. Your program should choose the labeling such that if the entire output file is read as a string, this string will be minimal in the lexicographical ordering. SAMPLE OUTPUT (file starry.out)123456789101112131415a000a0000000000b00000000aaaaa000ccccc000d0dd0d0a0000000c000c000dddddd000000000c0b0c000d0dddd00000eee0c000c0000000000000e00e0ccccc000000000b000000e00000000000000000b0f000000ccccc00a00000000f000000c000c00aaaaa0000000ddd0c0b0c0a000a000000b00dd0c000c0000000000g000ddd0ccccc000000000g0000ddd0000000e000000000b000d0000f000e00e0b0000000ddd000f000eee000 This is one possible result for the sample input above. Notice that this output file corresponds to the following picture. Figure 3. Picture with the clusters marked Constraints0 &lt;= W (width of the sky map) &lt;= 100 0 &lt;= H (height of the sky map) &lt;= 100 0 &lt;= Number of clusters &lt;= 500 0 &lt;= Number of non-similar clusters &lt;= 26 (a..z) 1 &lt;= Number of stars per cluster &lt;= 160 做法显然，我们可以求出每一个联通快——通过floodfill。那么问题就是哪些联通快是同构的。 容易想到哈希，如果两个联通块完全相同，我们可以通过最左上角的坐标和一些来进行Hash。 那么如果要满足旋转，对称怎么办。 大家想一下，怎么样的一个Hash可以满足？ 可能还有别的做法，但是我写此文时只想到这个。 考虑旋转对称之后，对于联通块的某一个对应的格子，它的周围8个是类似的。 可以考虑把每一个联通快的每一个是1的根据8*8范围内的1来进行Hash——可以累加或者怎么样的。 当然，可以多取几个模数来保证正确性。——反例总是有的。 发现，W*H&lt;=10000，所以是不会超时的。 下面给出我的哈希函数 123456789101112131415161718const int P[5][5] = &#123;&#123;659 ,2017,4049,2017,659 &#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;4049,3359,1 ,3359,4049&#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;659 ,2017,4049,2017,659 &#125;&#125;;int Val(int x,int y)&#123; int ans = 0; for (int i=-2;i&lt;=2;i++)&#123; for (int j=-2;j&lt;=2;j++)&#123; if ((x + i &lt; 0) || (x + i &gt;= H) || (y + j &lt; 0) || (y + j &gt;= W))continue; if (Ans[x+i][y+j] == -1)&#123; ans = ans + P[i+2][j+2]; &#125; &#125; &#125; return ans;&#125; 取一些大素数！这样可以让正确率增大许多。 Executing… Test 1: TEST OK [0.000 secs, 4332 KB] Test 2: TEST OK [0.000 secs, 4332 KB] Test 3: TEST OK [0.000 secs, 4332 KB] Test 4: TEST OK [0.000 secs, 4332 KB] Test 5: TEST OK [0.000 secs, 4332 KB] All tests OK. 事实上很快。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/*ID:cqz15311LANG:C++PROG:starry */#include&lt;bits/stdc++.h&gt;const int maxn = 105;using namespace std;const int dx[8] = &#123;-1,-1,-1, 0,0, 1,1,1&#125;;const int dy[8] = &#123;-1, 0, 1,-1,1,-1,0,1&#125;; struct Q&#123; int x,y; Q(int _x = 0,int _y = 0)&#123; x = _x; y = _y; &#125;&#125;q[maxn*maxn];char a[maxn][maxn];bool vis[maxn][maxn];int Ans[maxn][maxn];int front,rear;int W,H;void floodfill(int sx,int sy)&#123; int x,y,_x,_y;// puts(\"\"); front = rear = 0; q[rear++] = Q(sx,sy); Ans[sx][sy] = -1; while (front &lt; rear)&#123; x = q[front] . x; y = q[front] . y; front++; for (int d=0;d&lt;8;d++)&#123; _x = x + dx[d]; _y = y + dy[d]; if ((_x &lt; 0) || (_y &lt; 0) || (_x &gt;= H) || (_y &gt;= W) || (a[_x][_y] == 0) || Ans[_x][_y] == -1) continue; Ans[_x][_y] = -1; q[rear++] = Q(_x,_y); &#125; &#125;&#125;const int P[5][5] = &#123;&#123;659 ,2017,4049,2017,659 &#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;4049,3359,1 ,3359,4049&#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;659 ,2017,4049,2017,659 &#125;&#125;;int Val(int x,int y)&#123; int ans = 0; for (int i=-2;i&lt;=2;i++)&#123; for (int j=-2;j&lt;=2;j++)&#123; if ((x + i &lt; 0) || (x + i &gt;= H) || (y + j &lt; 0) || (y + j &gt;= W))continue; if (Ans[x+i][y+j] == -1)&#123; ans = ans + P[i+2][j+2]; &#125; &#125; &#125; return ans;&#125;int get_hash(int sx,int sy)&#123; int x,y,_x,_y; int rec = 0; front = rear = 0; q[rear++] = Q(sx,sy); vis[sx][sy] = true; while (front &lt; rear)&#123; x = q[front] . x; y = q[front] . y; rec = rec + Val(x,y); front++; for (int d=0;d&lt;8;d++)&#123; _x = x + dx[d]; _y = y + dy[d]; if ((_x &lt; 0) || (_y &lt; 0) || (_x &gt;= H) || (_y &gt;= W)) continue; if (Ans[_x][_y] == -1 &amp;&amp; !vis[_x][_y])&#123; vis[_x][_y] = true; q[rear++] = Q(_x,_y); &#125; &#125; &#125; return rec;&#125;void Filled(int sx,int sy,int Addval)&#123; int x,y,_x,_y; front = rear = 0; Ans[sx][sy] = Addval; q[rear++] = Q(sx,sy); while (front &lt; rear)&#123; x = q[front] . x; y = q[front] . y; front++; for (int d=0;d&lt;8;d++)&#123; _x = x + dx[d]; _y = y + dy[d]; if ((_x &lt; 0) || (_y &lt; 0) || (_x &gt;= H) || (_y &gt;= W) || Ans[_x][_y] != -1) continue; Ans[_x][_y] = Addval; q[rear++] = Q(_x,_y); &#125; &#125; &#125;int Hash[28];int find(int x)&#123; for (int i=1;i&lt;=Hash[0];i++)&#123; if (x == Hash[i]) return i + 'a' - 1; &#125; Hash[++Hash[0]] = x; return Hash[0] + 'a' - 1;&#125;int main()&#123; freopen(\"starry.in\",\"r\",stdin); freopen(\"starry.out\",\"w\",stdout); scanf(\"%d%d\",&amp;W,&amp;H); for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; a[i][j] = getchar(); while ((a[i][j] != '0') &amp;&amp; (a[i][j]!='1')) a[i][j] = getchar(); a[i][j] -= '0'; &#125; &#125; memset(Hash,0,sizeof(Hash)); memset(vis,false,sizeof(vis)); memset(Ans,0,sizeof(Ans)); for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; if (Ans[i][j] != 0 || a[i][j] == 0) continue; floodfill(i,j); //把当前联通块全部求出来，标记为-1 int Tmp = find(get_hash(i,j)); Filled(i,j,Tmp); &#125; &#125; for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; if (Ans[i][j] == 0) putchar('0'); else printf(\"%c\",Ans[i][j]); &#125; puts(\"\"); &#125; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"}]},{"title":"USACO5.1.1","slug":"USACO/training/Section5/USACO5.1.1/fc","date":"2017-08-14T01:17:49.000Z","updated":"2017-08-18T03:26:59.328Z","comments":true,"path":"2017/08/14/USACO/training/Section5/USACO5.1.1/fc/","link":"","permalink":"http://yoursite.com/2017/08/14/USACO/training/Section5/USACO5.1.1/fc/","excerpt":"Fencing the Cows 给你一些点，问包围这些点的最小花费是多少。","text":"Fencing the Cows 给你一些点，问包围这些点的最小花费是多少。 本题的实质是求一个凸包 为什么是凸包？ 很显然地发现，如果存在A-&gt;B-&gt;C，其中B是凹的，那么不如A-&gt;C来得赚。 凸包是什么？请大家自行Baidu Or Google 下面给出凸包的求法： 首先明确什么是叉积 对于点A，点B，它们的叉积就是 |A| |B| sin(α)① 其中|A|表示A的长度，α表示A到B的夹角 我们可以通过α的正负来判断A和B相对于原点的位置（顺时针or逆时针） 然而，叉积还有另外一个公式 A.x B.y - A.y B.x② 123double Cross(Point a,Point b,Point c)&#123;//这里以c为源点 return (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);&#125; 这个证明不给出，主要是通过单位向量之间的转换得到。 那么我们可以通过公式②的正负性得到点之间的位置。 凸包因为是凸多边形，对于相邻的3个点A，B，C（按照逆时针排序） 必然满足相对于A来说，C在B的顺时针方向。 而且我们还知道，凸包的顶点一定是给定的点中的。 因此可以整理出下面的算法框架 $选择最左的，如果相同选择最下面的——这个点一定是凸包中的点 ——好处很多，下面有提到 1234567int k = 0;for (int i=1;i&lt;n;i++)&#123; if ((P[i].x &lt; P[k].x) || (fabs(P[i].x-P[k].x)&lt;eps) &amp;&amp; (P[i].y &lt; P[k].y))&#123; k = i; &#125;&#125;tmp = P[k];P[k] = P[0];P[0] = tmp; $把其它的点与这个点之间，按照极角排序 1234bool cmp(Point a,Point b)&#123; return Cross(a,b,p[0]) &gt; 0; //大于0表示a在b的顺时针方向，所以a应该排在b的前面 &#125; $逆时针一个点一个点考虑，要满足上面提到的性质——用一个栈维护 12345678910top = 0;Stack[top] . x = P[0].x;Stack[top] . y = P[0].y;top++;for (int i=1;i&lt;n;i++)&#123; while ((top &gt;= 2) &amp;&amp; (Cross(P[i],Stack[top-1],Stack[top-2]) &gt; 0)) top--; Stack[top] . x = P[i].x; Stack[top] . y = P[i].y; top++;&#125; $直到考虑完所有点结束（不用重新考虑0号点) 大家可以考虑一下为什么不用重新考虑 上面的性质可以用一个栈来维护。 那么凸包的周长就是所有凸包上的点之间的距离和 123456double Ans = 0;for (int i=1;i&lt;top;i++)&#123; Ans = Ans + dis(Stack[i-1],Stack[i]);&#125;Ans = Ans + dis(Stack[top-1],Stack[0]);printf(\"%.2lf\\n\",Ans); 做法虽然有点繁琐，但代码很好理解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*ID:cqz15311LANG:C++PROG:fc*/#include&lt;bits/stdc++.h&gt;const double eps = 1e-8;using namespace std;struct Point&#123; double x,y;&#125;tmp,P[10005],Stack[10005];int n; double Cross(Point a,Point b,Point c)&#123;//这里以c为源点 return (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);&#125;bool cmp(Point a,Point b)&#123; return Cross(a,b,P[0]) &gt; 0; //大于0表示a在b的顺时针方向，所以a应该排在b的前面 &#125;void init()&#123; freopen(\"fc.in\",\"r\",stdin); freopen(\"fc.out\",\"w\",stdout); scanf(\"%d\",&amp;n); for (int i=0;i&lt;n;i++)&#123; scanf(\"%lf%lf\",&amp;P[i].x,&amp;P[i].y); &#125; int k = 0; for (int i=1;i&lt;n;i++)&#123; if ((P[i].x &lt; P[k].x) || (fabs(P[i].x-P[k].x)&lt;eps) &amp;&amp; (P[i].y &lt; P[k].y))&#123; k = i; &#125; &#125; tmp = P[k];P[k] = P[0];P[0] = tmp; sort(P+1,P+n,cmp);&#125;int top;void solve()&#123; top = 0; Stack[top] . x = P[0].x; Stack[top] . y = P[0].y; top++; for (int i=1;i&lt;n;i++)&#123; while ((top &gt;= 2) &amp;&amp; (Cross(P[i],Stack[top-1],Stack[top-2]) &gt; 0)) top--; Stack[top] . x = P[i].x; Stack[top] . y = P[i].y; top++; &#125;&#125;double dis(Point a,Point b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;void Write()&#123; double Ans = 0; for (int i=1;i&lt;top;i++)&#123; Ans = Ans + dis(Stack[i-1],Stack[i]); &#125; Ans = Ans + dis(Stack[top-1],Stack[0]); printf(\"%.2lf\\n\",Ans); fclose(stdin); fclose(stdout);&#125;int main()&#123; init(); solve(); Write(); return 0;&#125;","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"计算几何","slug":"计算几何","permalink":"http://yoursite.com/tags/计算几何/"}]},{"title":"USACO4.4.3","slug":"USACO/training/Section4/4/USACO4.4.3-frameup/frameup","date":"2017-08-12T10:25:32.000Z","updated":"2017-08-18T03:27:11.092Z","comments":true,"path":"2017/08/12/USACO/training/Section4/4/USACO4.4.3-frameup/frameup/","link":"","permalink":"http://yoursite.com/2017/08/12/USACO/training/Section4/4/USACO4.4.3-frameup/frameup/","excerpt":"Frame up题意： 有一些框架，大小在H*W以内，依次放入这些框架在一个格子内，得到一副图，给你这幅图，问放框架的顺序。 保证矩形的每条边都有一部分是可见的。","text":"Frame up题意： 有一些框架，大小在H*W以内，依次放入这些框架在一个格子内，得到一副图，给你这幅图，问放框架的顺序。 保证矩形的每条边都有一部分是可见的。 原题 Consider the following five picture frames shown on an 9 x 8 array: 123456789........ ........ ........ ........ .CCC....EEEEEE.. ........ ........ ..BBBB.. .C.C....E....E.. DDDDDD.. ........ ..B..B.. .C.C....E....E.. D....D.. ........ ..B..B.. .CCC....E....E.. D....D.. ....AAAA ..B..B.. ........E....E.. D....D.. ....A..A ..BBBB.. ........E....E.. DDDDDD.. ....A..A ........ ........E....E.. ........ ....AAAA ........ ........EEEEEE.. ........ ........ ........ ........ 1 2 3 4 5Now place all five picture frames on top of one another starting with 1 at the bottom and ending up with 5 on top. If any part of a frame covers another frame, it hides that part of the frame below. Viewing the stack of five frames we see the following. .CCC... ECBCBB.. DCBCDB.. DCCC.B.. D.B.ABAA D.BBBB.A DDDDAD.A E...AAAA EEEEEE.. Given a picture like this, determine the order of the frames stacked from bottom to top. Here are the rules for this challenge: The width of the frame is always exactly 1 character and the sides are never shorter than 3 characters.It is possible to see at least one part of each of the four sides of a frame. A corner is part of two sides.The frames will be lettered with capital letters, and no two frames will be assigned the same letter.PROGRAM NAME: frameup INPUT FORMAT Line 1: Two space-separated integers: the height H (3 &lt;= H &lt;=30) and the width W (3 &lt;= W &lt;= 30).Line 2..H+1: H lines, each with a string W characters wide.SAMPLE INPUT (file frameup.in) 123456789109 8.CCC....ECBCBB..DCBCDB..DCCC.B..D.B.ABAAD.BBBB.ADDDDAD.AE...AAAAEEEEEE.. OUTPUT FORMAT Print the letters of the frames in the order they were stacked from bottom to top. If there are multiple possibilities for an ordering, list all such possibilities – in alphabetical order – on successive lines. There will always be at least one legal ordering. SAMPLE OUTPUT (file frameup.out) EDABC 做法: 注意到题目保证 ​ 矩形的每条边都有一部分是可见的。 ​ 而且N&lt;=26（不然无法保存） 而且矩形的每一条边的长度为1，我们可以很显然地得到一个矩形的范围。 （通过枚举每一个N，然后得到其最左在什么地方出现，最上在什么地方出现，最右在什么地方出现，最下在什么地方出现） 那么如果在这个矩形边上的可见的，说明那个编号的矩形是当前矩形之后才摁上去的。 从而可以考虑到拓扑排序,怎么做呢？设当前处理到的矩形为i,编号为j的矩形在i的边上，而且是可见的，那么相当于从i到j有一条又向边。 通过一次拓扑排序，就可以得到结果了。 注意，该题中的字母可能不连续。 具体实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*ID:cqz15311LANG:C++PROG:frameup*/#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int from,to,nxt;&#125;edge[31*31*31*31];//邻接矩阵就行了，我是不是太浪费了 int first[255];int H,W,In[255],nume,Len;char a[31][31];bool find(char x)&#123; for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; if (a[i][j] == x) return true; &#125; &#125; return false;&#125;void add_edge(int a,int b)&#123;// printf(\"%c--&gt;%c\\n\",a,b);// if (b == 'E') printf(\"ADDing%c\\n\",a); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; first[a] = nume++; In[b]++;&#125;int cnt;bool vis[255];char ans[255];bool found[255];void dfs(int x)&#123; if (x == Len+1)&#123; for (int i=1;i&lt;=Len;i++) putchar(ans[i]); puts(\"\"); return ; &#125; for (int i='A';i&lt;='Z';i++)&#123; if (found[i] &amp;&amp; !vis[i] &amp;&amp; In[i] == 0)&#123; vis[i] = true; ans[x] = i; for (int e=first[i];e!=-1;e=edge[e].nxt) In[edge[e].to]--; dfs(x+1); for (int e=first[i];e!=-1;e=edge[e].nxt) In[edge[e].to]++; vis[i] =false; ans[x] = -1; &#125; &#125; //一位一位按照字典序枚举，得到一个解就输出，是满足字典序的。 &#125;int main()&#123; freopen(\"frameup.in\",\"r\",stdin); freopen(\"frameup.out\",\"w\",stdout); scanf(\"%d%d\",&amp;H,&amp;W); for (int i=0;i&lt;H;i++)&#123; scanf(\"%s\",&amp;a[i]); &#125; nume = 0; Len = 0; memset(found,false,sizeof(found)); memset(first,-1,sizeof(first)); for (int c='A';c&lt;='Z';c++)&#123; if (find(c))&#123;//可能不连续，所以要判断c是否存在 found[c] = true; Len++; int L,R,U,D; L = W; R = -1; U = H; D = -1; for (int i=0;i&lt;H;i++) for (int j=0;j&lt;W;j++) if (a[i][j] == c) L = min(L,j),R = max(R,j),U = min(U,i),D = max(D,i); for (int i=L;i&lt;=R;i++)&#123; if (a[U][i] != '.' &amp;&amp; a[U][i] != c) add_edge(c,a[U][i]); if (a[D][i] != '.' &amp;&amp; a[D][i] != c) add_edge(c,a[D][i]); &#125; for (int i=U;i&lt;=D;i++)&#123; if (a[i][L] != '.' &amp;&amp; a[i][L] != c) add_edge(c,a[i][L]); if (a[i][R] != '.' &amp;&amp; a[i][R] != c) add_edge(c,a[i][R]); &#125; //注意不能自己向自己连边 &#125; &#125; memset(vis,false,sizeof(vis)); dfs(1); fclose(stdin); fclose(stdout); return 0;&#125; 呼&amp;把第四章刷完了。","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"圆桌问题","slug":"网络流24题/第5题/5","date":"2017-08-12T08:20:30.000Z","updated":"2017-08-12T08:33:42.825Z","comments":true,"path":"2017/08/12/网络流24题/第5题/5/","link":"","permalink":"http://yoursite.com/2017/08/12/网络流24题/第5题/5/","excerpt":"有n个单位，每个单位有ri的人，有m个圆桌，每个圆桌可以容纳ci个人，要求使得同一个单位的人不在一个圆桌。求一种分组方法。","text":"有n个单位，每个单位有ri的人，有m个圆桌，每个圆桌可以容纳ci个人，要求使得同一个单位的人不在一个圆桌。求一种分组方法。 考虑建立边 相当于对于s到每个单位流一条ri的边，从圆桌到t连一条ci的边，每个单位和每个圆桌连一条1的边，然后跑一遍SAP。 这题不想多说………… n和m别搞错 其实就是二分图多重匹配问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;const int maxv = 505;const int maxe = maxv*maxv;const int oo = 1&lt;&lt;30;using namespace std;struct Edge&#123; int from,to,nxt,flow,cap;&#125;;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe * 2]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123;// printf(\"%d --&gt; %d:%d\\n\",a,b,c); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; int sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=0;i&lt;n;i++) cur[i] = first[i]; int u = s; while (dist[s] != n+1)&#123;// printf(\"U = %d --&gt;\",u); if (u == t)&#123;// puts(\"Add\"); int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123;// printf(\"%d %d %d\\n\",v,path[v],edge[path[v]].from); if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;int m,n,sum; int main()&#123; scanf(\"%d%d\",&amp;m,&amp;n); G.init(m+n+2); int s = 0,t = n+m+1; for (int i=1;i&lt;=m;i++)&#123; int W; scanf(\"%d\",&amp;W); sum = sum + W; G.add_edge(s,i,W); &#125; for (int i=1;i&lt;=n;i++)&#123; int W; scanf(\"%d\",&amp;W); G.add_edge(m+i,t,W); &#125; for (int i=1;i&lt;=m;i++)&#123; for (int j=1;j&lt;=n;j++)&#123; G.add_edge(i,m+j,1); &#125; &#125; int Ans = G.sap(s,t); if (Ans == sum)&#123; puts(\"1\"); for (int i =1;i&lt;=m;i++)&#123; for (int e=G.first[i];e!=-1;e=G.edge[e].nxt)&#123; if (((e &amp; 1) == 0) &amp;&amp; (G.edge[e].cap == G.edge[e].flow))&#123; printf(\"%d \",G.edge[e].to - m); &#125; &#125; puts(\"\"); &#125; &#125; else puts(\"0\"); &#125;","categories":[],"tags":[]},{"title":"USACO4.4.1","slug":"USACO/training/Section4/4/USACO4.4.1-shuttle/shuttle","date":"2017-08-11T13:04:04.000Z","updated":"2017-08-18T03:27:29.107Z","comments":true,"path":"2017/08/11/USACO/training/Section4/4/USACO4.4.1-shuttle/shuttle/","link":"","permalink":"http://yoursite.com/2017/08/11/USACO/training/Section4/4/USACO4.4.1-shuttle/shuttle/","excerpt":"Shuttle Puzzle题意：给定n，当n=3的时候，表示从WWW_BBB到BBB_WWW的最少操作步数。每次可以将某一个W或者B移动到空格位置，但是距离得小于等于2。 n&lt;=12","text":"Shuttle Puzzle题意：给定n，当n=3的时候，表示从WWW_BBB到BBB_WWW的最少操作步数。每次可以将某一个W或者B移动到空格位置，但是距离得小于等于2。 n&lt;=12 这题搜索似乎要超时。 下面给出原题： USACO4.4.1 Shuttle PuzzleTraditionalThe Shuttle Puzzle of size 3 consists of 3 white marbles, 3 black marbles, and a strip of wood with 7 holes. The marbles of the same color are placed in the holes at the opposite ends of the strip, leaving the center hole empty. INITIAL STATE: WWW_BBBGOAL STATE: BBB_WWWTo solve the shuttle puzzle, use only two types of moves. Move 1 marble 1 space (into the empty hole) or jump 1 marble over 1 marble of the opposite color (into the empty hole). You may not back up, and you may not jump over 2 marbles. A Shuttle Puzzle of size N consists of N white marbles and N black marbles and 2N+1 holes. Here’s one solution for the problem of size 3 showing the initial, intermediate, and end states: WWW BBBWW WBBBWWBW BBWWBWB BWWB BWBW BWBWB WBWBWBBW WBWBBWBW WBBWBWBWBWBWB WBWB BWWB BWBWWBB WBWWBBBW WWBBB WWWWrite a program that will solve the SHUTTLE PUZZLE for any size N (1 &lt;= N &lt;= 12) in the minimum number of moves and display the successive moves, 20 per line. PROGRAM NAME: shuttle INPUT FORMAT A single line with the integer N.SAMPLE INPUT (file shuttle.in) 3OUTPUT FORMAT The list of moves expressed as space-separated integers, 20 per line (except possibly the last line). Number the marbles/holes from the left, starting with one. Output the solution that would appear first among the set of minimal solutions sorted numerically (first by the first number, using the second number for ties, and so on). SAMPLE OUTPUT (file shuttle.out) 3 5 6 4 2 1 3 5 7 6 4 2 3 5 4 一下仅表示-对于Nocow内容，我的理解- 33 5 6 4 2 1 3 5 7 6 4 2 3 5 444 6 7 5 3 2 4 6 8 9 7 5 3 1 2 4 6 8 7 5 3 4 6 555 7 8 6 4 3 5 7 9 10 8 6 4 2 1 3 5 7 9 11 10 8 6 4 2 3 5 7 9 8 6 4 5 7 666 8 9 7 5 4 6 8 10 11 9 7 5 3 2 4 6 8 10 12 13 11 9 7 5 3 1 2 4 6 8 10 12 11 9 7 5 3 4 6 8 10 9 7 5 6 8 7 进行神奇的分析 把空格的位置也算上 3：4|35|642|1357|642|35|4 4：5|46|753|2468|97531|2468|753|46|5 ……聪明的你发现规律了吗？ 是的，这是一个对称的等差数列。 要证明？？http://train.usaco.org/usacoanal2?a=lNUFVam4bZA&amp;S=shuttle 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*ID:cqz15311LANG:C++PROG:shuttle*/#include&lt;bits/stdc++.h&gt; using namespace std;int n,now,len,cnt;int main()&#123; freopen(\"shuttle.in\",\"r\",stdin); freopen(\"shuttle.out\",\"w\",stdout); scanf(\"%d\",&amp;n); now = n+1; cnt = 0; for (int i=1;i&lt;=2*n+1;i++)&#123; if (i &lt;= n+1)&#123; len = i; &#125; else len = 2 * (n+1) - i; if (i &amp; 1)&#123; for (int j=1;j&lt;=len;j++)&#123; if (i!=1)&#123; cnt++; printf(\"%d\",now); if ((i == 2*n+1) &amp;&amp; (j == len)) puts(\"\"); else if (cnt % 20 == 0) puts(\"\"); else putchar(' '); &#125; now = now - 2; &#125; now+=2; if (i &lt;= n)now--; else now++; &#125; else&#123; for (int j=1;j&lt;=len;j++)&#123; cnt++; printf(\"%d\",now); if (cnt % 20 == 0) puts(\"\"); else putchar(' '); now = now + 2; &#125; now-=2; if (i &lt;= n)now++; else now--; &#125; &#125; //puts(\"\");这个不能有！害得我没有1A fclose(stdin); fclose(stdout); return 0;&#125;/*Executing... Test 1: TEST OK [0.000 secs, 4176 KB] Test 2: TEST OK [0.000 secs, 4176 KB] Test 3: TEST OK [0.000 secs, 4176 KB] Test 4: TEST OK [0.000 secs, 4176 KB] Test 5: TEST OK [0.000 secs, 4176 KB] Test 6: TEST OK [0.000 secs, 4176 KB] Test 7: TEST OK [0.000 secs, 4176 KB] Test 8: TEST OK [0.000 secs, 4176 KB] Test 9: TEST OK [0.000 secs, 4176 KB] Test 10: TEST OK [0.000 secs, 4176 KB]All tests OK.Your program ('shuttle') produced all correct answers! This is yoursubmission #2 for this problem. Congratulations!*/","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO4.4.2","slug":"USACO/training/Section4/4/USACO4.4.2-milk6/milk6","date":"2017-08-11T12:44:20.000Z","updated":"2017-08-18T03:27:20.350Z","comments":true,"path":"2017/08/11/USACO/training/Section4/4/USACO4.4.2-milk6/milk6/","link":"","permalink":"http://yoursite.com/2017/08/11/USACO/training/Section4/4/USACO4.4.2-milk6/milk6/","excerpt":"Pollutant Control题意：给定一张图，每条边有流量，求一个图的最小割，并且求出字典序最小一组最小割（在满足的情况下，边越少越好）。","text":"Pollutant Control题意：给定一张图，每条边有流量，求一个图的最小割，并且求出字典序最小一组最小割（在满足的情况下，边越少越好）。 下面给出原题： USACO4.4.2 Pollutant Control Hal Burch It’s your first day in Quality Control at Merry Milk Makers, and already there’s been a catastrophe: a shipment of bad milk has been sent out. Unfortunately, you didn’t discover this until the milk was already into your delivery system on its way to stores. You know which grocer that milk was destined for, but there may be multiple ways for the milk to get to that store. The delivery system is made up of a several warehouses, with trucks running from warehouse to warehouse moving milk. While the milk will be found quickly, it is important that it does not make it to the grocer, so you must shut down enough trucks to ensure that it is impossible for the milk to get to the grocer in question. Every route costs a certain amount to shut down. Find the minimum amount that must be spent to ensure the milk does not reach its destination, along with a set of trucks to shut down that achieves this goal at that cost. PROGRAM NAME: milk6 INPUT FORMAT Line 1: Two space separated integers, N and M. N (2 &lt;= N &lt;= 32) is the number of warehouses that Merry Milk Makers has, and M (0 &lt;= M &lt;= 1000) is the number of trucks routes run. Warehouse 1 is actually the productional facility, while warehouse N is the grocer to which which the bad milk was destined. Line 2..M+1: Truck routes: three space-separated integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si,Ei &lt;= N) correspond to the pickup warehouse and dropoff warehouse for the truck route. Ci (0 &lt;= Ci &lt;= 2,000,000) is the cost of shutting down the truck route. SAMPLE INPUT (file milk6.in) 1234564 51 3 1003 2 502 4 601 2 402 3 80 OUTPUT FORMAT The first line of the output should be two integers, C and T. C is the minimum amount which must be spent in order to ensure the our milk never reaches its destination. T is the minimum number of truck routes that you plan to shut down in order to achive this goal. The next T lines sould contain a sorted list of the indexes of the truck routes that you suggest shutting down. If there are multiple sets of truck routes that achieve the goal at minimum cost, choose one that shuts down the minimum number of routes. If there are still multiple sets, choose the one whose initial routes have the smallest index. SAMPLE OUTPUT (file milk6.out) 1260 13 分析和做法： 这题只需要最大流就可以：注意到边不超过1000个，我们可以把每条边的边权改成原来的边权*1001再加上1，那么跑一编最小割，可以得到用的边最少的。因为在边权相同的情况下，1选的越少越好。 那么答案就是最小割 / 1001。 那么如何求出字典序最小的一组最小割呢？ 显然，因为要字典序最小，我们不能用普通的BFS之类的。 考虑枚举每一条边，如果删去这条边后整个图的最小割变小了，而且变小的正好等于这条边的边权，说明这条边是最小割的一部分，然后真的把这条边从原来的网络中删去。 这里有一些注意点： 1、后面都是每行输出一个答案，不是一行里面 2、要开long long，不然会爆 3、答案的maxv和maxe不要搞错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/*ID:cqz15311LANG:C++PROG:milk6 */#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL oo = 1LL&lt;&lt;50;const int maxv = 35;const int maxe = 2005;struct Edge&#123; int from,to,nxt; LL cap,flow;&#125;;struct G&#123; int nume; int first[maxv],cur[maxv],path[maxv],num[maxv+2],n; int dist[maxv]; Edge edge[maxe * 2]; LL Max_flow; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123; edge[nume] . from = a; edge[nume] . to = b; edge[nume] . cap = c; edge[nume] . flow = 0; edge[nume] . nxt = first[a]; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . cap = 0; edge[nume] . flow = 0; edge[nume] . nxt = first[b]; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++) edge[i] . flow = 0; &#125; LL sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=1;i&lt;=n;i++) cur[i] = first[i]; int u = s; while (dist[s] &lt; n)&#123;// printf(\"%d\\n\",u); if (u == t)&#123; LL Min_flow = oo,break_point; //Augment for (int v=t;v!=s;v=edge[path[v]].from)&#123; if (edge[path[v]] . cap - edge[path[v]] . flow &lt; Min_flow)&#123; Min_flow = edge[path[v]] . cap - edge[path[v]] . flow; break_point = edge[path[v]] . from; &#125; &#125; Max_flow += Min_flow; for (int v=t;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v]^1] .flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int &amp;e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((edge[e].cap &gt; edge[e].flow) &amp;&amp; (dist[edge[e].to] + 1 == dist[u]))&#123; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n+1; for (int e=first[u];e!=-1;e=edge[e].nxt)&#123; if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to] + 1); &#125; &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125;&#125;G;int ans[maxe+1];int a[maxe],b[maxe];LL c[maxe];int main()&#123; freopen(\"milk6.in\",\"r\",stdin); freopen(\"milk6.out\",\"w\",stdout); int n,m; scanf(\"%d%d\",&amp;n,&amp;m); G.init(n); for (int i=0;i&lt;m;i++)&#123; scanf(\"%d%d%lld\",&amp;a[i],&amp;b[i],&amp;c[i]); c[i] = c[i] * 1001 + 1; G.add_edge(a[i],b[i],c[i]); &#125; LL Max_flow = G.sap(1,n); printf(\"%lld \",Max_flow / 1001); memset(ans,0,sizeof(ans)); for (int i=0;i&lt;m;i++)&#123; G.edge[i*2] . cap = 0; LL tmp = G.sap(1,n); if (Max_flow - tmp == c[i])&#123; ans[++ans[0]] = i+1; Max_flow -= c[i]; &#125; else G.edge[i*2] . cap = c[i]; &#125; printf(\"%d\\n\",ans[0]); if (ans[0] != 0)&#123; printf(\"%d\\n\",ans[1]); for (int i=2;i&lt;=ans[0];i++)&#123; printf(\"%d\\n\",ans[i]); &#125; &#125; fclose(stdin); fclose(stdout);&#125;/*Executing... Test 1: TEST OK [0.000 secs, 4328 KB] Test 2: TEST OK [0.000 secs, 4328 KB] Test 3: TEST OK [0.000 secs, 4328 KB] Test 4: TEST OK [0.000 secs, 4328 KB] Test 5: TEST OK [0.056 secs, 4328 KB] Test 6: TEST OK [0.000 secs, 4328 KB] Test 7: TEST OK [0.000 secs, 4328 KB] Test 8: TEST OK [0.000 secs, 4328 KB] Test 9: TEST OK [0.014 secs, 4328 KB] Test 10: TEST OK [0.154 secs, 4328 KB] Test 11: TEST OK [0.000 secs, 4328 KB] Test 12: TEST OK [0.000 secs, 4328 KB]All tests OK.*/","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"网络流练习4","slug":"网络流24题/第4题/4","date":"2017-08-11T07:46:09.000Z","updated":"2017-08-11T13:36:34.049Z","comments":true,"path":"2017/08/11/网络流24题/第4题/4/","link":"","permalink":"http://yoursite.com/2017/08/11/网络流24题/第4题/4/","excerpt":"魔术球问题有n根柱子，每次可以依次放入编号为1,2,3……个球，每次只能在最上面放球，要求同一根柱子中相邻两球的编号和为完全平方数，问n根柱子上最多能放多少球。","text":"魔术球问题有n根柱子，每次可以依次放入编号为1,2,3……个球，每次只能在最上面放球，要求同一根柱子中相邻两球的编号和为完全平方数，问n根柱子上最多能放多少球。 假设有 n 根柱子，现要按下述规则在这 n 根柱子中依次放入编号为 1，2，3，…的球。（1）每次只能在某根柱子的最上面放球。（2）在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。试设计一个算法，计算出在 n 根柱子上最多能放多少个球。例如，在 4 根柱子上最多可放 11 个球。对于给定的 n，计算在 n 根柱子上最多能放多少个球。 样例输入 ​ 4 样例输出 ​ 11 ​ 1 8 ​ 2 7 9 ​ 3 6 10 ​ 4 5 11 数据范围 ​ N&lt;=60 分析： ​ 我们可以考虑把两个可以相邻的点连上一条有向边，那么答案就是用n条路径覆盖1~Ans所有点。 ​ 可以考虑二分出Ans，然后判断前Ans个是否可行（用最小路径覆盖解决，可以见网络流练习3），可以发现，随着Ans的增大，需要的路劲数是单调非递减的。 ​ 就是从原来的模型——&gt;最小路径覆盖——&gt;二分图匹配——&gt;最大流 ​ 但是其实二分答案，因为每次都要重新建图，所以比较慢，可以考虑每次加入2个点，加入一些边，然后把dist数组重新弄成0，在原来的图的基础上继续找增广路。然后继续找增广路。这样最早得到一个不可行的Ans，Ans-1就是答案。 ​ 最后再把最后2个点删掉，重新跑一边最大流，然后输出方案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;bits/stdc++.h&gt;const int maxAns = 5000;const int maxv = maxAns*2+5;const int maxe = 3200000;const int oo = 1&lt;&lt;30;using namespace std;struct Edge&#123; int from,to,nxt,flow,cap;&#125;;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe * 2]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123;// printf(\"%d:%d --&gt; %d:%d\\n\",nume,a,b,c);// printf(\"Add:Edge[0] . from = %d\",edge[0].from); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; void init_sap()&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); memset(path,0,sizeof(path)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=0;i&lt;n;i++) cur[i] = first[i]; &#125; int sap(int s,int t)&#123; memset(dist,0,sizeof(dist)); int u = s; while (dist[s] != n+1)&#123; if (u == t)&#123; int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123; if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;int n,m;bool vis[maxv];int main()&#123; int s = 0,t = maxAns *2 + 1; G.init(maxAns*2+2); scanf(\"%d\",&amp;n); G.Reset(); int i; for (i=1;i&lt;=maxAns;i++)&#123; G.add_edge(s,i,1); G.add_edge(maxAns + i,t,1); for (int j=1;j&lt;i;j++)&#123; int t = (int)sqrt(1.0*(i+j)); if (t * t == (i+j))&#123; G.add_edge(j,i + maxAns,1); &#125; &#125; int rec = i - G.sap(s,t); if (rec &gt; n)&#123; break; &#125; &#125; //Ans = i int Ans = i-1; for (int j=0;j&lt;G.nume;j++)&#123; if ((G.edge[j].to == i) || (G.edge[j].to == i+maxAns) || (G.edge[j].from == i) || (G.edge[j].from == i+maxAns))&#123; G.edge[j].cap = 0; G.edge[j].flow = 0; &#125; &#125; G.Reset(); G.sap(s,t); /* for (int j=0;j&lt;G.nume;j++)&#123; if ((G.edge[j].to == i) || (G.edge[j].to == i+maxAns) || (G.edge[j].from == i) || (G.edge[j].from == i+maxAns))&#123; G.edge[j].cap = -1; G.edge[j].flow = -1; printf(\"Delete%d--&gt;%d\\n\",G.edge[j].from,G.edge[j].to); &#125; &#125;*/ memset(vis,false,sizeof(vis)); vis[i] = true; printf(\"%d\\n\",Ans); for (int i=1;i&lt;=Ans;i++)&#123; if (vis[i]) continue; int u = i; // printf(\"find(%d) = %d\\n\",i,u); while (true)&#123;// printf(\"%d,%d \\n\",vis[u],u); printf(\"%d \",u); vis[u] = true; bool found = false; for (int e=G.first[u];e!=-1;e=G.edge[e].nxt)&#123;// printf(\"%d--(%d,%d)-&gt;%d\\n\",u,G.edge[e].cap,G.edge[e].flow,G.edge[e].to); if (((e &amp; 1) == 0) &amp;&amp; (G.edge[e].cap == G.edge[e].flow) &amp;&amp; (!vis[G.edge[e].to - maxAns]))&#123; u = G.edge[e].to - maxAns; found = true; break; &#125; &#125; if (!found) break; &#125;// printf(\"\\n%d**\",i); puts(\"\"); &#125;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"网络流练习3","slug":"网络流24题/第3题/3","date":"2017-08-11T05:40:43.000Z","updated":"2017-08-11T07:37:55.454Z","comments":true,"path":"2017/08/11/网络流24题/第3题/3/","link":"","permalink":"http://yoursite.com/2017/08/11/网络流24题/第3题/3/","excerpt":"最小路径覆盖问题给定一个DAG，问这个DAG的最小路劲覆盖数，以及哪些最小路劲（任意输出一个）","text":"最小路径覆盖问题给定一个DAG，问这个DAG的最小路劲覆盖数，以及哪些最小路劲（任意输出一个） 输入描述 第1 行有2个正整数n和m。n是给定有向无环图G 的顶点数，m是G 的边数。接下来的m行，每行有2 个正整数i和j，表示一条有向边(i,j)。 输出描述 将最小路径覆盖输出。从第1 行开始，每行输出一条路径。文件的最后一行是最少路径数。 样例输入 11 121 21 31 42 53 64 75 86 97 108 119 1110 11 样例输出 1 4 7 10 112 5 83 6 93 数据范围 n&lt;=150,m&lt;=6000 问题模型转化： 将一个点拆开，差成2个点，记为X,X’ 如果1到2有一条边，1到3有一条边，2到3有一条边 相当于建立一副二分图 1到2’有边权为1的边 1到3’有边权为1的边 2到3‘有边权为1的边 如果两个点之间有一条边，意味着两个点可以同时在一条路劲上存在。 因此 DAG最小路劲覆盖数=总点数-一个神奇的二分图的最大匹配。 这里只考虑方案数，因为方案其实只需要做完之后顺着一个点正向反向BFS几一下，然后最长的即可。 下面给出只考虑方案的代码： http://codevs.cn/problem/1904/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;const int maxv = 350;const int maxe = maxv*maxv;const int oo = 1&lt;&lt;30;using namespace std;struct Edge&#123; int from,to,nxt,flow,cap;&#125;;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe * 2]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123;// printf(\"%d --&gt; %d:%d\\n\",a,b,c); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; int sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=0;i&lt;n;i++) cur[i] = first[i]; int u = s; while (dist[s] != n+1)&#123;// printf(\"U = %d --&gt;\",u); if (u == t)&#123;// puts(\"Add\"); int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123;// printf(\"%d %d %d\\n\",v,path[v],edge[path[v]].from); if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123;// printf(\"\\nU = %d --&gt;**\\n\",u); bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e;// printf(\"\\n%d--&gt;path[%d] = %d:%d\\n\",u,edge[e].to,e,edge[e].from); u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;int n,m;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); G.init(2*n+2); int s = 0,t = n*2+1; for (int i=1;i&lt;=m;i++)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); G.add_edge(a,n+b,1); &#125; for (int i=1;i&lt;=n;i++)&#123; G.add_edge(s,i,1); G.add_edge(i+n,t,1); &#125; printf(\"%d\\n\",n - G.sap(s,t));&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"网络流练习2","slug":"网络流24题/第2题/2","date":"2017-08-10T13:12:28.000Z","updated":"2017-08-11T12:48:15.159Z","comments":true,"path":"2017/08/10/网络流24题/第2题/2/","link":"","permalink":"http://yoursite.com/2017/08/10/网络流24题/第2题/2/","excerpt":"最大权闭合子图最大权闭合子图问题，有n个实验，每个实验要一些工具，每个工具需要花费，每个实验可以得到收益，求最大化收益。","text":"最大权闭合子图最大权闭合子图问题，有n个实验，每个实验要一些工具，每个工具需要花费，每个实验可以得到收益，求最大化收益。 W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 E={E1，E2，…，Em}，和进行这些实验需要使用的全部仪器的集合 I={I1， I2，… I n } 。实验 Ej需要用到的仪器是 I 的子集 Rj˝I。配置仪器 Ik的费用为 ck美元。实验 Ej的赞助商已同意为该实验结果支付 pj美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。 对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。 输入描述 Input Description 第 1 行有 2 个正整数 m和 n。m 是实验数，n 是仪器数。接下来的 m 行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的 n 个数是配置每个仪器的费用。 输出描述 Output Description 第 1 行是实验编号；第 2行是仪器编号；最后一行是净收益。 样例输入 Sample Input 2 3 10 1 2 25 2 3 5 6 7 样例输出 Sample Output 1 2 1 2 3 17 这题是典型的最大权闭合子图。 这题我们可以这样考虑如果全部做，不买物品，总收益为S 对于一个实验，要么是实验做（相当于花费购买器械的价格），要么是实验不做（相当于减去这个实验的收益） 然后最后我们要最大化收益，也就是使得花费最小。可以考虑到最小割——&gt;最大流 具体这样建图（样例）： 最后求哪些最小割我是穷举每条边重新跑的，其实没有必要，因为这题有SPJ（不一定字典序最小之类），所以一般只需要重新开始沿着没有被割的边BFS即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;bits/stdc++.h&gt; using namespace std;const int maxv = 150;const int maxe = 30000;struct Edge&#123; int from,to,nxt,cap,flow;&#125;; int Mark[maxv],Sum;bool choice[maxv],C[maxv];const int oo = 1&lt;&lt;25;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123; edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; int sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); memset(dist,0,sizeof(dist)); for (int i=1;i&lt;=n;i++) cur[i] = first[i]; int u = s; while (dist[s] != n+1)&#123; if (u == t)&#123; int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123; if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u!=s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;char c = '.';int read(int x)&#123; while ((!((c&gt;='0') &amp;&amp; (c&lt;='9'))) &amp;&amp; ((c!='\\n') || (x == 1))) c=getchar(); if (c == '\\n') return -1; int a = 0; while ((c&gt;='0') &amp;&amp; (c&lt;='9'))&#123; a = a * 10 + c - 48; c=getchar(); &#125; return a;&#125;int m,n;int Son[maxv][maxv];int main()&#123; m = read(1);n = read(1); Sum = 0; G.init(1+m+n+1); for (int u=1;u&lt;=m;u++)&#123; Son[u][0] = 0; int value = read(1); Sum = Sum + value; G.add_edge(1,1+u,value); for (Son[u][++Son[u][0]] = read(0);Son[u][Son[u][0]]!=-1;Son[u][++Son[u][0]]=read(0))&#123; G.add_edge(1+u,1+m+Son[u][Son[u][0]],oo); &#125; &#125; for (int i=1;i&lt;=n;i++)&#123; int dis = read(1); G.add_edge(1+m+i,1+n+m+1,dis); &#125; int Max_flow = G.sap(1,1+n+m+1); for (int e=G.first[1];e!=-1;e=G.edge[e].nxt) if ((e &amp; 1) == 0)&#123;//如果是正向边 //尝试去掉这条边 int tmp1 = G.edge[e].cap; G.edge[e].cap = 0; int tmp2 = G.sap(1,1+n+m+1); G.edge[e].cap = tmp1; if (G.edge[e].cap - G.edge[e].flow != tmp2) choice[G.edge[e].to-1] = true; &#125; memset(C,0,sizeof(C)); for (int i=1;i&lt;=m;i++)&#123; if (choice[i])&#123; printf(\"%d \",i); for (int j=1;j&lt;=Son[i][0];j++)&#123; C[Son[i][j]] = true; &#125; &#125; &#125; puts(\"\"); for (int i=1;i&lt;=n;i++)&#123; if (C[i]) printf(\"%d \",i); &#125; puts(\"\"); printf(\"%d\\n\",Sum-Max_flow);&#125;/*2 310 1 225 2 35 6 7*/","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"网络流练习1","slug":"网络流24题/第1题/1","date":"2017-08-10T12:36:55.000Z","updated":"2017-08-13T14:34:52.669Z","comments":true,"path":"2017/08/10/网络流24题/第1题/1/","link":"","permalink":"http://yoursite.com/2017/08/10/网络流24题/第1题/1/","excerpt":"二分图最大匹配问题​ 从前一个和谐的班级，有 nl 个是男生，有 nr 个是女生。编号分别为 1,…,nl 和 1,…,nr。 有若干个这样的条件：第 v 个男生和第 u个女生愿意结为配偶。 请问这个班级里最多产生多少对配偶？","text":"二分图最大匹配问题​ 从前一个和谐的班级，有 nl 个是男生，有 nr 个是女生。编号分别为 1,…,nl 和 1,…,nr。 有若干个这样的条件：第 v 个男生和第 u个女生愿意结为配偶。 请问这个班级里最多产生多少对配偶？ 输入格式第一行三个正整数，nl,nr,m。 ​ 接下来 m 行，每行两个整数 v,u 表示第 v 个男生和第 u 个女生愿意结为配偶。保证 1≤v≤nl1≤v≤nl，1≤u≤nr1≤u≤nr，保证同一个条件不会出现两次。 输出格式第一行一个整数，表示最多产生多少对配偶。 接下来一行 nl个整数，描述一组最优方案。第 v 个整数表示 v 号男生的配偶的编号。如果 v 号男生没配偶请输出 0。 考虑2种做法，第一种是建图+SAP，最后判断哪些边是被流满了的。 如图： 用Dinic或者SAP，速度是比较快的，大概是sqrt(n)*m，但是代码比较长，这里推荐第二种做法：匈牙利 匈牙利算法主要是基于增广路，也就是每次经过男生~女生~男生~女生，一直到一个未匹配的女生，结束，然后两两对应匹配。时间复杂度O(n^3)——邻接表（数组模拟链表）存和邻接矩阵存差不多，下面给出邻接表的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt; const int maxv = 505;int nl,nr,m,ans; int Map[maxv][maxv],link[maxv],Ans[maxv]; bool vis[maxv]; using namespace std; bool Hungary(int u)&#123; for (int v=1;v&lt;=nr;v++)&#123; if (!vis[v] &amp;&amp; Map[u][v])&#123; vis[v] = true; if (link[v] == -1 || Hungary(link[v]))&#123; link[v] = u; return true; &#125; &#125; &#125; return false; &#125; int c,x; int main()&#123; memset(Map,false,sizeof(Map)); scanf(\"%d%d%d\",&amp;nl,&amp;nr,&amp;m); for (int i=1;i&lt;=m;i++)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); Map[a][b] = true; &#125; ans = 0; memset(link,-1,sizeof(link)); for (int k=1;k&lt;=nl;k++)&#123; memset(vis,false,sizeof(vis)); if (Hungary(k)) ans++; &#125; printf(\"%d\\n\",ans); memset(Ans,0,sizeof(Ans)); for (int i=1;i&lt;=nr;i++)&#123; Ans[link[i]] = i; &#125; for (int i=1;i&lt;=nl;i++)&#123; printf(\"%d \",Ans[i]); &#125; return 0; &#125; 推荐在UOJ上提交，事实上各大OJ一般都有。","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"SAP算法总结","slug":"学习/SAP算法总结","date":"2017-08-09T12:56:24.000Z","updated":"2017-08-11T12:47:47.610Z","comments":true,"path":"2017/08/09/学习/SAP算法总结/","link":"","permalink":"http://yoursite.com/2017/08/09/学习/SAP算法总结/","excerpt":"ISAP算法，一种最大流的优秀算法。","text":"ISAP算法，一种最大流的优秀算法。 概念1：增广路，不解释 概念2：当前弧​ 对于一个点，必然存在当前要处理的弧，一开始，最早的当前弧是它的第一条弧，然后如果下一次他要到下一条边处理，它的当前弧变成下一条边。 具体实现： ·一开始，先跑一发BFS，得到每一个点到汇点的最短距离，这里用最短距离为n+1表示与汇点不联通。 ·在满足源点到汇点联通的情况下（dist[s] != n+1)，每一个节点从那个节点的当前弧开始跑增广路，跑增广路的时候，保存其当前弧，以及整条增广路的路劲。 ·如果到了节点t，那么从节点t开始，一直到s（也就是遍历整条增广路）得到可以增广的量最少的，同时记录这条边的开始那个节点），记为Min_flow和break_point。 ·对整条增广路上的所有路劲减去Min_flow，并同时从break_point开始继续增广。 ·如果当前节点找不到一个后继节点使得dist[u] +1 = dist[nxt]，那么让dist[u]变成它后继节点的dist的最小值+1，如果没有，或者后继节点都到不了t，那么变为n+1。同时，原先那个层次的点的个数-1，当前这个层次的点的个数+1。这个点的当前弧从第一条弧重新开始（如果原先那个层次没有点，说明有断层，直接return即可） ·一直找，直到出现断层。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt; using namespace std;#define maxv 205#define maxe 205struct Edge&#123; int from,to,cap,flow,nxt; //表示从from到to有一条容量为cap，当前流量为flow的边（数组模拟链表的下一个是nxt） &#125;edge[maxe * 2];//总共有maxe条边，还有maxe条反向边 int nume,first[maxv];//边的数量和某个点开始最早的边 int dist[maxv];//当前点到汇点的dist int n,m,path[maxv],cur[maxv];//节点个数，边的个数，增广路以及当前弧 void init()&#123; nume = 0; memset(first,-1,sizeof(first));&#125;//预处理 void add_edge(int a,int b,int c)&#123; edge[nume] . from = a; edge[nume] . to = b; edge[nume] . cap = c; edge[nume] . flow = 0; edge[nume] . nxt = first[a]; first[a] = nume++; //正边 edge[nume] . from = b; edge[nume] . to = a; edge[nume] . cap = 0; edge[nume] . flow = 0; edge[nume] . nxt = first[b]; first[b] = nume++; //反向边 &#125;const int oo = 1&lt;&lt;20;int ISAP(int s,int t)&#123; int u,v,break_point; int num[maxv]; for (int i=1;i&lt;=n;i++) cur[i] = first[i]; int Ans = 0;// bfs(t);//反向BFS，可以不要。 memset(num,0,sizeof(num)); for (int i=1;i&lt;=n;i++) num[dist[i]] ++;//预处理得到每个层次的数量 u = s;//从源点开始 while (dist[s] &lt; n)&#123; if (u == t)&#123;//找到一条增广路 v = u; int Min_flow = oo; while (v!=s)&#123; int e = path[v]; if (edge[e].cap - edge[e].flow &lt; Min_flow)&#123; Min_flow = edge[e].cap - edge[e].flow; break_point = edge[e] . from; &#125; v = edge[e] . from; &#125;//遍历整个增广路，找到Min_flow和break_point Ans = Ans + Min_flow;//增加答案 v = u; while (v!=s)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; v = edge[path[v]] . from; &#125;//改变整条增广路上的flow。 u = break_point;//回到端点 &#125;//end of (u = t) else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; v = edge[e].to; if ((dist[v] == dist[u] - 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; //找到一条可以走的路（满足是下一个，并且容量大于流量） path[v] = e; cur[u] = e; u = v; found = true; break; &#125; &#125; if (!found)&#123;//Retreat int tmp = n+1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; v = edge[e].to; tmp = min(tmp,dist[v] + 1); &#125;//得到其子节点的所有dist中最小的+1 num[dist[u]]--;//原来层次的点数-1 if ((num[dist[u]]) == 0) return Ans;//断点优化，也叫做GAP优化 dist[u] = tmp;//更新层次 num[tmp] = num[tmp] + 1;//新的层次的点数增加 cur[u] = first[u];//当前弧从头开始 if (u != s) u = edge[path[u]].from;//前面的点也要改过 &#125; &#125; &#125; return Ans;//返回结果 &#125;int main()&#123; init(); scanf(\"%d%d\",&amp;m,&amp;n); for (int i=1;i&lt;=m;i++)&#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); add_edge(a,b,c); &#125; printf(\"%d\\n\",ISAP(1,n));&#125;","categories":[],"tags":[]}]}