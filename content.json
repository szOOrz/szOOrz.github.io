[{"title":"想想","date":"2017-08-19T11:48:55.000Z","path":"2017/08/19/想想/","text":"","raw":"---\ntitle: 想想\ndate: 2017-08-19 19:48:55\ntags:\n---\n","link":"","tags":[]},{"title":"codeforces","date":"2017-08-19T05:10:03.000Z","path":"2017/08/19/Codeforces/codeforces/","text":"一道题目一道题目写太乱了， 感觉无法忍受 打算学大佬的写法。 不贴代码Orz Codeforces Round #327 (Div. 1) CF590A:给你一个只有0和1组成的序列A，每次可以对序列A进行操作，每次操作是把A的每一个元素变成上一个序列的它，它左边，它右边3个数的中位数，其中1和n不变。问几次操作后会变成稳定——不会再改变，然后稳定时候的状态是怎么样的。 划分 ​ 对于中间的元素，只有一种情况会使得其改变：010或者101——其中它在中间。考虑可以把整个序列划分成一些稳定的两端构成的序列 如，把1010101010111010101划分成10101010101|1|1010101这3部分，然后每一部分最终都会变成4种形态:11110000或者00001111或者11111111或者00000000这种。 既然这样，就可以处理，然后答案对操作数取一个Max即可。线性O(n)扫描。 CF590B:您要从(x1,y1)到(x2,y2)，一开始风速为(vx,vy)，t秒后(wx,wy)，您的速度不超过Vmax，求最少到终点的时间，保证风速小于您的速度，风速和您的速度都是向量 二分答案 ​ 二分答案，然后假设人不动，判断是否可行。 CF590C:给定一个N*M的矩阵，这个矩阵里面有’1’,’2’,’3’,’.’,’#’,你可以把’.’改成桥，使得所有1,2,3四联通，问最少把多少个’.’改变，其中‘#’不能改变，如果不能输出-1。——其中’1’,’2’,’3’本身是连续的 BFS ​ 注意到，桥一定会在一个点交汇——这个点可能在某个国家里面，也可能在’.’位置。我们可以考虑枚举这个交汇点的位置，然后把3个国家到这个点的Dis全部加起来，取Min就是结果为什么是对的呢？这个不会有重复吗？会的。不过必然有一个点没有，那就是交汇点。我们可以预处理出某一个国家到一个点路上最少经过的’.’的个数——我用循环入队一直T，后来改成优先队列做的——事实上还有更好的方法。然后枚举每一个点，当然，如果这个点是’.’会被计算3次，要减去。 CF590D:n个数，求最多相邻两两交换S次，使前K个数的和最小 DP ​ 注意到，N*(N-1)/2&lt;=S的时候，S的大小已经没有什么用途了考虑用dp[i,j,k]表示处理到前i个数字，其中已经交换了j次的，前k个已经确定的最小数字之和考虑把第i个交换到第k个位置——或者不交换。不交换的话$dp[i,j,k] = dp[i-1,j,k]$交换的话$dp[i,j,k] = dp[i-1,j - (i-k) , k-1] + a[i]$用滚动数组优化一下答案就是$dp[N,X,K] (X&lt;=S)$ Codeforces Round #330 (Div. 1) CF594A:数轴上有N个点，N是偶数。有两个人，依次取走一个点，直到最后剩下2个点，其中第一个人（先取要最后剩下的点的距离最大），第二个人要使得距离最小，问距离最小是多少。 博弈 ​ 如果您作为第二个人，您一定会去取两端的。如果存在答案区间L,R。显然，第二个人一定会取L,R以外的。 ​ 相反，第一个人会取L,R以内的，因为L,R以外的第二个人会去取。所以答案就是在其中找一段区间，使得内部有(N-2)/2个点，然后区间最小。 CF594C平面上，给你n个点，然后你可以删除k个点然后让你用一个两边平行于坐标轴的矩形，去围住这n-k个点，问这个矩形的面积，最小可以是多少$(K&lt;=10)$ ​ 暴力，考虑到只会删除上下左右4个方向的点，先暴力得到上下删除哪些点，然后再暴力得到左右删了哪些点，用一个标记数组维护。 CF594D:给你n个数(n&lt;=200000)，每个数&lt;=1e6，给出Q个询问，每个询问给出l,r,问的值是多少。 ​ 回顾一下欧拉函数的求法 $$\\large cp[n] =n* \\prod_p^{p是n的质因数}(p-1) / p$$ ​ 同样的，扩展到区间 $$\\large cp[Π(A[L]-A[R])] = \\prod_{i=L}^{R}(A[i]) * \\prod_p^{p是这些乘积的质因数}(p-1)/p$$ ​ 这题没有修改操作，一切都是询问，可以考虑离线处理。我们把所有询问按照右端点排序。那么如何处理(L~R)这一段的乘积的欧拉函数呢？事实上，L~R中间的数的乘积我们可以通过前缀$O(1)$得出来，我们需要的就是L~R这一段所有数包含的质因数(p)的(p-1) / p，当然，在Mod意义下是逆元。这里，我们先假设每个数出现不同的质因数。计$Xi = (p1-1) / (p1) * (p2-1) / p2$……，其中p1,p2是ai的质因数同样的，我们可以保存前缀，算得$X1$~$Xr$的乘积，然后再算得到$X1$~$X_(l-1) $的乘积，然后可以O1求解。然而，我们要知道，每个数可能拥有同样的质因数。显然，由于我们已经按照右端点排序 ​ 我们可以把所有可能的质因子保存在最右边出现质因子的地方。用一棵树状数组维护前缀Xi的乘积。对于新加入的一个数$Ai$，考虑得到它的所有质因数，如果这些质因数还没有出现过，那么把(p-1)/p弄上去，否则，不但要把(p-1)/p弄到这个节点上，还要把p / (p-1)弄到前面出现p的节点上，以消除p的重复影响。 Codeforces Round #333 (Div. 1) CF601A有个地方有些城镇，城镇与城镇间如果有铁路相连，就不会有公路相连，没有铁路连接的城镇就会有公路相连。给你n个城镇数目，m铁路线，问同时从1出发，分别坐火车和坐汽车到达n点，两者都到达的时候最少的用时。其中火车和汽车不能同时到达中间点。 ​ 跑2次最短路即可。 CF601B给定n个hi，然后定义·if n &lt; 2, ·if n ≥ 2, over all 1 ≤ i &lt; j ≤ n 给出区间L,R，问区间L,R的所有子段的L函数之和。 脑洞，单调栈 ​ 把$i$看成横坐标，$h[i]$看作纵坐标，那么$L(h)$其实就是一个区间中的某两点之间的斜率绝对值，从而可以证明$L(h)$一定是坐标相邻的点的斜率的绝对值$L(h) = abs(h[i+1] - h[i]) ——1&lt;=i&lt; n$设$D[i] = h[i] - h[i-1].$那么答案就是各个$f[i]$的贡献和，这个可以通过单调栈做出来。通过单调栈，可以得到这个位置向左严格最大到哪边，向右不严格最大到哪边——主要是为了让每个区间都加入计数。 CF601C有$n$场比赛，每一场比赛都有$m$人参与。每场比赛的得分都是这个人的排名（没有相等的）总分是$n$场比赛的分数之和。总排名定义为：总分严格小于他的人数$+1$。已知小K在$n$场比赛中的排名。所有人的水平相同，求小K的期望总排名。 DP ​ 考虑到直接计算排名比较麻烦，设$f[i,j]$表示$i$场比赛之后，总分为$j$的期望人数，那么可以得到一个转移方程：$\\large f[i,j] = \\sum\\frac{f[i-1][j-k]}{m-1}(i&lt;=k&lt;=m,k≠a[i])$，通过这个式子观察之后我们可以发现，可以前缀和优化转移，于是采用差分方法实现。 Codeforces Round #334 (Div. 1) CF603A有一个长度为n的1,0组成的串，可以将其中连续一段翻转，使得剩下的1010交替出现的子序列最长。 DP(1A) ​ 考虑用$f[i]$,$g[i]$,$h[i]$分别表示还没有翻转，正在翻转，翻转完了的$ans$，最后取一个$max$即可。 CF603C，有n堆石子，如果某一个石子是偶数，可以选择得到k堆石子数/2个，奇偶都可以得到石子数-1个石子。没法操作者败 博弈(3A) ​ 考虑SG函数打表找规律，当i为奇数的时候，$SG[i] = mex SG[i-1]$，当i为偶数的时候,能执行第二种操作，所以$SG[i] = mex(SG[i-1],SG[i/2] xor SG[i/2]……共k个)$，由此可以得到，答案之和$k$的奇偶有关，当$k$是奇数的时候，$SG[i] = mexSG[i-1],0$，所以往后一定是01交替出现，当$k$是偶数的时候，SG当$i$是奇数的时候为0，否则只需要$SG[i/2]$递归调用，取$mex$即可，注意到，不会超过$log$次调用。 Codeforces Round #335 (Div. 1) CF605A给定$n$的一个排列，每次可以把一个数放到开头或末尾，求变为升序的最少步骤 DP(1A)​ 考虑就是寻找到一个每位都递增1的最长上升子序列，然后这些不动，其它改变。用DP求即可。 CF605B有一个$n$个点，$m$条边的图，然后$m$条边中有$n−1$条边构成了最小生成树，然后边权与是否作为$MST$的边告诉你，要构造出这个图。 构造(2A) ​ 逐个添加，如果应该作为最小生成树的，考虑可以把1和这个节点连接，如果不应该作为最小生成树的，考虑把剩下可以用的边连接，如果无法连接，就是无解。当加入一个新节点，可以用的边加入这个点到前面非1的位置的。新节点只有当最小生成树的边加入时才增加。 CF605C有$n$项工作，第ii项工作每天可以带来$ai$的经验，$bi$的钱。问最少几天可以得到$p$的经验和$q$的钱。工作天数可以是小数，每次只能进行一种工作。 二分答案，凸包(10A)——注意LL ​ 考虑把(ai,bi)看作平面上的一个点，注意到，一个点可行，当且仅当这个点是平面的凸包上的点——否则一定有2个点比这个点优。进一步，一定是凸包一个点，或者相邻两个点组合得到的。 ​ 考虑二分答案，然后用类似解二元一次方程的方法，把凸包相邻2个点，或者凸包上的一个点组合得到的算出来，输出解即可。 CF605D玩家有两个属性$x,y$，有$n$个魔法。对于第$i$个魔法，用$(ai,bi,ci,di)$描述。当$ai&lt;=x,bi&lt;=y$时，玩家能使用这个魔法。之后玩家的属性$x=ci,y=di$。求施展第n个魔法最少需要多少次。输出方案，答案不唯一。 BFS，树状数组，set(2A) ​ 相当于一个二维平面，因为是最小步数，很容易想到$BFS$，但是$BFS$的扩展节点只能扩展这个的左下方的，为了快速扩展（线段树套线段树显然可行）——用一个更容易实现的，考虑树状数组（离散化后的x坐标）套$set$，来快速维护下一个应该扩展的点，那么就是在左下角寻找一个满足条件的，（用树状数组），然后用$set$的lower_ bound快速寻找，然后扩展。时间复杂度$O(n log(n) log(n) )$ Wunder Fund Round 2016 (Div. 1 + Div. 2 combined) CF618E原来有一个N个段的长度为1的段，然后有m个操作，操作1是给定第X段，然后把第X段延长，变成多少Y，然后操作2是把某一个段按照原先的左端点旋转α°，每次操作完了询问原先最右边的端。 $n,m&lt;=300 000$ 线段树 可以用线段树维护两个点之间的相对位移这里有一些公式：假设任意点(x,y)，绕一个坐标点(rx0,ry0)逆时针旋转a角度后的新的坐标设为(x0, y0)： $x0= (x - rx0) \\times cos(a) - (y - ry0)\\times sin(a) + rx0 ;$ $y0= (x - rx0)\\times sin(a) + (y - ry0)\\times cos(a) + ry0 ;$ 显然，延长操作只是单点修改。——保存位移之后只要同比例缩放就行了.那么旋转呢？这是一个区间修改。对于后面全部整段，都是需要绕着某个点进行旋转的。其实，角度是可以叠加的:___大家可以自己画图，然后用延长用四点共圆证明……角度竟然是可以叠加的! 然后就好做多了……QAQ。——本来还想着用矩阵结合律。。。 Codeforces Round #345 (Div. 1) CF650D给定一个长度为n的数列，和m个询问，每个询问给出Ai,Bi表示把第Ai个数改成Bi之后，这个数列的最长上升子序列（严格大于,询问相互独立） 线段树 ​ 具体做法分成2部分。一方面，我们要求得改过之后经过改过的点的LIS。这个比较好实现，离散化之后排个序离线用两棵线段树正反两次扫描维护。另一方面，我们要求得不经过这个点的LIS我们再把这个分为两部分。如果原来的LIS（至少有一条）不包括那个点，那么答案就是原来的LIS。如果所有的LIS都包括那个点，那么答案就是原来的LIS-1。一个点如何可能是LIS中的一个呢？注意到，当他的前缀LIS加上后缀LIS等于总的LIS+1的时候。那么我们只需要统计，这个点是不是唯一的这个位置。怎么样算唯一呢？就是它的前缀LIS（或者后缀）长度，除了它，没有别的点了。因此，我们只需要满足2个条件，这个点就是原来的LIS-1了。 ​ $1、L(LIS)_i+R(LIS)_i=Lis+1$ $2、there.is.only.one.L(LIS)_i$ ​ 还是通过正反两次扫描实现。 IndiaHacks 2016 - Online Edition CF653E:n个点，m条不能相连的边，点1的度为k（相连的边有且仅有k条）。问是否能构成一棵树。 set维护BFS ​ 考虑将1除去之后，得到剩下的联通块，其中有一个联通块没有向1的边，说明impossible，否则，如果联通块的数量大于等于k，说明无解。——因为联通块里面是可以随意连的。那么如何求联通块呢，考虑BFS。但是普通的BFS的复杂度会到$O(N^2)$，而这题的N比较大，是撑不住的，注意到，选取点有很大的冗余——因为每个点最多只会被访问1次，那么如何选点的？考虑用一个set维护还没有被访问过的点，访问一个点，将这个点从set中删去。对于某个点开始，寻找set中的元素，如果可以访问，那么访问，同时删去。 ​ 注意到，这个时间复杂度只有$O((n+m)log n)$。 VK Cup 2016 - Round 1 CF639B：构造一棵树，使得树有n个节点，直径是D，树高是H，不存在输出-1 构造 显然，D&gt;2*H无解。否则，考虑先把直径画好。 ​ 直径分为两部分，两部分分别画好，然后再把剩下的点弄到1号那里 ​ D=H要特殊处理。 CF639C：定义一个合法的n次多项式f(x)，满足最高项系数an!=0，所有系数ai都是整数，且绝对值不超过K。 现在给您一个合法的n次多项式P(x)，但P(2)!=0。您需要改变其中一个系数，仍然得到一个n次多项式Q(x)。满足Q(2)=0。求方案数。$n&lt;=200000$ 多项式 ​ 考虑把系数转化成二进制，除了最高位。 ​ 那么要使得可以消掉，必然是满足当前的系数左边没有1或者-1。 ​ 那么考虑把系数转化成二进制后，倒着把系数推回来，得到右边一段的系数相当于是多少，记为sum ​ sum的求值可以每次 2+当前元素得到。那么如果i左边的系数（小的系数）满足都是0，那么我们知道，当前这个Q的值显然就是$sum 2^i$。所以只要把这一位的系数减去这个sum，就能保证整个$Q(2) = 0$。 ​ 因此，我们只需要先正着扫一遍，得到最低的非0位的位置。 ​ 然后倒着扫一遍，得到sum，并统计。 ​ 注意的是，当sum&gt;2*k的时候，已经没有必要继续统计了。 CF639D：有n个人，每个人都有自己的贡献ti（任意整数）可以花费b，使得某个人的贡献+5,花费c，使得某个人的贡献+1.求至少使得k个人的贡献相等，最少需要的花费。$k&lt;=n&lt;=200000,$$1&lt;=b,c&lt;=1000$ $|t_i|&lt;=1e9$ 优先队列维护前k小的数的和 ​ 考虑首先对于输入的数排序。同时如果$b=min(b,c\\times 5)$，那么得到所有可能最后的相同的那个数（一定不会超过某个数+0,1,2,3,4,5这个范围），然后考虑枚举所有的Ans，下一步的操作是要在所有数中寻找满足条件的最小花费的k个数。可以把花费看作一些数，先变成对应的mod 5=r的数，然后再一直加上b。考虑到我们已经排序了，所以这个右指针（哪些是包含的）是会单调递增的。设x mod 5 = r;考虑预处理出每一个数到mod 5 = r的数值为t[i,r]，那么最后的最小花费必然是选出一些i，使得$min(∑(t[i,r] - a[i]) \\times c + ∑(x - t[i,r]) / 5 \\times b)$，考虑到x[i]和t[i,r]的余数是一样的，可以化简为 $$\\large k \\times （x / 5 \\times b） + \\sum _{i}^{t[i,r]&lt;=x}(t[i,r] \\times c - a[i] \\times c - t[i,r] / 5 \\times b)$$ 考虑维护5个堆，得到这5个堆中元素和，压入一个元素，加上这个sum，如果元素个数超过k，将大的弹出来，减去这个sum。 Codeforces Round #347 (Div. 1) CF663A:给定一些类似?+?-?=n表达式，然后知道最后一个数字为n（给定），然后在前面填（1~n)的数，问可不可能有满足条件的等式，可能输出Possible并给出一组解。 脑洞(2A) ​ 考虑对于使得表达式最小的式子，加是+1，减是-n，再考虑使得表达式最大的式子，加是+n，减是-1，那么如果n在两者之间，这个式子一定可以通过一定的改变得到，否则就是不行。 ​ 为了实现简单，只要统计加法有多少，减法有多少就可以得到了。构造主要可以这样实现，对于每一个位置，找到一个最小的使得后面依旧可以填的(这个值不会很大)。这样好实现很多。然后n去掉这个值，继续处理。虽然可以二分，但是麻烦。注意如果你是改变n的，记得保存一个n的镜像。 CF663B:给出了一个数字的后缀，要求最终这个数字大于等于1989，并且在最小的情况下，这个数字之前没有被占用过。求最终拼凑的数字。 不会QAQ CF663C:有一个n个点，m条边的无向图，一开始，每条边的颜色都是给定的，然后玩家选择一个顶点，把相邻的边的颜色反转一下，问使得所有边颜色相同最少反转几下，输出那些反转的顶点，不可以输出-1.$(1 ≤ n, m ≤ 100 000)$ 并查集(6A) ​ 不失一般性，考虑把所有边的颜色变成红色，那么可以把整个图分成不同的联通块，每个联通块分别处理。如果有一条边是蓝色的，说明这条边的左右两端的状态是不同的，如果是红色的，说明状态是相同的。对于一个联通块，显然只有2类。那么我们只需要在2类中取较小的一类即可。 ​ 考虑用2个并查集，分别维护相同类和不同类。 CF663D: 不会QAQ CF663E:有一个n*m的表格，包含0或1.每一次可以选择一行，或一列翻转(0&lt;-&gt;1)。求一些操作后，1的个数的最小值。$n&lt;=20, m&lt;=100000 $ FWT优化(4A) ​ 很容易想到一个暴力，是枚举行变化$O(2^n)$，然后贪心验证$O(n*m)$，然后利用位运算，可以通过预处理先得到$v_i$表示$i$，或者$i$的翻转包含的最少的1的个数($i$是一状压二进制)，$v_i = min(|i|,n-|i|)$，那么设某一列状压之后是$A_i$，当前枚举到行变化是$s$，那么如果用$Ans[s]$表示在s状态能够获得的最大$Ans$，用$cnt[i]$表示所有列中$i$出现了几次可以得到， $$\\large Ans[s] =\\sum{i=0}^{2^n-1} v{s⊕i} * cnt_i$$ ————然后，上面这个式子是可以通过FWT优化的，因为这个等价于存在两个向量$cnt$和$v$，然后要求它们的亦或卷积得到的另一个向量。 $$\\large Ans[s] = \\sum_{j⊕k =i}cnt_j*v_k$$ 因此，跑一个 $$FWT(A) = (FWT(A0)+FWT(A1),FWT(A0)-FWT(A1))$$ $$IFWT(A)=IFWT((A0+A1) \\div2,(A0-A1)\\div2)$$ 最后来一个统计就有结果了——虽然我也不知道怎么构造，我也不知道怎么证明。","raw":"---\ntitle: codeforces\ndate: 2017-08-19 13:10:03\ntags:\n - codeforces\n---\n\n一道题目一道题目写太乱了，\n\n感觉无法忍受\n\n打算学大佬的写法。\n\n不贴代码Orz\n\n<!--more-->\n\n\n\n##### [Codeforces Round #327 (Div. 1)](http://codeforces.com/contest/590)\n\n> **CF590A**:给你一个只有0和1组成的序列A，每次可以对序列A进行操作，每次操作是把A的每一个元素变成上一个序列的它，它左边，它右边3个数的中位数，其中1和n不变。问几次操作后会变成稳定——不会再改变，然后稳定时候的状态是怎么样的。\n\n**划分**\n\n​\t对于中间的元素，只有一种情况会使得其改变：010或者101——其中它在中间。考虑可以把整个序列划分成一些稳定的两端构成的序列\t如，把1010101010111010101划分成10101010101|1|1010101这3部分，然后每一部分最终都会变成4种形态:11110000或者00001111或者11111111或者00000000这种。\t既然这样，就可以处理，然后答案对操作数取一个Max即可。线性O(n)扫描。\n\n> **CF590B:**您要从(x1,y1)到(x2,y2)，一开始风速为(vx,vy)，t秒后(wx,wy)，您的速度不超过Vmax，求最少到终点的时间，保证风速小于您的速度，风速和您的速度都是向量\n\n**二分答案**\n\n​\t二分答案，然后假设人不动，判断是否可行。\n\n> **CF590C:**给定一个N*M的矩阵，这个矩阵里面有'1','2','3','.','#',你可以把'.'改成桥，使得所有1,2,3四联通，问最少把多少个'.'改变，其中‘#'不能改变，如果不能输出-1。——其中'1','2','3'本身是连续的\n\n**BFS**\n\n​\t注意到，桥一定会在一个点交汇——这个点可能在某个国家里面，也可能在'.'位置。我们可以考虑枚举这个交汇点的位置，然后把3个国家到这个点的Dis全部加起来，取Min就是结果为什么是对的呢？这个不会有重复吗？会的。不过必然有一个点没有，那就是交汇点。我们可以预处理出某一个国家到一个点路上最少经过的'.'的个数——我用循环入队一直T，后来改成优先队列做的——事实上还有更好的方法。然后枚举每一个点，当然，如果这个点是'.'会被计算3次，要减去。\n\n> **CF590D:**n个数，求最多相邻两两交换S次，使前K个数的和最小\n\n**DP**\n\n​\t注意到，N*(N-1)/2<=S的时候，S的大小已经没有什么用途了考虑用dp[i,j,k]表示处理到前i个数字，其中已经交换了j次的，前k个已经确定的最小数字之和考虑把第i个交换到第k个位置——或者不交换。不交换的话$dp[i,j,k] = dp[i-1,j,k]$交换的话$dp[i,j,k] = dp[i-1,j - (i-k) , k-1] + a[i]$用滚动数组优化一下答案就是$dp[N,X,K] (X<=S)$\n\n\n\n##### [Codeforces Round #330 (Div. 1)](http://codeforces.com/contest/594)\n\n> **CF594A:**数轴上有N个点，N是偶数。有两个人，依次取走一个点，直到最后剩下2个点，其中第一个人（先取要最后剩下的点的距离最大），第二个人要使得距离最小，问距离最小是多少。\n\n**博弈**\n\n​\t如果您作为第二个人，您一定会去取两端的。如果存在答案区间L,R。显然，第二个人一定会取L,R以外的。\n\n​\t相反，第一个人会取L,R以内的，因为L,R以外的第二个人会去取。所以答案就是在其中找一段区间，使得内部有(N-2)/2个点，然后区间最小。\n\n> **CF594C**平面上，给你n个点，然后你可以删除k个点然后让你用一个两边平行于坐标轴的矩形，去围住这n-k个点，问这个矩形的面积，最小可以是多少$(K<=10)$\n\n​\t**暴力**，考虑到只会删除上下左右4个方向的点，先暴力得到上下删除哪些点，然后再暴力得到左右删了哪些点，用一个标记数组维护。\n\n> **CF594D:**给你n个数(n<=200000)，每个数<=1e6，给出Q个询问，每个询问给出l,r,问![img](http://codeforces.com/predownloaded/30/e5/30e539b0cc8f5d37f524dd78cdc549a4fa5c7a93.png)的值是多少。\n\n​\t回顾一下欧拉函数的求法\t$$\\large cp[n] =n* \\prod_p^{p是n的质因数}(p-1) / p$$\n\n​\t同样的，扩展到区间\t$$\\large cp[Π(A[L]-A[R])] = \\prod_{i=L}^{R}(A[i]) * \\prod_p^{p是这些乘积的质因数}(p-1)/p$$\n\n​\t这题没有修改操作，一切都是询问，可以考虑离线处理。我们把所有询问按照右端点排序。那么如何处理(L~R)这一段的乘积的欧拉函数呢？事实上，L~R中间的数的乘积我们可以通过前缀$O(1)$得出来，我们需要的就是L~R这一段所有数包含的质因数(p)的(p-1) / p，当然，在Mod意义下是逆元。这里，我们先假设每个数出现不同的质因数。计$Xi = (p1-1) / (p1) * (p2-1) / p2$……，其中p1,p2是ai的质因数同样的，我们可以保存前缀，算得$X1$~$Xr$的乘积，然后再算得到$X1$~$X_(l-1) $的乘积，然后可以O1求解。然而，我们要知道，每个数可能拥有同样的质因数。显然，由于我们已经按照右端点排序\n\n​\t我们可以把所有可能的质因子保存在最右边出现质因子的地方。用一棵树状数组维护前缀Xi的乘积。对于新加入的一个数$Ai$，考虑得到它的所有质因数，如果这些质因数还没有出现过，那么把(p-1)/p弄上去，否则，不但要把(p-1)/p弄到这个节点上，还要把p / (p-1)弄到前面出现p的节点上，以消除p的重复影响。\n\n\n\n\n\n##### [Codeforces Round #333 (Div. 1)](http://codeforces.com/contest/601)\n\n> **CF601A**有个地方有些城镇，城镇与城镇间如果有铁路相连，就不会有公路相连，没有铁路连接的城镇就会有公路相连。给你n个城镇数目，m铁路线，问同时从1出发，分别坐火车和坐汽车到达n点，两者都到达的时候最少的用时。其中火车和汽车不能同时到达中间点。\n\n​\t跑2次最短路即可。\n\n> **CF601B**给定n个hi，然后定义·if *n* < 2, ![img](http://codeforces.com/predownloaded/a3/7d/a37dc46ef6a265bb8f01595c2118a82b456b068a.png)·if *n* ≥ 2, ![img](http://codeforces.com/predownloaded/cf/32/cf32e97135c9c6e4e441357b5c63e0b5a8d93ffe.png) over all 1 ≤ *i* < *j* ≤ *n*\n>\n> 给出区间L,R，问区间L,R的所有子段的L函数之和。\n\n**脑洞，单调栈**\n\n​\t把$i$看成横坐标，$h[i]$看作纵坐标，那么$L(h)$其实就是一个区间中的某两点之间的斜率绝对值，从而可以证明$L(h)$一定是坐标相邻的点的斜率的绝对值$L(h) = abs(h[i+1] - h[i]) ——1<=i< n$设$D[i] = h[i] - h[i-1].$那么答案就是各个$f[i]$的贡献和，这个可以通过单调栈做出来。通过单调栈，可以得到这个位置向左严格最大到哪边，向右不严格最大到哪边——主要是为了让每个区间都加入计数。\n\n> **CF601C**有$n$场比赛，每一场比赛都有$m$人参与。每场比赛的得分都是这个人的排名（没有相等的）总分是$n$场比赛的分数之和。总排名定义为：总分严格小于他的人数$+1$。已知小K在$n$场比赛中的排名。所有人的水平相同，求小K的期望总排名。\n\n**DP**\n\n​\t考虑到直接计算排名比较麻烦，设$f[i,j]$表示$i$场比赛之后，总分为$j$的期望人数，那么可以得到一个转移方程：$\\large f[i,j] = \\sum\\frac{f[i-1][j-k]}{m-1}(i<=k<=m,k≠a[i])$，通过这个式子观察之后我们可以发现，可以前缀和优化转移，于是采用差分方法实现。\n\n##### [Codeforces Round #334 (Div. 1)](http://codeforces.com/contest/603)\n\n> **CF603A**有一个长度为n的1,0组成的串，可以将其中连续一段翻转，使得剩下的1010交替出现的子序列最长。\n\n**DP**(1A)\n\n​\t考虑用$f[i]$,$g[i]$,$h[i]$分别表示还没有翻转，正在翻转，翻转完了的$ans$，最后取一个$max$即可。\n\n> **CF603C**，有n堆石子，如果某一个石子是偶数，可以选择得到k堆石子数/2个，奇偶都可以得到石子数-1个石子。没法操作者败\n\n**博弈**(3A)\n\n​\t考虑SG函数打表找规律，当i为奇数的时候，$SG[i] = mex SG[i-1]$，当i为偶数的时候,能执行第二种操作，所以$SG[i] = mex(SG[i-1],SG[i/2] xor SG[i/2]……共k个)$，由此可以得到，答案之和$k$的奇偶有关，当$k$是奇数的时候，$SG[i] = mexSG[i-1],0$，所以往后一定是01交替出现，当$k$是偶数的时候，SG当$i$是奇数的时候为0，否则只需要$SG[i/2]$递归调用，取$mex$即可，注意到，不会超过$log$次调用。\n\n#####  [Codeforces Round #335 (Div. 1)](http://codeforces.com/contest/605)\n\n> **CF605A**给定$n$的一个排列，每次可以把一个数放到开头或末尾，求变为升序的最少步骤\n\n**DP**(1A)\n​\t考虑就是寻找到一个每位都递增1的最长上升子序列，然后这些不动，其它改变。用DP求即可。\n\n> **CF605B**有一个$n$个点，$m$条边的图，然后$m$条边中有$n−1$条边构成了最小生成树，然后边权与是否作为$MST$的边告诉你，要构造出这个图。\n\n**构造**(2A)\n\n​\t逐个添加，如果应该作为最小生成树的，考虑可以把1和这个节点连接，如果不应该作为最小生成树的，考虑把剩下可以用的边连接，如果无法连接，就是无解。当加入一个新节点，可以用的边加入这个点到前面非1的位置的。新节点只有当最小生成树的边加入时才增加。\n\n> **CF605C**有$n$项工作，第ii项工作每天可以带来$ai$的经验，$bi$的钱。问最少几天可以得到$p$的经验和$q$的钱。工作天数可以是小数，每次只能进行一种工作。\n\n**二分答案，凸包**(10A)——注意LL\n\n​\t考虑把(ai,bi)看作平面上的一个点，注意到，一个点可行，当且仅当这个点是平面的凸包上的点——否则一定有2个点比这个点优。进一步，一定是凸包一个点，或者相邻两个点组合得到的。\n\n​\t考虑二分答案，然后用类似解二元一次方程的方法，把凸包相邻2个点，或者凸包上的一个点组合得到的算出来，输出解即可。\n\n> **CF605D**玩家有两个属性$x,y$，有$n$个魔法。对于第$i$个魔法，用$(ai,bi,ci,di)$描述。当$ai<=x,bi<=y$时，玩家能使用这个魔法。之后玩家的属性$x=ci,y=di$。求施展第n个魔法最少需要多少次。输出方案，答案不唯一。\n\n**BFS，树状数组，set**(2A)\n\n​\t相当于一个二维平面，因为是最小步数，很容易想到$BFS$，但是$BFS$的扩展节点只能扩展这个的左下方的，为了快速扩展（线段树套线段树显然可行）——用一个更容易实现的，考虑树状数组（离散化后的x坐标）套$set$，来快速维护下一个应该扩展的点，那么就是在左下角寻找一个满足条件的，（用树状数组），然后用$set$的lower_ bound快速寻找，然后扩展。时间复杂度$O(n * log(n) * log(n) )$\n\n\n\n[Wunder Fund Round 2016 (Div. 1 + Div. 2 combined)](http://codeforces.com/contest/618)\n\n> **CF618E**原来有一个N个段的长度为1的段，然后有m个操作，操作1是给定第X段，然后把第X段延长，变成多少Y，然后操作2是把某一个段按照原先的左端点旋转α°，每次操作完了询问原先最右边的端。\n>\n> $n,m<=300 000$\n\n**线段树**\n\n可以用线段树维护两个点之间的相对位移这里有一些公式：假设任意点(x,y)，绕一个坐标点(rx0,ry0)逆时针旋转a角度后的新的坐标设为(x0, y0)：\n\n$x0= (x - rx0) \\times cos(a) - (y - ry0)\\times sin(a) + rx0 ;$\n\n$y0= (x - rx0)\\times sin(a) + (y - ry0)\\times cos(a) + ry0 ;$\n\n显然，延长操作只是单点修改。——保存位移之后只要同比例缩放就行了.那么旋转呢？这是一个区间修改。对于后面全部整段，都是需要绕着某个点进行旋转的。其实，角度是可以叠加的:___大家可以自己画图，然后用延长用四点共圆证明……角度竟然是可以叠加的! 然后就好做多了……QAQ。——本来还想着用矩阵结合律。。。\n\n\n\n##### [Codeforces Round #345 (Div. 1)](http://codeforces.com/contest/650)\n\n> **CF650D**给定一个长度为n的数列，和m个询问，每个询问给出Ai,Bi表示把第Ai个数改成Bi之后，这个数列的最长上升子序列（严格大于,询问相互独立）\n\n**线段树**\n\n​\t具体做法分成2部分。一方面，我们要求得改过之后经过改过的点的LIS。这个比较好实现，离散化之后排个序离线用两棵线段树正反两次扫描维护。另一方面，我们要求得不经过这个点的LIS我们再把这个分为两部分。如果原来的LIS（至少有一条）不包括那个点，那么答案就是原来的LIS。如果所有的LIS都包括那个点，那么答案就是原来的LIS-1。一个点如何可能是LIS中的一个呢？注意到，当他的前缀LIS加上后缀LIS等于总的LIS+1的时候。那么我们只需要统计，这个点是不是唯一的这个位置。怎么样算唯一呢？就是它的前缀LIS（或者后缀）长度，除了它，没有别的点了。因此，我们只需要满足2个条件，这个点就是原来的LIS-1了。\n\n​\t$1、L(LIS)_i+R(LIS)_i=Lis+1$        $2、there.is.only.one.L(LIS)_i$\n\n​\t还是通过正反两次扫描实现。\n\n\n\n##### [IndiaHacks 2016 - Online Edition ](http://codeforces.com/contest/653)\n\n>**CF653E:**n个点，m条不能相连的边，点1的度为k（相连的边有且仅有k条）。问是否能构成一棵树。\n\n**set维护BFS**\n\n​\t考虑将1除去之后，得到剩下的联通块，其中有一个联通块没有向1的边，说明impossible，否则，如果联通块的数量大于等于k，说明无解。——因为联通块里面是可以随意连的。那么如何求联通块呢，考虑BFS。但是普通的BFS的复杂度会到$O(N^2)$，而这题的N比较大，是撑不住的，注意到，选取点有很大的冗余——因为每个点最多只会被访问1次，那么如何选点的？考虑用一个set维护还没有被访问过的点，访问一个点，将这个点从set中删去。对于某个点开始，寻找set中的元素，如果可以访问，那么访问，同时删去。\n\n​\t注意到，这个时间复杂度只有$O((n+m)log n)$。\n\n\n\n##### [VK Cup 2016 - Round 1](http://codeforces.com/contest/639)\n\n> **CF639B：**构造一棵树，使得树有n个节点，直径是D，树高是H，不存在输出-1\n\n**构造**\n\n显然，D>2*H无解。否则，考虑先把直径画好。\n\n​\t直径分为两部分，两部分分别画好，然后再把剩下的点弄到1号那里\n\n​\tD=H要特殊处理。\n\n> **CF639C：**定义一个合法的n次多项式f(x)，满足最高项系数an!=0，所有系数ai都是整数，且绝对值不超过K。\t现在给您一个合法的n次多项式P(x)，但P(2)!=0。您需要改变其中一个系数，仍然得到一个n次多项式Q(x)。满足Q(2)=0。求方案数。$n<=200000$\n\n**多项式**\n\n​\t考虑把系数转化成二进制，除了最高位。\n\n​\t那么要使得可以消掉，必然是满足当前的系数左边没有1或者-1。\n\n​\t那么考虑把系数转化成二进制后，倒着把系数推回来，得到右边一段的系数相当于是多少，记为sum\n\n​\tsum的求值可以每次 * 2+当前元素得到。那么如果i左边的系数（小的系数）满足都是0，那么我们知道，当前这个Q的值显然就是$sum * 2^i$。所以只要把这一位的系数减去这个sum，就能保证整个$Q(2) = 0$。\n\n​\t因此，我们只需要先正着扫一遍，得到最低的非0位的位置。\n\n​\t然后倒着扫一遍，得到sum，并统计。\n\n​\t注意的是，当sum>2*k的时候，已经没有必要继续统计了。\n\n> **CF639D：**有n个人，每个人都有自己的贡献ti（任意整数）可以花费b，使得某个人的贡献+5,花费c，使得某个人的贡献+1.求至少使得k个人的贡献相等，最少需要的花费。$k<=n<=200000,$$1<=b,c<=1000$ $|t_i|<=1e9$\n\n**优先队列维护前k小的数的和**\n\n​\t考虑首先对于输入的数排序。同时如果$b=min(b,c\\times 5)$，那么得到所有可能最后的相同的那个数（一定不会超过某个数+0,1,2,3,4,5这个范围），然后考虑枚举所有的Ans，下一步的操作是要在所有数中寻找满足条件的最小花费的k个数。\n可以把花费看作一些数，先变成对应的mod 5=r的数，然后再一直加上b。考虑到我们已经排序了，所以这个右指针（哪些是包含的）是会单调递增的。\n设x mod 5 = r;考虑预处理出每一个数到mod 5 = r的数值为t[i,r]，那么最后的最小花费必然是选出一些i，使得$min(∑(t[i,r] - a[i]) \\times c + ∑(x - t[i,r]) / 5 \\times b)$，考虑到x[i]和t[i,r]的余数是一样的，可以化简为\n\n$$\\large k \\times （x / 5 \\times b）   +   \\sum _{i}^{t[i,r]<=x}(t[i,r] \\times c - a[i] \\times c - t[i,r] / 5 \\times b)$$\n\n考虑维护5个堆，得到这5个堆中元素和，压入一个元素，加上这个sum，如果元素个数超过k，将大的弹出来，减去这个sum。\n\n##### [Codeforces Round #347 (Div. 1)](http://codeforces.com/contest/663)\n\n>**CF663A:**给定一些类似?+?-?=n表达式，然后知道最后一个数字为n（给定），然后在前面填（1~n)的数，问可不可能有满足条件的等式，可能输出Possible并给出一组解。\n\n**脑洞**(2A)\n\n​\t考虑对于使得表达式最小的式子，加是+1，减是-n，再考虑使得表达式最大的式子，加是+n，减是-1，那么如果n在两者之间，这个式子一定可以通过一定的改变得到，否则就是不行。\n\n​\t为了实现简单，只要统计加法有多少，减法有多少就可以得到了。构造主要可以这样实现，对于每一个位置，找到一个最小的使得后面依旧可以填的(这个值不会很大)。这样好实现很多。然后n去掉这个值，继续处理。虽然可以二分，但是麻烦。注意如果你是改变n的，记得保存一个n的镜像。\n\n>**CF663B:**给出了一个数字的后缀，要求最终这个数字大于等于1989，并且在最小的情况下，这个数字之前没有被占用过。求最终拼凑的数字。\n\n不会QAQ\n\n> **CF663C:**有一个n个点，m条边的无向图，一开始，每条边的颜色都是给定的，然后玩家选择一个顶点，把相邻的边的颜色反转一下，问使得所有边颜色相同最少反转几下，输出那些反转的顶点，不可以输出-1.$(1 ≤ n, m ≤ 100 000)$\n\n**并查集**(6A)\n\n​\t不失一般性，考虑把所有边的颜色变成红色，那么可以把整个图分成不同的联通块，每个联通块分别处理。如果有一条边是蓝色的，说明这条边的左右两端的状态是不同的，如果是红色的，说明状态是相同的。对于一个联通块，显然只有2类。那么我们只需要在2类中取较小的一类即可。\n\n​\t考虑用2个并查集，分别维护相同类和不同类。\n\n> **CF663D:**\n\n不会QAQ\n\n\n\n> **CF663E:**有一个n*m的表格，包含0或1.每一次可以选择一行，或一列翻转(0<->1)。求一些操作后，1的个数的最小值。$n<=20, m<=100000 $\n\n**FWT优化**(4A)\n\n​\t很容易想到一个暴力，是枚举行变化$O(2^n)$，然后贪心验证$O(n*m)$，然后利用位运算，可以通过预处理先得到$v_i$表示$i$，或者$i$的翻转包含的最少的1的个数($i$是一状压二进制)，$v_i = min(|i|,n-|i|)$，那么设某一列状压之后是$A_i$，当前枚举到行变化是$s$，那么如果用$Ans[s]$表示在s状态能够获得的最大$Ans$，用$cnt[i]$表示所有列中$i$出现了几次可以得到，\n\n$$\\large Ans[s] =\\sum_{i=0}^{2^n-1} v_{s⊕i} * cnt_i$$ ————然后，上面这个式子是可以通过FWT优化的，因为这个等价于存在两个向量$cnt$和$v$，然后要求它们的亦或卷积得到的另一个向量。\n\n$$\\large Ans[s] = \\sum_{j⊕k =i}cnt_j*v_k$$\n\n因此，跑一个\n\n$$FWT(A) = (FWT(A0)+FWT(A1),FWT(A0)-FWT(A1))$$\n\n$$IFWT(A)=IFWT((A0+A1) \\div2,(A0-A1)\\div2)$$\n\n最后来一个统计就有结果了——虽然我也不知道怎么构造，我也不知道怎么证明。","link":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"USACO5.4","date":"2017-08-18T08:43:25.000Z","path":"2017/08/18/USACO/5/USACO5.4/USACO5-4/","text":"[TOC] USACO5.4.1题意给定一个图，问一条从起点到终点，再从终点到起点，除了起点和终点外，不能经过重复节点的路劲，这条路劲最长有多长。（节点&lt;=100) 而且，是东西方向的，所以不存在类似1–&gt;3–&gt;2–&gt;4的，只有1–&gt;2–&gt;3–&gt;4的。 原题USACO5.4.1-Canada Tour Canada Tour You have won a contest sponsored by an airline. The prize is a ticket to travel around Canada, beginning in the most western point served by this airline, then traveling only from west to east until you reach the most eastern point served, and then coming back only from east to west until you reach the starting city. No city may be visited more than once, except for the starting city, which must be visited exactly twice (at the beginning and the end of the trip). You are not allowed to use any other airline or any other means of transportation. Given a list of cities served by the airline and a list of direct flights between pairs of cities, find an itinerary which visits as many cities as possible and satisfies the above conditions beginning with the first city and visiting the last city on the list and returning to the first city. PROGRAM NAME: tour INPUT FORMAT Line 1: The number N of cities served by the airline and the number V of direct flights that will be listed. N will be a positive integer not larger than 100. V is any positive integer. Lines 2..N+1: Each line contains a name of a city served by the airline. The names are ordered from west to east in the input file. There are no two cities in the same meridian. The name of each city is a string of, at most, 15 digits and/or characters of the Latin alphabet; there are no spaces in the name of a city. Lines N+2..N+2+V-1: Each line contains two names of cities (taken from the supplied list), separated by a single blank space. This pair is connected by a direct, two-way airline flight. SAMPLE INPUT (file tour.in) 8 9VancouverYellowknifeEdmontonCalgaryWinnipegTorontoMontrealHalifaxVancouver EdmontonVancouver CalgaryCalgary WinnipegWinnipeg TorontoToronto HalifaxMontreal HalifaxEdmonton MontrealEdmonton YellowknifeEdmonton Calgary OUTPUT FORMAT Line 1: The number M of different cities visited in the optimal itinerary. Output 1 if no itinerary is possible. SAMPLE OUTPUT (file tour.out) 7 Namely: Vancouver, Edmonton, Montreal, Halifax, Toronto, Winnipeg, Calgary, and Vancouver (but that’s not a different city). 做法这是一个无向图——至于字符串可以用Map来解决。 那么不能经过重复节点的，要到终点的2条路。 考虑用$f[i,j]$表示2条路劲，其中一条到了i，第二条到了j最多经过的城市 考虑对于一个城市k$$f[i,j] = max(f[i,k] + 1，f[k,j]+1);$$如果j到k右边，那么左边的是可行的，如果k到j有边，那么k到j是有边的 这样是不会重复的。 可以用归纳法解决，如果f[i,k]或者f[k,j]没有重复，那么加上只有一个城市到了j，所以也是不会有重复的。 把f函数改改 可以得到这些： ​ 1、$f[i,j] = f[j,i]$ 因此只要考虑把第二个k改变即可。 $f[i,j] = max(f[i,k] + 1)$ 百度到的做法Orz 相当于（除了1和n）每个点内部有容量为1，费用为1的边，外部是容量为1费用为0的边。跑最大费用最大流$Orz$ 好了，不管下面的做法。 给出DP代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*ID:cqz15311LANG:C++PROG:tour*/#include&lt;bits/stdc++.h&gt; using namespace std;string a,b;map&lt;string,int&gt; Name; const int inf = 0x3fffffff;bool g[105][105];int f[105][105],n,m,ans;char s[105],t[105];int main()&#123; freopen(\"tour.in\",\"r\",stdin); freopen(\"tour.out\",\"w\",stdout); cin &gt;&gt; n &gt;&gt; m; for (int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; s; Name[s] = i; &#125; memset(g,false,sizeof(g)); for (int i=1;i&lt;=m;i++)&#123; cin &gt;&gt; s &gt;&gt; t; g[Name[s]][Name[t]] = true; g[Name[t]][Name[s]] = true; &#125; f[1][1] = 1; for (int i=1;i&lt;=n;i++)&#123; for (int j=i+1;j&lt;=n;j++)&#123; f[i][j] = -inf; for (int k=1;k&lt;j;k++) if (g[k][j] &amp;&amp; f[i][k]&gt;0 &amp;&amp; f[i][k]&gt;f[i][j]) f[i][j] = f[i][k]; f[j][i] = ++f[i][j];// printf(\"%d %d:%d\\n\",i,j,f[i][j]); &#125; &#125; ans = 1; for (int i=1;i&lt;=n;i++) if (g[i][n] &amp;&amp; f[i][n] &gt; ans) ans = f[i][n]; cout &lt;&lt; ans &lt;&lt; endl; fclose(stdin); fclose(stdout); return 0;&#125;/*Executing... Test 1: TEST OK [0.000 secs, 4236 KB] Test 2: TEST OK [0.000 secs, 4236 KB] Test 3: TEST OK [0.000 secs, 4236 KB] Test 4: TEST OK [0.000 secs, 4236 KB] Test 5: TEST OK [0.000 secs, 4236 KB] Test 6: TEST OK [0.000 secs, 4236 KB] Test 7: TEST OK [0.000 secs, 4236 KB] Test 8: TEST OK [0.000 secs, 4236 KB] Test 9: TEST OK [0.000 secs, 4236 KB] Test 10: TEST OK [0.000 secs, 4236 KB] Test 11: TEST OK [0.000 secs, 4236 KB]All tests OK.YOUR PROGRAM ('tour') WORKED FIRST TIME! That's fantastic-- and a rare thing. Please accept these special automatedcongratulations.*/ USACO5.4.2题意原题做法USACO5.4.3题意给定一个无向图，问字典序最小的最小点割集。 原题USACO5.4.3 - Telecowmunication Telecowmunication Farmer John’s cows like to keep in touch via email so they have created a network of cowputers so that they can intercowmunicate. These machines route email so that if there exists a sequence of c cowputers a1, a2, …, a(c) such that a1 is connected to a2, a2 is connected to a3, and so on then a1 and a(c) can send email to one another. Unfortunately, a cow will occasionally step on a cowputer or Farmer John will drive over it, and the machine will stop working. This means that the cowputer can no longer route email, so connections to and from that cowputer are no longer usable. Two cows are pondering the minimum number of these accidents that can occur before they can no longer use their two favorite cowputers to send email to each other. Write a program to calculate this minimal value for them, and to calculate a set of machines that corresponds to this minimum. For example the network: 123 1 / 3 - 2 shows 3 cowputers connected with 2 lines. We want to send messages between cowputers 1 and 2. Direct lines connect 1-3 and 2-3. If cowputer 3 is down, them there is no way to get a message from 1 to 2. PROGRAM NAME: telecow INPUT FORMAT Line 1 Four space-separated integers: N, M, c1, and c2. N is the number of computers (1 &lt;= N &lt;= 100), which are numbered 1..N. M is the number of connections between pairs of cowputers (1 &lt;= M &lt;= 600). The last two numbers, c1 and c2, are the id numbers of the cowputers that the communicating cows are using. Each connection is unique and bidirectional (if c1 is connected to c2, then c2 is connected to c1). There can be at most one wire between any two given cowputers. Computers c1 and c2 will not have a direct connection. Lines 2..M+1 The subsequent M lines contain pairs of cowputers id numbers that have connections between them. SAMPLE INPUT (file telecow.in) 1233 2 1 21 32 3 OUTPUT FORMAT Generate two lines of output. The first line is the minimum number of (well-chosen) cowputers that can be down before terminals c1 &amp; c2 are no longer connected. The second line is a minimal-length sorted list of cowputers that will cause c1 &amp; c2 to no longer be connected. Note that neither c1 nor c2 can go down. In case of ties, the program should output the set of computers that, if interpreted as a base N number, is the smallest one. SAMPLE OUTPUT (file telecow.out) 1213 做法考虑把每个点拆成2份，中间连一条边，权值为1. 当然，1号点和n号点权值无穷大 对于外面的边，权值为无穷大。 然后跑最小割（SAP）。","raw":"---\ntitle: USACO5.4\ndate: 2017-08-18 16:43:25\ntags:\n - USACO\n - DP\n - 网络流\n---\n\n[TOC]\n\n<!--more-->\n\n# USACO5.4.1\n\n### 题意\n\n给定一个图，问一条从起点到终点，再从终点到起点，除了起点和终点外，不能经过重复节点的路劲，这条路劲最长有多长。（节点<=100)\n\n而且，是东西方向的，所以不存在类似1-->3-->2-->4的，只有1-->2-->3-->4的。\n\n### 原题\n\nUSACO5.4.1-**Canada Tour**\n\n**Canada Tour**\n\nYou have won a contest sponsored by an airline. The prize is a ticket to travel around Canada, beginning in the most western point served by this airline, then traveling only from west to east until you reach the most eastern point served, and then coming back only from east to west until you reach the starting city. No city may be visited more than once, except for the starting city, which must be visited exactly twice (at the beginning and the end of the trip). You are not allowed to use any other airline or any other means of transportation.\n\nGiven a list of cities served by the airline and a list of direct flights between pairs of cities, find an itinerary which visits as many cities as possible and satisfies the above conditions beginning with the first city and visiting the last city on the list and returning to the first city.\n\nPROGRAM NAME: tour\n\nINPUT FORMAT\n\n| Line 1:             | The number N of cities served by the airline and the number V of direct flights that will be listed. N will be a positive integer not larger than 100. V is any positive integer. |\n| ------------------- | ---------------------------------------- |\n| Lines 2..N+1:       | Each line contains a name of a city served by the airline. The names are ordered from west to east in the input file. There are no two cities in the same meridian. The name of each city is a string of, at most, 15 digits and/or characters of the Latin alphabet; there are no spaces in the name of a city. |\n| Lines N+2..N+2+V-1: | Each line contains two names of cities (taken from the supplied list), separated by a single blank space. This pair is connected by a direct, two-way airline flight. |\n\nSAMPLE INPUT (file tour.in)\n\n8 9\t\nVancouver\t\t\nYellowknife\t\nEdmonton\nCalgary\nWinnipeg\nToronto\t\nMontreal\nHalifax\t\nVancouver Edmonton\nVancouver Calgary\t\nCalgary Winnipeg\nWinnipeg Toronto\nToronto Halifax\nMontreal Halifax\nEdmonton Montreal\nEdmonton Yellowknife\nEdmonton Calgary\n\nOUTPUT FORMAT\n\n| Line 1: | The number M of different cities visited in the optimal itinerary. Output 1 if no itinerary is possible. |\n| ------- | ---------------------------------------- |\n|         |                                          |\n\nSAMPLE OUTPUT (file tour.out)\n\n7\n\n\n\nNamely: Vancouver, Edmonton, Montreal, Halifax, Toronto, Winnipeg, Calgary, and Vancouver (but that's not a different city). \n\n### 做法\n\n这是一个无向图——至于字符串可以用Map来解决。\n\n那么不能经过重复节点的，要到终点的2条路。\n\n考虑用$f[i,j]$表示2条路劲，其中一条到了i，第二条到了j最多经过的城市\n\n考虑对于一个城市k\n$$\nf[i,j] = max(f[i,k] + 1，f[k,j]+1);\n$$\n如果j到k右边，那么左边的是可行的，如果k到j有边，那么k到j是有边的\n\n这样是不会重复的。\n\n可以用归纳法解决，如果f[i,k]或者f[k,j]没有重复，那么加上只有一个城市到了j，所以也是不会有重复的。\n\n把f函数改改\n\n可以得到这些：\n\n​\t1、$f[i,j] = f[j,i]$\n\n因此只要考虑把第二个k改变即可。\n\n$f[i,j] = max(f[i,k] + 1)$\n\n**百度到的做法Orz**\n\n相当于（除了1和n）每个点内部有容量为1，费用为1的边，外部是容量为1费用为0的边。跑最大费用最大流$Orz$\n\n好了，不管下面的做法。\n\n给出DP代码\n\n\n\n```cpp\n/*\nID:cqz15311\nLANG:C++\nPROG:tour\n*/\n#include<bits/stdc++.h> \nusing namespace std;\nstring a,b;\nmap<string,int> Name; \nconst int inf = 0x3fffffff;\nbool g[105][105];\nint f[105][105],n,m,ans;\nchar s[105],t[105];\nint main(){\n\tfreopen(\"tour.in\",\"r\",stdin);\n\tfreopen(\"tour.out\",\"w\",stdout);\n\tcin >> n >> m;\n\tfor (int i=1;i<=n;i++){\n\t\tcin >> s;\n\t\tName[s] = i;\n\t}\n\tmemset(g,false,sizeof(g));\n\tfor (int i=1;i<=m;i++){\n\t\tcin >> s >> t;\n\t\tg[Name[s]][Name[t]] = true;\n\t\tg[Name[t]][Name[s]] = true;\n\t}\n\tf[1][1] = 1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=i+1;j<=n;j++){\n\t\t\tf[i][j] = -inf;\n\t\t\tfor (int k=1;k<j;k++)\n\t\t\t\tif (g[k][j] && f[i][k]>0 && f[i][k]>f[i][j])\n\t\t\t\t\tf[i][j] = f[i][k];\n\t\t\tf[j][i] = ++f[i][j];\n//\t\t\tprintf(\"%d %d:%d\\n\",i,j,f[i][j]);\n\t\t}\n\t}\n\tans = 1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (g[i][n] && f[i][n] > ans) ans = f[i][n];\n\tcout << ans << endl;\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n/*\nExecuting...\n   Test 1: TEST OK [0.000 secs, 4236 KB]\n   Test 2: TEST OK [0.000 secs, 4236 KB]\n   Test 3: TEST OK [0.000 secs, 4236 KB]\n   Test 4: TEST OK [0.000 secs, 4236 KB]\n   Test 5: TEST OK [0.000 secs, 4236 KB]\n   Test 6: TEST OK [0.000 secs, 4236 KB]\n   Test 7: TEST OK [0.000 secs, 4236 KB]\n   Test 8: TEST OK [0.000 secs, 4236 KB]\n   Test 9: TEST OK [0.000 secs, 4236 KB]\n   Test 10: TEST OK [0.000 secs, 4236 KB]\n   Test 11: TEST OK [0.000 secs, 4236 KB]\n\nAll tests OK.\nYOUR PROGRAM ('tour') WORKED FIRST TIME!  That's fantastic\n-- and a rare thing.  Please accept these special automated\ncongratulations.\n*/\n```\n\n# USACO5.4.2\n\n### 题意\n\n### 原题\n\n### 做法\n\n# USACO5.4.3\n\n### 题意\n\n给定一个无向图，问字典序最小的最小点割集。\n\n### 原题\n\nUSACO5.4.3 - **Telecowmunication**\n\n**Telecowmunication**\n\nFarmer John's cows like to keep in touch via email so they have created a network of cowputers so that they can intercowmunicate. These machines route email so that if there exists a sequence of c cowputers a1, a2, ..., a(c) such that a1 is connected to a2, a2 is connected to a3, and so on then a1 and a(c) can send email to one another.\n\nUnfortunately, a cow will occasionally step on a cowputer or Farmer John will drive over it, and the machine will stop working. This means that the cowputer can no longer route email, so connections to and from that cowputer are no longer usable.\n\nTwo cows are pondering the minimum number of these accidents that can occur before they can no longer use their two favorite cowputers to send email to each other. Write a program to calculate this minimal value for them, and to calculate a set of machines that corresponds to this minimum.\n\nFor example the network:\n\n```\n               1\n              /  \n             3 - 2\n\n```\n\nshows 3 cowputers connected with 2 lines. We want to send messages between cowputers 1 and 2. Direct lines connect 1-3 and 2-3. If cowputer 3 is down, them there is no way to get a message from 1 to 2.\n\nPROGRAM NAME: telecow\n\nINPUT FORMAT\n\n| Line 1       | Four space-separated integers: N, M, c1, and c2. N is the number of computers (1 <= N <= 100), which are numbered 1..N. M is the number of connections between pairs of cowputers (1 <= M <= 600). The last two numbers, c1 and c2, are the id numbers of the cowputers that the communicating cows are using. Each connection is unique and bidirectional (if c1 is connected to c2, then c2 is connected to c1). There can be at most one wire between any two given cowputers. Computers c1 and c2 will not have a direct connection. |\n| ------------ | ---------------------------------------- |\n| Lines 2..M+1 | The subsequent M lines contain pairs of cowputers id numbers that have connections between them. |\n\nSAMPLE INPUT (file telecow.in)\n\n```\n3 2 1 2\n1 3\n2 3\n```\n\nOUTPUT FORMAT\n\nGenerate two lines of output. The first line is the minimum number of (well-chosen) cowputers that can be down before terminals c1 & c2 are no longer connected. The second line is a minimal-length sorted list of cowputers that will cause c1 & c2 to no longer be connected. Note that neither c1 nor c2 can go down. In case of ties, the program should output the set of computers that, if interpreted as a base N number, is the smallest one.\n\nSAMPLE OUTPUT (file telecow.out)\n\n```\n1\n3\n```\n\n### 做法\n\n考虑把每个点拆成2份，中间连一条边，权值为1.\n\n当然，1号点和n号点权值无穷大\n\n对于外面的边，权值为无穷大。\n\n然后跑最小割（SAP）。\n\n","link":"","tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO5.4.2","date":"2017-08-18T06:20:20.000Z","path":"2017/08/18/USACO/5/USACO5.4/USACO5.4.2/USACO5-4-2/","text":"题意图像识别：给定_,a,b,……z的完整图像，然后给出一个破损的图像 每个完整字符长 20 行。 输入文件包含一个或多个可能损坏的字符图案。一个字符图案可能以这些方式被损坏。 最多有一行可能被复制了（就接在原来那一行的下面） 最多有一行可能丢失了 有些“0”可能被改成“1” 有些“1”可能被改成“0” 不会有任何一个字符图案既多余了一行并且又丢失了一行。在测试数据的任何一个字符图案中，“0”和“1”的被改变率不超过 30%。 原题USACO5.4.2-Character Recognition 给出输入问题http://train.usaco.org/usaco/font.in 做法一脸懵逼Orz 第一次接触到类似的题目Orz 可不可以枚举每一个答案 然后枚举是哪一行删除，哪一行复制，然后计算匹配率QAQ 这样的话 复杂度是$O(2727272020)$……好像不会超 可是怎么根据匹配率搞？","raw":"---\ntitle: USACO5.4.2\ndate: 2017-08-18 14:20:20\ntags:\n - USACO\n---\n\n# 题意\n\n图像识别：给定_,a,b,……z的完整图像，然后给出一个破损的图像\n\n每个完整字符长 20 行。\n\n输入文件包含一个或多个可能损坏的字符图案。一个字符图案可能以这些方式被损坏。\n\n- 最多有一行可能被复制了（就接在原来那一行的下面）\n- 最多有一行可能丢失了\n- 有些“0”可能被改成“1”\n- 有些“1”可能被改成“0”\n\n不会有任何一个字符图案既多余了一行**并且**又丢失了一行。在测试数据的任何一个字符图案中，“0”和“1”的被改变率不超过 30%。\n\n# 原题\n\nUSACO5.4.2-**Character Recognition**\n\n给出输入问题http://train.usaco.org/usaco/font.in\n\n# 做法\n\n一脸懵逼Orz\n\n第一次接触到类似的题目Orz\n\n可不可以枚举每一个答案\n\n然后枚举是哪一行删除，哪一行复制，然后计算匹配率QAQ\n\n这样的话\n\n复杂度是$O(27*27*27*20*20)$……好像不会超\n\n可是怎么根据匹配率搞？\n\n\n\n","link":"","tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO5.3","date":"2017-08-17T04:41:43.000Z","path":"2017/08/17/USACO/5/USACO5.3/USACO5.3/","text":"[TOC] USACO5.3.2window你刚刚接手一项窗体界面工程。窗体界面还算简单，而且幸运的是，你不必显示实际的窗体。有 5 种基本操作： 创建一个新窗体 将窗体置顶 将窗体置底 删除一个窗体 输出窗体可见部分的百分比（就是，不被其它窗体覆盖的部分）。 原题USACO5.3.2-Window 做法这题采用模拟大法 如何模拟 我们可以用一个链表存储QAQ。 保存底窗体，顶窗体。 同时保存前面的那个窗体，后面的那个窗体。 支持这些操作。 1、Remove 删除其中一个窗体 1234567void remove(int x)&#123; if (x == -1) return; if (x != tail) pre[nxt[x]] = pre[x]; if (x != head) nxt[pre[x]] = nxt[x]; if (x == tail) tail = pre[x]; if (x == head) head = nxt[x];&#125; 2、Addhead 在头加上一个窗体（用于置底操作） 1234567void Addhead(int x)&#123; pre[x] = -1; nxt[x] = head; if (head!=-1) pre[head] = x; head = x; if (tail==-1) tail = x;&#125; 3、Addtail 在尾部加上一个窗体（用于置顶操作） 1234567void Addtail(int x)&#123; nxt[x] = -1; pre[x] = tail; if (tail!=-1) nxt[tail] = x; tail = x; if (head==-1) head = x;&#125; ★顺着next指针寻找，利用漂浮法，矩阵切割，从而得到可以见到的面积。 12345678910111213141516171819202122int dfs(int l,int r,int u,int d,int n)&#123; while ((n != -1) &amp;&amp; ((l &gt;= R[n]) || (r &lt;= L[n]) || (u &gt;= D[n]) || (d &lt;= U[n]))) n = nxt[n]; if (n == -1) return (r-l) * (d-u); int rec = 0; if (l &lt; L[n])&#123; rec += dfs(l,L[n],u,d,nxt[n]); l = L[n]; &#125; if (r &gt; R[n])&#123; rec += dfs(R[n],r,u,d,nxt[n]); r = R[n]; &#125; if (u &lt; U[n])&#123; rec += dfs(l,r,u,U[n],nxt[n]); u = U[n]; &#125; if (d &gt; D[n])&#123; rec += dfs(l,r,D[n],d,nxt[n]); d = D[n]; &#125; return rec;&#125; USACO5.3.3题意给定一个有向图，然后在一些点上立flag，这些flag可以通过有向边传递 1、问使得所有点都被弄上flag最少要立多少flag 2、问最少加多少边使得这个图强连通 原题USACO5.3.3-schlnet 做法很显然的做法 先强连通分量缩点，缩完点后，求有多少个没有入度，那么就是结果1 第二问显然就是没有出度的分量和没有入度的分量之中取一个较大的。 注意只有一个强连通分量的特判QAQ 1A USACO5.3.4题意一个N N的矩阵中有T个点有树，(xi,yi)有一棵树，然后在NN的范围内，问最大的没有树的正方形的边长是多少。(N&lt;=1000,T&lt;=10000) 原题USACO5.3.4-bigbrn Big BarnA Special TreatFarmer John wants to place a big square barn on his square farm. He hates to cut down trees on his farm and wants to find a location for his barn that enables him to build it only on land that is already clear of trees. For our purposes, his land is divided into N x N parcels. The input contains a list of parcels that contain trees. Your job is to determine and report the largest possible square barn that can be placed on his land without having to clear away trees. The barn sides must be parallel to the horizontal or vertical axis. EXAMPLE Consider the following grid of Farmer John’s land where .&#39; represents a parcel with no trees and#’ represents a parcel with trees: 123456789 1 2 3 4 5 6 7 81 . . . . . . . .2 . # . . . # . .3 . . . . . . . .4 . . . . . . . .5 . . . . . . . .6 . . # . . . . .7 . . . . . . . .8 . . . . . . . . The largest barn is 5 x 5 and can be placed in either of two locations in the lower right part of the grid. PROGRAM NAME: bigbrn INPUT FORMAT Line 1: Two integers: N (1 &lt;= N &lt;= 1000), the number of parcels on a side, and T (1 &lt;= T &lt;= 10,000) the number of parcels with treesLines 2..T+1: Two integers (1 &lt;= each integer &lt;= N), the row and column of a tree parcelSAMPLE INPUT (file bigbrn.in) 8 32 22 66 3OUTPUT FORMAT The output file should consist of exactly one line, the maximum side length of John’s barn. SAMPLE OUTPUT (file bigbrn.out) 5 做法考虑枚举每一个点作为右下角的点，然后看能往左上角扩展多少。 考虑用f[i,j]表示第i行，第j列的答案 如果(i,j)是’#’，那么f[i,j] = 0 否则 f[i,j] = min( f[i,j-1],f[i-1,j],f[i-1,j-1]) + 1 为什么是这样的呢？ 首先f[i-1,j-1]是比较好理解的 假设f[i-1,j-1] = x 那么还需要横着和竖着的两条都是x得到。 那么好理解了吧QAQ","raw":"---\ntitle: USACO5.3\ndate: 2017-08-17 12:41:43\ntags:\n - USACO\n---\n\n[TOC]\n\n<!--more-->\n\n# USACO5.3.2\n\n### window\n\n你刚刚接手一项窗体界面工程。窗体界面还算简单，而且幸运的是，你不必显示实际的窗体。有 5 种基本操作：\n\n1. 创建一个新窗体\n2. 将窗体置顶\n3. 将窗体置底\n4. 删除一个窗体\n5. 输出窗体可见部分的百分比（就是，不被其它窗体覆盖的部分）。\n\n<!--more-->\n\n### 原题\n\nUSACO5.3.2-Window\n\n### 做法\n\n这题采用模拟大法\n\n如何模拟\n\n我们可以用一个链表存储QAQ。\n\n保存底窗体，顶窗体。\n\n同时保存前面的那个窗体，后面的那个窗体。\n\n支持这些操作。\n\n1、Remove\n\n删除其中一个窗体\n\n```cpp\nvoid remove(int x){\n\tif (x == -1) return;\n\tif (x != tail) pre[nxt[x]] = pre[x];\n\tif (x != head) nxt[pre[x]] = nxt[x];\n\tif (x == tail) tail = pre[x];\n\tif (x == head) head = nxt[x];\n}\n```\n\n2、Addhead\n\n在头加上一个窗体（用于置底操作）\n\n```cpp\nvoid Addhead(int x){\n\tpre[x] = -1;\n\tnxt[x] = head;\n\tif (head!=-1) pre[head] = x;\n\thead = x;\n\tif (tail==-1) tail = x;\n}\n```\n\n3、Addtail\n\n在尾部加上一个窗体（用于置顶操作）\n\n```cpp\nvoid Addtail(int x){\n\tnxt[x] = -1;\n\tpre[x] = tail;\n\tif (tail!=-1) nxt[tail] = x;\n\ttail = x;\n\tif (head==-1) head = x;\n}\n```\n\n★顺着next指针寻找，利用漂浮法，矩阵切割，从而得到可以见到的面积。\n\n```cpp\nint dfs(int l,int r,int u,int d,int n){\n\twhile ((n != -1) && ((l >= R[n]) || (r <= L[n]) || (u >= D[n]) || (d <= U[n]))) n = nxt[n];\n\tif (n == -1) return (r-l) * (d-u);\n\tint rec = 0;\n\tif (l < L[n]){\n\t\trec += dfs(l,L[n],u,d,nxt[n]);\n\t\tl = L[n];\n\t}\n\tif (r > R[n]){\n\t\trec += dfs(R[n],r,u,d,nxt[n]);\n\t\tr = R[n];\n\t}\n\tif (u < U[n]){\n\t\trec += dfs(l,r,u,U[n],nxt[n]);\n\t\tu = U[n];\n\t}\n\tif (d > D[n]){\n\t\trec += dfs(l,r,D[n],d,nxt[n]);\n\t\td = D[n];\n\t}\n\treturn rec;\n}\n```\n\n----\n\n# USACO5.3.3\n\n### 题意\n\n给定一个有向图，然后在一些点上立flag，这些flag可以通过有向边传递\n\n1、问使得所有点都被弄上flag最少要立多少flag\n\n2、问最少加多少边使得这个图强连通\n\n<!--more-->\n\n### 原题\n\nUSACO5.3.3-schlnet\n\n### 做法\n\n**很显然的做法**\n\n先**强连通分量**缩点，缩完点后，求有多少个没有入度，那么就是结果1\n\n第二问显然就是没有出度的分量和没有入度的分量之中取一个较大的。\n\n注意只有一个强连通分量的特判QAQ\n\n> 1A\n\n----\n\n# USACO5.3.4\n\n### 题意\n\n一个N* N的矩阵中有T个点有树，(xi,yi)有一棵树，然后在N*N的范围内，问最大的没有树的正方形的边长是多少。(N<=1000,T<=10000)\n\n### 原题\n\n**USACO5.3.4-bigbrn**\n\n**Big Barn**\nA Special Treat\nFarmer John wants to place a big square barn on his square farm. He hates to cut down trees on his farm and wants to find a location for his barn that enables him to build it only on land that is already clear of trees. For our purposes, his land is divided into N x N parcels. The input contains a list of parcels that contain trees. Your job is to determine and report the largest possible square barn that can be placed on his land without having to clear away trees. The barn sides must be parallel to the horizontal or vertical axis.\n\n**EXAMPLE**\n\nConsider the following grid of Farmer John's land where `.' represents a parcel with no trees and `#' represents a parcel with trees:\n\n```\n      1 2 3 4 5 6 7 8\n    1 . . . . . . . .\n    2 . # . . . # . .\n    3 . . . . . . . .\n    4 . . . . . . . .\n    5 . . . . . . . .\n    6 . . # . . . . .\n    7 . . . . . . . .\n    8 . . . . . . . .\n```\n\nThe largest barn is 5 x 5 and can be placed in either of two locations in the lower right part of the grid.\n\nPROGRAM NAME: bigbrn\n\nINPUT FORMAT\n\nLine 1:\tTwo integers: N (1 <= N <= 1000), the number of parcels on a side, and T (1 <= T <= 10,000) the number of parcels with trees\nLines 2..T+1:\tTwo integers (1 <= each integer <= N), the row and column of a tree parcel\nSAMPLE INPUT (file bigbrn.in)\n\n8 3\n2 2\n2 6\n6 3\nOUTPUT FORMAT\n\nThe output file should consist of exactly one line, the maximum side length of John's barn.\n\nSAMPLE OUTPUT (file bigbrn.out)\n\n5\n\n### 做法\n\n**考虑枚举每一个点作为右下角的点，然后看能往左上角扩展多少。**\n\n**考虑用f[i,j]表示第i行，第j列的答案**\n\n**如果(i,j)是'#'，那么f[i,j] = 0**\n\n**否则**\n\n**f[i,j] = min( f[i,j-1],f[i-1,j],f[i-1,j-1]) + 1**\n\n**为什么是这样的呢？**\n\n**首先f[i-1,j-1]是比较好理解的**\n\n**假设f[i-1,j-1] = x**\n\n**那么还需要横着和竖着的两条都是x得到。**\n\n**那么好理解了吧QAQ**\n","link":"","tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"codeforces590D","date":"2017-08-15T02:14:18.000Z","path":"2017/08/15/Codeforces/590/codeforces590D/","text":"题意n个数，求最多相邻两两交换S次，使前K个数的和最小 原题http://codeforces.com/contest/590/problem/D 做法注意到，N*(N-1)/2&lt;=S的时候，S的大小已经没有什么用途了 考虑用dp[i,j,k]表示处理到前i个数字，其中已经交换了j次的，前k个已经确定的最小数字之和 考虑把第i个交换到第k个位置——或者不交换 不交换的话 dp[i,j,k] = dp[i-1,j,k] 交换的话 dp[i,j,k] = dp[i-1,j - (i-k) , k-1] + a[i] 用滚动数组优化一下 答案就是dp[N,X,K] (X&lt;=S) 20行代码 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 155;int dp[maxn*maxn][maxn],N,K,S,a[maxn],Ans;int main()&#123; memset(dp,0x3f,sizeof(dp)); dp[0][0] = 0; scanf(\"%d%d%d\",&amp;N,&amp;K,&amp;S); int Maxs = (N * (N-1)) / 2; for (int i=1;i&lt;=N;i++)&#123; scanf(\"%d\",&amp;a[i]); for (int j=Maxs;j&gt;=0;j--) for (int k=K;k&gt;=0;k--) if ((j - (i-k) &gt;= 0) &amp;&amp; (k-1 &gt;= 0)) dp[j][k] = min(dp[j][k],dp[j-(i-k)][k-1] + a[i]); &#125; Ans = 0x3fffffff; for (int i=0;i&lt;=min(S,Maxs);i++) Ans = min(Ans,dp[i][K]); printf(\"%d\\n\",Ans);&#125;","raw":"---\ntitle: codeforces590D\ndate: 2017-08-15 10:14:18\ntags:\n - codeforces \n - DP\n---\n\n# 题意\n\nn个数，求最多相邻两两交换S次，使前K个数的和最小\n\n<!--more-->\n\n# 原题\n\nhttp://codeforces.com/contest/590/problem/D\n\n# 做法\n\n注意到，N*(N-1)/2<=S的时候，S的大小已经没有什么用途了\n\n考虑用dp[i,j,k]表示处理到前i个数字，其中已经交换了j次的，前k个已经确定的最小数字之和\n\n考虑把第i个交换到第k个位置——或者不交换\n\n不交换的话\n\ndp[i,j,k] = dp[i-1,j,k]\n\n交换的话\n\ndp[i,j,k] = dp[i-1,j - (i-k) , k-1] + a[i]\n\n用滚动数组优化一下\n\n答案就是dp[N,X,K] (X<=S)\n\n20行代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 155;\nint dp[maxn*maxn][maxn],N,K,S,a[maxn],Ans;\nint main(){\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0] = 0;\n\tscanf(\"%d%d%d\",&N,&K,&S);\n\tint Maxs = (N * (N-1)) / 2;\n\tfor (int i=1;i<=N;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tfor (int j=Maxs;j>=0;j--)\n\t\t\tfor (int k=K;k>=0;k--)\n\t\t\t\tif ((j - (i-k) >= 0) && (k-1 >= 0))\n\t\t\t\t\tdp[j][k] = min(dp[j][k],dp[j-(i-k)][k-1] + a[i]);\n\t}\n\tAns = 0x3fffffff;\n\tfor (int i=0;i<=min(S,Maxs);i++) Ans = min(Ans,dp[i][K]);\n\tprintf(\"%d\\n\",Ans);\n}\n```\n\n","link":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}]},{"title":"codeforces590D","date":"2017-08-15T02:14:18.000Z","path":"2017/08/15/Codeforces/590/CF590D/codeforces590D/","text":"题意n个数，求最多相邻两两交换S次，使前K个数的和最小 原题http://codeforces.com/contest/590/problem/D 做法注意到，N*(N-1)/2&lt;=S的时候，S的大小已经没有什么用途了 考虑用dp[i,j,k]表示处理到前i个数字，其中已经交换了j次的，前k个已经确定的最小数字之和 考虑把第i个交换到第k个位置——或者不交换 不交换的话 dp[i,j,k] = dp[i-1,j,k] 交换的话 dp[i,j,k] = dp[i-1,j - (i-k) , k-1] + a[i] 用滚动数组优化一下 答案就是dp[N,X,K] (X&lt;=S) 20行代码 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 155;int dp[maxn*maxn][maxn],N,K,S,a[maxn],Ans;int main()&#123; memset(dp,0x3f,sizeof(dp)); dp[0][0] = 0; scanf(\"%d%d%d\",&amp;N,&amp;K,&amp;S); int Maxs = (N * (N-1)) / 2; for (int i=1;i&lt;=N;i++)&#123; scanf(\"%d\",&amp;a[i]); for (int j=Maxs;j&gt;=0;j--) for (int k=K;k&gt;=0;k--) if ((j - (i-k) &gt;= 0) &amp;&amp; (k-1 &gt;= 0)) dp[j][k] = min(dp[j][k],dp[j-(i-k)][k-1] + a[i]); &#125; Ans = 0x3fffffff; for (int i=0;i&lt;=min(S,Maxs);i++) Ans = min(Ans,dp[i][K]); printf(\"%d\\n\",Ans);&#125;","raw":"---\ntitle: codeforces590D\ndate: 2017-08-15 10:14:18\ntags:\n - codeforces \n - DP\n---\n\n# 题意\n\nn个数，求最多相邻两两交换S次，使前K个数的和最小\n\n<!--more-->\n\n# 原题\n\nhttp://codeforces.com/contest/590/problem/D\n\n# 做法\n\n注意到，N*(N-1)/2<=S的时候，S的大小已经没有什么用途了\n\n考虑用dp[i,j,k]表示处理到前i个数字，其中已经交换了j次的，前k个已经确定的最小数字之和\n\n考虑把第i个交换到第k个位置——或者不交换\n\n不交换的话\n\ndp[i,j,k] = dp[i-1,j,k]\n\n交换的话\n\ndp[i,j,k] = dp[i-1,j - (i-k) , k-1] + a[i]\n\n用滚动数组优化一下\n\n答案就是dp[N,X,K] (X<=S)\n\n20行代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 155;\nint dp[maxn*maxn][maxn],N,K,S,a[maxn],Ans;\nint main(){\n\tmemset(dp,0x3f,sizeof(dp));\n\tdp[0][0] = 0;\n\tscanf(\"%d%d%d\",&N,&K,&S);\n\tint Maxs = (N * (N-1)) / 2;\n\tfor (int i=1;i<=N;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tfor (int j=Maxs;j>=0;j--)\n\t\t\tfor (int k=K;k>=0;k--)\n\t\t\t\tif ((j - (i-k) >= 0) && (k-1 >= 0))\n\t\t\t\t\tdp[j][k] = min(dp[j][k],dp[j-(i-k)][k-1] + a[i]);\n\t}\n\tAns = 0x3fffffff;\n\tfor (int i=0;i<=min(S,Maxs);i++) Ans = min(Ans,dp[i][K]);\n\tprintf(\"%d\\n\",Ans);\n}\n```\n\n","link":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}]},{"title":"codeforces590B","date":"2017-08-15T01:59:36.000Z","path":"2017/08/15/Codeforces/590/codeforces590B/","text":"题意您要从(x1,y1)到(x2,y2)，一开始风速为(vx,vy)，t秒后(wx,wy)，您的速度不超过Vmax，求最少到终点的时间，保证风速小于您的速度，风速和您的速度都是向量 原题http://codeforces.com/problemset/problem/590/B 做法二分答案，然后假设人不动，判断是否可行。 这题不用多说 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;double T,V,X1,X2,Y1,Y2,X3,Y3,t,vx,vy,wx,wy;double L,R,mid;double dist(double a,double b,double c,double d)&#123; return sqrt((a-c) * (a-c) + (b-d) * (b-d));&#125;bool check(double T)&#123; if (T &lt;= t)&#123; X3 = X2 - T*vx; Y3 = Y2 - T*vy; return dist(X1,Y1,X3,Y3) &lt;= T*V; &#125; else&#123; X3 = X2 - t*vx - (T-t) * wx; Y3 = Y2 - t*vy - (T-t) * wy; return dist(X1,Y1,X3,Y3) &lt;= T*V; &#125; &#125;int main()&#123; scanf(\"%lf%lf%lf%lf\",&amp;X1,&amp;Y1,&amp;X2,&amp;Y2); scanf(\"%lf%lf%lf%lf%lf%lf\",&amp;V,&amp;t,&amp;vx,&amp;vy,&amp;wx,&amp;wy); L = 0;R = 1e10; while (R-L &gt; 1e-8)&#123; mid = (L+R) * 0.5; if(check(mid)) R = mid; else L = mid; &#125; printf(\"%lf\\n\",L);&#125; 本来可以1A的，没想到交错代码了……QAQ","raw":"---\ntitle: codeforces590B\ndate: 2017-08-15 09:59:36\ntags:\n - codeforces\n---\n\n# 题意\n\n您要从(x1,y1)到(x2,y2)，一开始风速为(vx,vy)，t秒后(wx,wy)，您的速度不超过Vmax，求最少到终点的时间，保证风速小于您的速度，风速和您的速度都是向量\n\n<!--more-->\n\n# 原题\n\nhttp://codeforces.com/problemset/problem/590/B\n\n# 做法\n\n二分答案，然后假设人不动，判断是否可行。\n\n这题不用多说\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ndouble T,V,X1,X2,Y1,Y2,X3,Y3,t,vx,vy,wx,wy;\ndouble L,R,mid;\ndouble dist(double a,double b,double c,double d){\n\treturn sqrt((a-c) * (a-c) + (b-d) * (b-d));\n}\nbool check(double T){\n\tif (T <= t){\n\t\tX3 = X2 - T*vx;\n\t\tY3 = Y2 - T*vy;\n\t\treturn dist(X1,Y1,X3,Y3) <= T*V;\n\t} else{\n\t\tX3 = X2 - t*vx - (T-t) * wx;\n\t\tY3 = Y2 - t*vy - (T-t) * wy;\n\t\treturn dist(X1,Y1,X3,Y3) <= T*V;\n\t} \n}\nint main(){\n\tscanf(\"%lf%lf%lf%lf\",&X1,&Y1,&X2,&Y2);\n\tscanf(\"%lf%lf%lf%lf%lf%lf\",&V,&t,&vx,&vy,&wx,&wy);\n\tL = 0;R = 1e10;\n\twhile (R-L > 1e-8){\n\t\tmid = (L+R) * 0.5;\n\t\tif(check(mid)) R = mid; else L = mid;\n\t}\n\tprintf(\"%lf\\n\",L);\n}\n```\n\n本来可以1A的，没想到交错代码了……QAQ","link":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"codeforces590B","date":"2017-08-15T01:59:36.000Z","path":"2017/08/15/Codeforces/590/CF590B/codeforces590B/","text":"题意您要从(x1,y1)到(x2,y2)，一开始风速为(vx,vy)，t秒后(wx,wy)，您的速度不超过Vmax，求最少到终点的时间，保证风速小于您的速度，风速和您的速度都是向量 原题http://codeforces.com/problemset/problem/590/B 做法二分答案，然后假设人不动，判断是否可行。 这题不用多说 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;double T,V,X1,X2,Y1,Y2,X3,Y3,t,vx,vy,wx,wy;double L,R,mid;double dist(double a,double b,double c,double d)&#123; return sqrt((a-c) * (a-c) + (b-d) * (b-d));&#125;bool check(double T)&#123; if (T &lt;= t)&#123; X3 = X2 - T*vx; Y3 = Y2 - T*vy; return dist(X1,Y1,X3,Y3) &lt;= T*V; &#125; else&#123; X3 = X2 - t*vx - (T-t) * wx; Y3 = Y2 - t*vy - (T-t) * wy; return dist(X1,Y1,X3,Y3) &lt;= T*V; &#125; &#125;int main()&#123; scanf(\"%lf%lf%lf%lf\",&amp;X1,&amp;Y1,&amp;X2,&amp;Y2); scanf(\"%lf%lf%lf%lf%lf%lf\",&amp;V,&amp;t,&amp;vx,&amp;vy,&amp;wx,&amp;wy); L = 0;R = 1e10; while (R-L &gt; 1e-8)&#123; mid = (L+R) * 0.5; if(check(mid)) R = mid; else L = mid; &#125; printf(\"%lf\\n\",L);&#125; 本来可以1A的，没想到交错代码了……QAQ","raw":"---\ntitle: codeforces590B\ndate: 2017-08-15 09:59:36\ntags:\n - codeforces\n---\n\n# 题意\n\n您要从(x1,y1)到(x2,y2)，一开始风速为(vx,vy)，t秒后(wx,wy)，您的速度不超过Vmax，求最少到终点的时间，保证风速小于您的速度，风速和您的速度都是向量\n\n<!--more-->\n\n# 原题\n\nhttp://codeforces.com/problemset/problem/590/B\n\n# 做法\n\n二分答案，然后假设人不动，判断是否可行。\n\n这题不用多说\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ndouble T,V,X1,X2,Y1,Y2,X3,Y3,t,vx,vy,wx,wy;\ndouble L,R,mid;\ndouble dist(double a,double b,double c,double d){\n\treturn sqrt((a-c) * (a-c) + (b-d) * (b-d));\n}\nbool check(double T){\n\tif (T <= t){\n\t\tX3 = X2 - T*vx;\n\t\tY3 = Y2 - T*vy;\n\t\treturn dist(X1,Y1,X3,Y3) <= T*V;\n\t} else{\n\t\tX3 = X2 - t*vx - (T-t) * wx;\n\t\tY3 = Y2 - t*vy - (T-t) * wy;\n\t\treturn dist(X1,Y1,X3,Y3) <= T*V;\n\t} \n}\nint main(){\n\tscanf(\"%lf%lf%lf%lf\",&X1,&Y1,&X2,&Y2);\n\tscanf(\"%lf%lf%lf%lf%lf%lf\",&V,&t,&vx,&vy,&wx,&wy);\n\tL = 0;R = 1e10;\n\twhile (R-L > 1e-8){\n\t\tmid = (L+R) * 0.5;\n\t\tif(check(mid)) R = mid; else L = mid;\n\t}\n\tprintf(\"%lf\\n\",L);\n}\n```\n\n本来可以1A的，没想到交错代码了……QAQ","link":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"codeforces590C","date":"2017-08-15T00:10:56.000Z","path":"2017/08/15/Codeforces/590/CF590C/codeforces590C/","text":"题意给定一个N*M的矩阵，这个矩阵里面有’1’,’2’,’3’,’.’,’#’,你可以把’.’改成桥，使得所有1,2,3四联通，问最少把多少个’.’改变，其中‘#’不能改变，如果不能输出-1。——其中’1’,’2’,’3’本身是连续的 原题http://codeforces.com/contest/590/problem/C Examplesinput 123454 511..2#..22#.323.#333 output 12 input 121 51#2#3 output 1-1 做法 Wrong 感觉这是个最小生成树问题 而且联通块个数还为3。那么考虑对于每一个国家，我们得到其它的点到它的最小距离—— 通过先把所有这个国家的点压入队列，然后跑一发BFS。 从而得到这个国家和剩下2个国家的最近距离。然后最小生成树然后就错了。 错误的原因：没有考虑桥可以公用的情况。 12311..22........3... May_right 先不考虑无解的情况 注意到，桥一定会在一个点交汇——这个点可能在某个国家里面，也可能在’.’位置。 我们可以考虑枚举这个交汇点的位置，然后把3个国家到这个点的Dis全部加起来，取Min就是结果 为什么是对的呢？这个不会有重复吗？会的。不过必然有一个点没有，那就是交汇点。 我们可以预处理出某一个国家到一个点路上最少经过的’.’的个数——我用循环入队一直T，后来改成优先队列做的——事实上还有更好的方法。 然后枚举每一个点，当然，如果这个点是’.’会被计算3次，要减去。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;struct Point&#123; int x,y,d; Point(int _x = 0,int _y = 0,int _d = 0)&#123; x = _x; y = _y; d = _d; &#125; bool operator &lt;(const Point &amp;x)const&#123; return d &gt; x.d; &#125;&#125;;priority_queue&lt;Point&gt; q;int front,rear;int dist[4][1005][1005];int Ans,n,m;int a[1005][1005];const int tx[4] = &#123;0,0,1,-1&#125;;const int ty[4] = &#123;1,-1,0,0&#125;;void Get(int c)&#123; int x,y,_x,_y,d,_d; memset(dist[c-'0'],-1,sizeof(dist[c - '0'])); front = rear = 0; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=m;j++)&#123; if (a[i][j] == c)&#123; dist[c-'0'][i][j] = 0; q.push(Point(i,j,0)); &#125; &#125; &#125; while (!q.empty())&#123; x = q.top().x; y = q.top().y; d = dist[c-'0'][x][y]; q.pop(); for (int t=0;t&lt;4;t++)&#123; _x = x + tx[t]; _y = y + ty[t]; if (a[_x][_y] == '#') continue; else if (a[_x][_y] == '.') _d = d + 1; else _d = d + 0; if (dist[c-'0'][_x][_y] == -1)&#123; dist[c-'0'][_x][_y] = _d; q.push(Point(_x,_y,_d)); &#125; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) a[i][0] = a[i][m+1] = '#'; for (int i=1;i&lt;=m;i++) a[0][i] = a[n+1][i] = '#'; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=m;j++)&#123; a[i][j] = getchar(); while((a[i][j]!='1')&amp;&amp;(a[i][j]!='2')&amp;&amp;(a[i][j]!='3')&amp;&amp;(a[i][j]!='.') &amp;&amp; (a[i][j]!='#')) a[i][j] = getchar(); &#125; &#125; Get('1'); Get('2'); Get('3'); Ans = -1; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=m;j++)&#123; if (dist[1][i][j] == -1) continue; if (dist[2][i][j] == -1) continue; if (dist[3][i][j] == -1) continue; int Rec = dist[1][i][j] + dist[2][i][j] + dist[3][i][j]; if (a[i][j] == '.') Rec-=2; if (Ans == -1 || Ans &gt; Rec)&#123; Ans = Rec; &#125; &#125; &#125; printf(\"%d\\n\",Ans);&#125;","raw":"---\ntitle: codeforces590C\ndate: 2017-08-15 08:10:56\ntags:\n - codeforces\n---\n\n# 题意\n\n给定一个N*M的矩阵，这个矩阵里面有'1','2','3','.','#',你可以把'.'改成桥，使得所有1,2,3四联通，问最少把多少个'.'改变，其中‘#'不能改变，如果不能输出-1。——其中'1','2','3'本身是连续的\n\n<!--more-->\n\n# 原题\n\nhttp://codeforces.com/contest/590/problem/C\n\n# Examples\n\n**input**\n\n```\n4 5\n11..2\n#..22\n#.323\n.#333\n```\n\n**output**\n\n```\n2\n```\n\n**input**\n\n```\n1 5\n1#2#3\n```\n\n**output**\n\n```\n-1\n```\n\n# 做法\n\n----\n\n**Wrong**\n\n感觉这是个最小生成树问题\n\n而且联通块个数还为3。那么考虑对于每一个国家，我们得到其它的点到它的最小距离——\n\n通过先把所有这个国家的点压入队列，然后跑一发BFS。\n\n从而得到这个国家和剩下2个国家的最近距离。然后最小生成树然后就错了。\n\n**错误的原因**：没有考虑桥可以公用的情况。\n\n```\n11..22\n......\n..3...\n```\n\n**May_right**\n\n先不考虑无解的情况\n\n注意到，桥一定会在一个点交汇——这个点可能在某个国家里面，也可能在'.'位置。\n\n我们可以考虑枚举这个交汇点的位置，然后把3个国家到这个点的Dis全部加起来，取Min就是结果\n\n为什么是对的呢？这个不会有重复吗？会的。不过必然有一个点没有，那就是交汇点。\n\n我们可以预处理出某一个国家到一个点路上最少经过的'.'的个数——我用循环入队一直T，后来改成优先队列做的——事实上还有更好的方法。\n\n然后枚举每一个点，当然，如果这个点是'.'会被计算3次，要减去。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct Point{\n\tint x,y,d;\n\tPoint(int _x = 0,int _y = 0,int _d = 0){\n\t\tx = _x;\n\t\ty = _y;\n\t\td = _d; \n\t}\n\tbool operator <(const Point &x)const{\n\t\treturn d > x.d;\n\t}\n};\npriority_queue<Point> q;\nint front,rear;\nint dist[4][1005][1005];\nint Ans,n,m;\nint a[1005][1005];\nconst int tx[4] = {0,0,1,-1};\nconst int ty[4] = {1,-1,0,0};\nvoid Get(int c){\n\tint x,y,_x,_y,d,_d;\n\tmemset(dist[c-'0'],-1,sizeof(dist[c - '0']));\n\tfront = rear = 0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tif (a[i][j] == c){\n\t\t\t\tdist[c-'0'][i][j] = 0;\n\t\t\t\tq.push(Point(i,j,0));\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()){\n\t\tx = q.top().x;\n\t\ty = q.top().y;\n\t\td = dist[c-'0'][x][y];\n\t\tq.pop();\n\t\tfor (int t=0;t<4;t++){\n\t\t\t_x = x + tx[t];\n\t\t\t_y = y + ty[t];\n\t\t\tif (a[_x][_y] == '#') continue;   else\n\t\t\tif (a[_x][_y] == '.') _d = d + 1; else\n\t\t\t\t\t\t\t\t  _d = d + 0;\n\t\t\tif (dist[c-'0'][_x][_y] == -1){\n\t\t\t\tdist[c-'0'][_x][_y] = _d;\n\t\t\t\tq.push(Point(_x,_y,_d));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) a[i][0] = a[i][m+1] = '#';\n\tfor (int i=1;i<=m;i++) a[0][i] = a[n+1][i] = '#';\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\ta[i][j] = getchar();\n\t\t\twhile((a[i][j]!='1')&&(a[i][j]!='2')&&(a[i][j]!='3')&&(a[i][j]!='.') && (a[i][j]!='#'))\n\t\t\t\ta[i][j] = getchar();\n\t\t}\n\t}\n\tGet('1');\n\tGet('2');\n\tGet('3');\n\tAns = -1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tif (dist[1][i][j] == -1) continue;\n\t\t\tif (dist[2][i][j] == -1) continue;\n\t\t\tif (dist[3][i][j] == -1) continue;\n\t\t\tint Rec = dist[1][i][j] + dist[2][i][j] + dist[3][i][j];\n\t\t\tif (a[i][j] == '.') Rec-=2;\n\t\t\tif (Ans == -1 || Ans > Rec){\n\t\t\t\tAns = Rec;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Ans);\n}\n```\n\n","link":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"codeforces590C","date":"2017-08-15T00:10:56.000Z","path":"2017/08/15/Codeforces/590/codeforces590C/","text":"题意给定一个N*M的矩阵，这个矩阵里面有’1’,’2’,’3’,’.’,’#’,你可以把’.’改成桥，使得所有1,2,3四联通，问最少把多少个’.’改变，其中‘#’不能改变，如果不能输出-1。——其中’1’,’2’,’3’本身是连续的 原题http://codeforces.com/contest/590/problem/C Examplesinput 123454 511..2#..22#.323.#333 output 12 input 121 51#2#3 output 1-1 做法 Wrong 感觉这是个最小生成树问题 而且联通块个数还为3。那么考虑对于每一个国家，我们得到其它的点到它的最小距离—— 通过先把所有这个国家的点压入队列，然后跑一发BFS。 从而得到这个国家和剩下2个国家的最近距离。然后最小生成树然后就错了。 错误的原因：没有考虑桥可以公用的情况。 12311..22........3... May_right 先不考虑无解的情况 注意到，桥一定会在一个点交汇——这个点可能在某个国家里面，也可能在’.’位置。 我们可以考虑枚举这个交汇点的位置，然后把3个国家到这个点的Dis全部加起来，取Min就是结果 为什么是对的呢？这个不会有重复吗？会的。不过必然有一个点没有，那就是交汇点。 我们可以预处理出某一个国家到一个点路上最少经过的’.’的个数——我用循环入队一直T，后来改成优先队列做的——事实上还有更好的方法。 然后枚举每一个点，当然，如果这个点是’.’会被计算3次，要减去。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;struct Point&#123; int x,y,d; Point(int _x = 0,int _y = 0,int _d = 0)&#123; x = _x; y = _y; d = _d; &#125; bool operator &lt;(const Point &amp;x)const&#123; return d &gt; x.d; &#125;&#125;;priority_queue&lt;Point&gt; q;int front,rear;int dist[4][1005][1005];int Ans,n,m;int a[1005][1005];const int tx[4] = &#123;0,0,1,-1&#125;;const int ty[4] = &#123;1,-1,0,0&#125;;void Get(int c)&#123; int x,y,_x,_y,d,_d; memset(dist[c-'0'],-1,sizeof(dist[c - '0'])); front = rear = 0; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=m;j++)&#123; if (a[i][j] == c)&#123; dist[c-'0'][i][j] = 0; q.push(Point(i,j,0)); &#125; &#125; &#125; while (!q.empty())&#123; x = q.top().x; y = q.top().y; d = dist[c-'0'][x][y]; q.pop(); for (int t=0;t&lt;4;t++)&#123; _x = x + tx[t]; _y = y + ty[t]; if (a[_x][_y] == '#') continue; else if (a[_x][_y] == '.') _d = d + 1; else _d = d + 0; if (dist[c-'0'][_x][_y] == -1)&#123; dist[c-'0'][_x][_y] = _d; q.push(Point(_x,_y,_d)); &#125; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) a[i][0] = a[i][m+1] = '#'; for (int i=1;i&lt;=m;i++) a[0][i] = a[n+1][i] = '#'; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=m;j++)&#123; a[i][j] = getchar(); while((a[i][j]!='1')&amp;&amp;(a[i][j]!='2')&amp;&amp;(a[i][j]!='3')&amp;&amp;(a[i][j]!='.') &amp;&amp; (a[i][j]!='#')) a[i][j] = getchar(); &#125; &#125; Get('1'); Get('2'); Get('3'); Ans = -1; for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=m;j++)&#123; if (dist[1][i][j] == -1) continue; if (dist[2][i][j] == -1) continue; if (dist[3][i][j] == -1) continue; int Rec = dist[1][i][j] + dist[2][i][j] + dist[3][i][j]; if (a[i][j] == '.') Rec-=2; if (Ans == -1 || Ans &gt; Rec)&#123; Ans = Rec; &#125; &#125; &#125; printf(\"%d\\n\",Ans);&#125;","raw":"---\ntitle: codeforces590C\ndate: 2017-08-15 08:10:56\ntags:\n - codeforces\n---\n\n# 题意\n\n给定一个N*M的矩阵，这个矩阵里面有'1','2','3','.','#',你可以把'.'改成桥，使得所有1,2,3四联通，问最少把多少个'.'改变，其中‘#'不能改变，如果不能输出-1。——其中'1','2','3'本身是连续的\n\n<!--more-->\n\n# 原题\n\nhttp://codeforces.com/contest/590/problem/C\n\n# Examples\n\n**input**\n\n```\n4 5\n11..2\n#..22\n#.323\n.#333\n```\n\n**output**\n\n```\n2\n```\n\n**input**\n\n```\n1 5\n1#2#3\n```\n\n**output**\n\n```\n-1\n```\n\n# 做法\n\n----\n\n**Wrong**\n\n感觉这是个最小生成树问题\n\n而且联通块个数还为3。那么考虑对于每一个国家，我们得到其它的点到它的最小距离——\n\n通过先把所有这个国家的点压入队列，然后跑一发BFS。\n\n从而得到这个国家和剩下2个国家的最近距离。然后最小生成树然后就错了。\n\n**错误的原因**：没有考虑桥可以公用的情况。\n\n```\n11..22\n......\n..3...\n```\n\n**May_right**\n\n先不考虑无解的情况\n\n注意到，桥一定会在一个点交汇——这个点可能在某个国家里面，也可能在'.'位置。\n\n我们可以考虑枚举这个交汇点的位置，然后把3个国家到这个点的Dis全部加起来，取Min就是结果\n\n为什么是对的呢？这个不会有重复吗？会的。不过必然有一个点没有，那就是交汇点。\n\n我们可以预处理出某一个国家到一个点路上最少经过的'.'的个数——我用循环入队一直T，后来改成优先队列做的——事实上还有更好的方法。\n\n然后枚举每一个点，当然，如果这个点是'.'会被计算3次，要减去。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct Point{\n\tint x,y,d;\n\tPoint(int _x = 0,int _y = 0,int _d = 0){\n\t\tx = _x;\n\t\ty = _y;\n\t\td = _d; \n\t}\n\tbool operator <(const Point &x)const{\n\t\treturn d > x.d;\n\t}\n};\npriority_queue<Point> q;\nint front,rear;\nint dist[4][1005][1005];\nint Ans,n,m;\nint a[1005][1005];\nconst int tx[4] = {0,0,1,-1};\nconst int ty[4] = {1,-1,0,0};\nvoid Get(int c){\n\tint x,y,_x,_y,d,_d;\n\tmemset(dist[c-'0'],-1,sizeof(dist[c - '0']));\n\tfront = rear = 0;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tif (a[i][j] == c){\n\t\t\t\tdist[c-'0'][i][j] = 0;\n\t\t\t\tq.push(Point(i,j,0));\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()){\n\t\tx = q.top().x;\n\t\ty = q.top().y;\n\t\td = dist[c-'0'][x][y];\n\t\tq.pop();\n\t\tfor (int t=0;t<4;t++){\n\t\t\t_x = x + tx[t];\n\t\t\t_y = y + ty[t];\n\t\t\tif (a[_x][_y] == '#') continue;   else\n\t\t\tif (a[_x][_y] == '.') _d = d + 1; else\n\t\t\t\t\t\t\t\t  _d = d + 0;\n\t\t\tif (dist[c-'0'][_x][_y] == -1){\n\t\t\t\tdist[c-'0'][_x][_y] = _d;\n\t\t\t\tq.push(Point(_x,_y,_d));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) a[i][0] = a[i][m+1] = '#';\n\tfor (int i=1;i<=m;i++) a[0][i] = a[n+1][i] = '#';\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\ta[i][j] = getchar();\n\t\t\twhile((a[i][j]!='1')&&(a[i][j]!='2')&&(a[i][j]!='3')&&(a[i][j]!='.') && (a[i][j]!='#'))\n\t\t\t\ta[i][j] = getchar();\n\t\t}\n\t}\n\tGet('1');\n\tGet('2');\n\tGet('3');\n\tAns = -1;\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=1;j<=m;j++){\n\t\t\tif (dist[1][i][j] == -1) continue;\n\t\t\tif (dist[2][i][j] == -1) continue;\n\t\t\tif (dist[3][i][j] == -1) continue;\n\t\t\tint Rec = dist[1][i][j] + dist[2][i][j] + dist[3][i][j];\n\t\t\tif (a[i][j] == '.') Rec-=2;\n\t\t\tif (Ans == -1 || Ans > Rec){\n\t\t\t\tAns = Rec;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Ans);\n}\n```\n\n","link":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"codeforces560A","date":"2017-08-14T23:57:08.000Z","path":"2017/08/15/Codeforces/590/codeforces590A/","text":"题意给你一个只有0和1组成的序列A，每次可以对序列A进行操作，每次操作是把A的每一个元素变成上一个序列的它，它左边，它右边3个数的中位数，其中1和n不变。问几次操作后会变成稳定——不会再改变，然后稳定时候的状态是怎么样的。 原题http://codeforces.com/contest/590/problem/A 做法对于中间的元素，只有一种情况会使得其改变： 010或者101——其中它在中间。 考虑可以把整个序列划分成一些稳定的两端构成的序列 如，把1010101010111010101划分成 ​ 10101010101|1|1010101这3部分，然后每一部分最终都会变成 4种形态 11110000或者 00001111或者 11111111或者 00000000这种 既然这样，就可以处理，然后答案对操作数取一个Max即可。 线性O(n)扫描。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500500;int a[maxn],Ans,n;bool T[maxn];int L,R,l,r,x,y;int main()&#123; scanf(\"%d\",&amp;n); int cnt = 0; for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); a[0] = a[1]; a[n+1] = a[n]; memset(T,false,sizeof(T)); for (int i=1;i&lt;=n;i++)&#123; if ((a[i-1] != a[i]) &amp;&amp; (a[i+1] != a[i]))&#123; T[i] = true; &#125; &#125; //Ti为true表示要变 L = 1;Ans = 0; for (int R=2;R&lt;=n;R++)&#123; if (!T[R])&#123; l = L + 1,r = R - 1; x = a[L],y = a[R]; cnt = 0; while (l &lt;= r)&#123; a[l] = x; a[r] = y; l++; r--; cnt++; &#125; Ans = max(Ans,cnt); L = R; &#125; &#125; printf(\"%d\\n\",Ans); for (int i=1;i&lt;=n;i++)&#123; printf(\"%d \",a[i]); &#125; return 0;&#125; ​","raw":"---\ntitle: codeforces560A\ndate: 2017-08-15 07:57:08\ntags:\n - codeforces\n---\n\n# 题意\n\n给你一个只有0和1组成的序列A，每次可以对序列A进行操作，每次操作是把A的每一个元素变成上一个序列的它，它左边，它右边3个数的中位数，其中1和n不变。问几次操作后会变成稳定——不会再改变，然后稳定时候的状态是怎么样的。\n\n<!--more-->\n\n# 原题\n\nhttp://codeforces.com/contest/590/problem/A\n\n# 做法\n\n对于中间的元素，只有一种情况会使得其改变：\n\n010或者101——其中它在中间。\n\n考虑可以把整个序列划分成一些稳定的两端构成的序列\n\n----\n\n如，把1010101010111010101划分成\n\n​\t    10101010101|1|1010101这3部分，然后每一部分最终都会变成\n\n4种形态\n\n11110000或者\n\n00001111或者\n\n11111111或者\n\n00000000这种\n\n既然这样，就可以处理，然后答案对操作数取一个Max即可。\n\n线性O(n)扫描。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 500500;\nint a[maxn],Ans,n;\nbool T[maxn];\nint L,R,l,r,x,y;\nint main(){\n\tscanf(\"%d\",&n);\n\tint cnt = 0;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\ta[0] = a[1]; a[n+1] = a[n];\n\tmemset(T,false,sizeof(T));\n\tfor (int i=1;i<=n;i++){\n\t\tif ((a[i-1] != a[i]) && (a[i+1] != a[i])){\n\t\t\tT[i] = true;\n\t\t}\n\t}\n\t//Ti为true表示要变\n\tL = 1;Ans = 0;\n\tfor (int R=2;R<=n;R++){\n\t\tif (!T[R]){\n\t\t\tl = L + 1,r = R - 1;\n\t\t\tx = a[L],y = a[R];\n\t\t\tcnt = 0;\n\t\t\twhile (l <= r){\n\t\t\t\ta[l] = x;\n\t\t\t\ta[r] = y;\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tAns = max(Ans,cnt);\n\t\t\tL = R;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Ans);\n\tfor (int i=1;i<=n;i++){\n\t\tprintf(\"%d \",a[i]);\n\t}\n\treturn 0;\n}\n```\n\n​\t\t\t\t   \n\n","link":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"codeforces560A","date":"2017-08-14T23:57:08.000Z","path":"2017/08/15/Codeforces/590/CF590A/cf590A/","text":"题意给你一个只有0和1组成的序列A，每次可以对序列A进行操作，每次操作是把A的每一个元素变成上一个序列的它，它左边，它右边3个数的中位数，其中1和n不变。问几次操作后会变成稳定——不会再改变，然后稳定时候的状态是怎么样的。 原题http://codeforces.com/contest/590/problem/A 做法对于中间的元素，只有一种情况会使得其改变： 010或者101——其中它在中间。 考虑可以把整个序列划分成一些稳定的两端构成的序列 如，把1010101010111010101划分成 ​ 10101010101|1|1010101这3部分，然后每一部分最终都会变成 4种形态 11110000或者 00001111或者 11111111或者 00000000这种 既然这样，就可以处理，然后答案对操作数取一个Max即可。 线性O(n)扫描。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 500500;int a[maxn],Ans,n;bool T[maxn];int L,R,l,r,x,y;int main()&#123; scanf(\"%d\",&amp;n); int cnt = 0; for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); a[0] = a[1]; a[n+1] = a[n]; memset(T,false,sizeof(T)); for (int i=1;i&lt;=n;i++)&#123; if ((a[i-1] != a[i]) &amp;&amp; (a[i+1] != a[i]))&#123; T[i] = true; &#125; &#125; //Ti为true表示要变 L = 1;Ans = 0; for (int R=2;R&lt;=n;R++)&#123; if (!T[R])&#123; l = L + 1,r = R - 1; x = a[L],y = a[R]; cnt = 0; while (l &lt;= r)&#123; a[l] = x; a[r] = y; l++; r--; cnt++; &#125; Ans = max(Ans,cnt); L = R; &#125; &#125; printf(\"%d\\n\",Ans); for (int i=1;i&lt;=n;i++)&#123; printf(\"%d \",a[i]); &#125; return 0;&#125; ​","raw":"---\ntitle: codeforces560A\ndate: 2017-08-15 07:57:08\ntags:\n - codeforces\n---\n\n# 题意\n\n给你一个只有0和1组成的序列A，每次可以对序列A进行操作，每次操作是把A的每一个元素变成上一个序列的它，它左边，它右边3个数的中位数，其中1和n不变。问几次操作后会变成稳定——不会再改变，然后稳定时候的状态是怎么样的。\n\n<!--more-->\n\n# 原题\n\nhttp://codeforces.com/contest/590/problem/A\n\n# 做法\n\n对于中间的元素，只有一种情况会使得其改变：\n\n010或者101——其中它在中间。\n\n考虑可以把整个序列划分成一些稳定的两端构成的序列\n\n----\n\n如，把1010101010111010101划分成\n\n​\t    10101010101|1|1010101这3部分，然后每一部分最终都会变成\n\n4种形态\n\n11110000或者\n\n00001111或者\n\n11111111或者\n\n00000000这种\n\n既然这样，就可以处理，然后答案对操作数取一个Max即可。\n\n线性O(n)扫描。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 500500;\nint a[maxn],Ans,n;\nbool T[maxn];\nint L,R,l,r,x,y;\nint main(){\n\tscanf(\"%d\",&n);\n\tint cnt = 0;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\ta[0] = a[1]; a[n+1] = a[n];\n\tmemset(T,false,sizeof(T));\n\tfor (int i=1;i<=n;i++){\n\t\tif ((a[i-1] != a[i]) && (a[i+1] != a[i])){\n\t\t\tT[i] = true;\n\t\t}\n\t}\n\t//Ti为true表示要变\n\tL = 1;Ans = 0;\n\tfor (int R=2;R<=n;R++){\n\t\tif (!T[R]){\n\t\t\tl = L + 1,r = R - 1;\n\t\t\tx = a[L],y = a[R];\n\t\t\tcnt = 0;\n\t\t\twhile (l <= r){\n\t\t\t\ta[l] = x;\n\t\t\t\ta[r] = y;\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tAns = max(Ans,cnt);\n\t\t\tL = R;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Ans);\n\tfor (int i=1;i<=n;i++){\n\t\tprintf(\"%d \",a[i]);\n\t}\n\treturn 0;\n}\n```\n\n​\t\t\t\t   \n\n","link":"","tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"USACO5.2.1","date":"2017-08-14T09:20:40.000Z","path":"2017/08/14/USACO/5/USACO5.2.1/snail/","text":"题意有一个N*N的方格(N&lt;=120)，上面有B（B&lt;=200）个障碍，你从(1,1)出发，一开始可以向右或下走，一直碰到障碍，然后选择转90度再走，走到障碍，一直走，直到走的过程中经过了原来走过的格子。问最多能走过过多少格子 原题Snail TrailsAll Ireland Contest Sally Snail likes to stroll on a N x N square grid (1 &lt;n &lt;= 120). She always starts in the upper left corner of the grid. The grid has empty squares (denoted below by ‘.’) and a number (B) of barriers (denoted below by `#’). Here is a depiction of a grid including a demonstration of the grid labelling algorithm: 123456789 A B C D E F G H1 S . . . . . # .2 . . . . # . . .3 . . . . . . . .4 . . . . . . . .5 . . . . . # . .6 # . . . . . . .7 . . . . . . . .8 . . . . . . . . Sally travels vertically (up or down) or horizontally (left or right). Sally can travel either down or right from her starting location, which is always A1. Sally travels as long as she can in her chosen direction. She stops and turns 90 degrees whenever she encounters the edge of the board or one of the barriers. She can not leave the grid or enter a space with a barrier. Additionally, Sally can not re-cross any square she has already traversed. She stops her traversal altogether any time she can no longer make a move. Here is one sample traversal on the sample grid above: 123456789 A B C D E F G H1 S---------+ # .2 . . . . # | . .3 . . . . . | . .4 . . . . . +---+5 . . . . . # . |6 # . . . . . . |7 +-----------+ |8 +-------------+ Sally traversed right, down, right, down, left, up, and right. She could not continue since she encountered a square already visited. Things might have gone differently if she had chosen to turn back toward our left when she encountered the barrier at F5. Your task is to determine and print the largest possible number of squares that Sally can visit if she chooses her turns wisely. Be sure to count square A1 as one of the visited squares. PROGRAM NAME: snailINPUT FORMATThe first line of the input has N, the dimension of the square, and B, the number of barriers (1 &lt;= B &lt;= 200). The subsequent B lines contain the locations of the barriers. The sample input file below describes the sample grid above. The sample output file below is supposed to describe the traversal shown above. Note that when N &gt; 26 then the input file can not specify barriers to the right of column Z. SAMPLE INPUT (file snail.in)123458 4E2A6G1F5 OUTPUT FORMATThe output file should consist of exactly one line, the largest possible number of squares that Sally can visit. SAMPLE OUTPUT (file snail.out)133 Using this traversal: 123456789 A B C D E F G H1 S . . . . . # .2 | . . . # . . .3 | . . . +-----+4 | . . . | . . |5 +-------+ # . |6 # . . . . . . |7 +------------ |8 +-------------+ 做法这题的做法的本质就是一个DFS的搜索。 走还是转。 然后弄一个数组保存哪些格子走过了。 输入比较繁琐。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*ID:cqz15311LANG:C++PROG:snail*/#include&lt;bits/stdc++.h&gt;const int maxn = 125;using namespace std;const int dx[4] = &#123;-1, 0,0,1&#125;;const int dy[4] = &#123; 0,-1,1,0&#125;;#define UP 0#define LEFT 1#define RIGHT 2#define DOWN 3bool vis[maxn][maxn];bool f[maxn][maxn];char s[5];int n,B,Ans;int getnum()&#123; int a = 0; for (int i=1;s[i];i++) a = a*10+s[i]-48; return a;&#125;void PT()&#123; for (int i=0;i&lt;=n+1;i++)&#123; for (int j=0;j&lt;=n+1;j++)&#123; if (vis[i][j]) putchar('V'); else if (f[i][j]) putchar('#'); else putchar('.'); &#125; puts(\"\"); &#125; puts(\"\");&#125;void dfs(int x,int y,int fx,int cnt)&#123; int _x,_y;// printf(\"X = %d %d %d\\n\",x,y,fx); if (f[x][y] || vis[x][y]) return; if (cnt &gt; Ans) Ans = cnt; vis[x][y] = true;// printf(\"%d %d\\n\",x,y);// PT(); _x = x + dx[fx]; _y = y + dy[fx]; if (f[_x][_y])&#123; for (int d=0;d&lt;4;d++) dfs(x + dx[d ],y+dy[d ],d ,cnt+1); &#125;//前面是障碍 else dfs(x + dx[fx],y+dy[fx],fx,cnt+1); vis[x][y] = false;&#125;int main()&#123; freopen(\"snail.in\",\"r\",stdin); freopen(\"snail.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;B); memset(f,0,sizeof(f)); for (int i=1;i&lt;=n;i++) f[0][i] = f[n+1][i] = 1; for (int i=1;i&lt;=n;i++) f[i][0] = f[i][n+1] = 1; for (int i=1;i&lt;=B;i++)&#123; scanf(\"%s\",&amp;s); f[getnum()][s[0] - 'A' + 1] = 1; &#125; Ans = 0; memset(vis,false,sizeof(vis)); dfs(1,1,RIGHT,1); dfs(1,1,DOWN,1); printf(\"%d\\n\",Ans); fclose(stdin); fclose(stdout);&#125; 速度还是很快的 Executing… Test 1: TEST OK [0.014 secs, 4208 KB] Test 2: TEST OK [0.014 secs, 4208 KB] Test 3: TEST OK [0.014 secs, 4208 KB] Test 4: TEST OK [0.014 secs, 4208 KB] Test 5: TEST OK [0.014 secs, 4208 KB] Test 6: TEST OK [0.014 secs, 4208 KB] Test 7: TEST OK [0.014 secs, 4208 KB] Test 8: TEST OK [0.014 secs, 4208 KB] Test 9: TEST OK [0.014 secs, 4208 KB] Test 10: TEST OK [0.014 secs, 4208 KB] Test 11: TEST OK [0.014 secs, 4208 KB] Test 12: TEST OK [0.112 secs, 4208 KB] All tests OK.YOUR PROGRAM (‘snail’) WORKED FIRST TIME! That’s fantastic– and a rare thing. Please accept these special automatedcongratulations.","raw":"---\ntitle: USACO5.2.1\ndate: 2017-08-14 17:20:40\ntags:\n - USACO\n - 搜索\n---\n\n# 题意\n\n有一个N*N的方格(N<=120)，上面有B（B<=200）个障碍，你从(1,1)出发，一开始可以向右或下走，一直碰到障碍，然后选择转90度再走，走到障碍，一直走，直到走的过程中经过了原来走过的格子。问最多能走过过多少格子\n\n<!--more-->\n\n# 原题\n\n**Snail Trails**\n**All Ireland Contest**\n\nSally Snail likes to stroll on a N x N square grid (1 <n <= 120). She always starts in the upper left corner of the grid. The grid has empty squares (denoted below by ‘.') and a number (B) of barriers (denoted below by `#'). Here is a depiction of a grid including a demonstration of the grid labelling algorithm:\n\n```\n          A B C D E F G H\n        1 S . . . . . # .\n        2 . . . . # . . .\n        3 . . . . . . . .\n        4 . . . . . . . .\n        5 . . . . . # . .\n        6 # . . . . . . .\n        7 . . . . . . . .\n        8 . . . . . . . .\n```\n\nSally travels vertically (up or down) or horizontally (left or right). Sally can travel either down or right from her starting location, which is always A1.\n\nSally travels as long as she can in her chosen direction. She stops and turns 90 degrees whenever she encounters the edge of the board or one of the barriers. She can not leave the grid or enter a space with a barrier. Additionally, Sally can not re-cross any square she has already traversed. She stops her traversal altogether any time she can no longer make a move.\n\nHere is one sample traversal on the sample grid above:\n\n```\n          A B C D E F G H\n        1 S---------+ # .\n        2 . . . . # | . .\n        3 . . . . . | . .\n        4 . . . . . +---+\n        5 . . . . . # . |\n        6 # . . . . . . |\n        7 +-----------+ |\n        8 +-------------+\n```\n\nSally traversed right, down, right, down, left, up, and right. She could not continue since she encountered a square already visited. Things might have gone differently if she had chosen to turn back toward our left when she encountered the barrier at F5.\n\nYour task is to determine and print the largest possible number of squares that Sally can visit if she chooses her turns wisely. Be sure to count square A1 as one of the visited squares.\n\n### PROGRAM NAME: snail\n\n### INPUT FORMAT\n\nThe first line of the input has N, the dimension of the square, and B, the number of barriers (1 <= B <= 200). The subsequent B lines contain the locations of the barriers. The sample input file below describes the sample grid above. The sample output file below is supposed to describe the traversal shown above. Note that when N > 26 then the input file can not specify barriers to the right of column Z.\n\n### SAMPLE INPUT (file snail.in)\n\n```\n8 4\nE2\nA6\nG1\nF5\n```\n\n### OUTPUT FORMAT\n\nThe output file should consist of exactly one line, the largest possible number of squares that Sally can visit.\n\n### SAMPLE OUTPUT (file snail.out)\n\n```\n33\n```\n\nUsing this traversal:\n\n```\n          A B C D E F G H\n        1 S . . . . . # .\n        2 | . . . # . . .\n        3 | . . . +-----+\n        4 | . . . | . . |\n        5 +-------+ # . |\n        6 # . . . . . . |\n        7 +------------ |\n        8 +-------------+\n```\n\n# 做法\n\n这题的做法的本质就是一个DFS的搜索。\n\n走还是转。\n\n然后弄一个数组保存哪些格子走过了。\n\n输入比较繁琐。\n\n```cpp\n/*\nID:cqz15311\nLANG:C++\nPROG:snail\n*/\n#include<bits/stdc++.h>\nconst int maxn = 125;\nusing namespace std;\nconst int dx[4] = {-1, 0,0,1};\nconst int dy[4] = { 0,-1,1,0};\n#define UP 0\n#define LEFT 1\n#define RIGHT 2\n#define DOWN 3\nbool vis[maxn][maxn];\nbool f[maxn][maxn];\nchar s[5];\nint n,B,Ans;\nint getnum(){\n\tint a = 0;\n\tfor (int i=1;s[i];i++) a = a*10+s[i]-48;\n\treturn a;\n}\nvoid PT(){\n\tfor (int i=0;i<=n+1;i++){\n\t\tfor (int j=0;j<=n+1;j++){\n\t\t\tif (vis[i][j]) putchar('V'); else\n\t\t\tif (f[i][j]) putchar('#'); else putchar('.');\n\t\t}\n\t\tputs(\"\");\n\t}\n\tputs(\"\");\n}\nvoid dfs(int x,int y,int fx,int cnt){\n\tint _x,_y;\n//\tprintf(\"X = %d %d %d\\n\",x,y,fx);\n\tif (f[x][y] || vis[x][y]) return;\n\tif (cnt > Ans) Ans = cnt;\n\tvis[x][y] = true;\n//\tprintf(\"%d %d\\n\",x,y);\n//\tPT();\n\t_x = x + dx[fx];\n\t_y = y + dy[fx];\n\tif (f[_x][_y]){\n\t\tfor (int d=0;d<4;d++)\n\t\t\tdfs(x + dx[d ],y+dy[d ],d ,cnt+1);\n\t}//前面是障碍 \n\telse \n\t\t\tdfs(x + dx[fx],y+dy[fx],fx,cnt+1);\n\tvis[x][y] = false;\n}\nint main(){\n\tfreopen(\"snail.in\",\"r\",stdin);\n\tfreopen(\"snail.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&B);\n\tmemset(f,0,sizeof(f));\n\tfor (int i=1;i<=n;i++) f[0][i] = f[n+1][i] = 1;\n\tfor (int i=1;i<=n;i++) f[i][0] = f[i][n+1] = 1;\n\tfor (int i=1;i<=B;i++){\n\t\tscanf(\"%s\",&s);\n\t\tf[getnum()][s[0] - 'A' + 1] = 1;\n\t}\n\tAns = 0;\n\tmemset(vis,false,sizeof(vis));\n\tdfs(1,1,RIGHT,1);\n\tdfs(1,1,DOWN,1);\n\tprintf(\"%d\\n\",Ans);\n\tfclose(stdin);\n\tfclose(stdout);\n}\n```\n\n速度还是很快的\n\n\nExecuting...\n   Test 1: TEST OK [0.014 secs, 4208 KB]\n   Test 2: TEST OK [0.014 secs, 4208 KB]\n   Test 3: TEST OK [0.014 secs, 4208 KB]\n   Test 4: TEST OK [0.014 secs, 4208 KB]\n   Test 5: TEST OK [0.014 secs, 4208 KB]\n   Test 6: TEST OK [0.014 secs, 4208 KB]\n   Test 7: TEST OK [0.014 secs, 4208 KB]\n   Test 8: TEST OK [0.014 secs, 4208 KB]\n   Test 9: TEST OK [0.014 secs, 4208 KB]\n   Test 10: TEST OK [0.014 secs, 4208 KB]\n   Test 11: TEST OK [0.014 secs, 4208 KB]\n   Test 12: TEST OK [0.112 secs, 4208 KB]\n\nAll tests OK.\nYOUR PROGRAM ('snail') WORKED FIRST TIME!  That's fantastic\n-- and a rare thing.  Please accept these special automated\ncongratulations.\n","link":"","tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"}]},{"title":"USACO5.1.3","date":"2017-08-14T07:10:03.000Z","path":"2017/08/14/USACO/5/USACO5.1.3/theme/","text":"Musical Themes题意 ​ 给定一个长度为N（N&lt;=5000)的数字串(0~88)，问最长的一个子串，使得除了这个子串外，还有一个与该子串重合位置的另一个长度相同子串的对应位置都是该子串的对应位置增加 原题Brian Dean A musical melody is represented as a sequence of N (1 &lt;= N &lt;= 5000) notes that are integers in the range 1..88, each representing a key on the piano. It is unfortunate but true that this representation of melodies ignores the notion of musical timing; but, this programming task is about notes and not timings. Many composers structure their music around a repeating “theme”, which, being a subsequence of an entire melody, is a sequence of integers in our representation. A subsequence of a melody is a theme if it: is at least five notes long appears (potentially transposed – see below) again somewhere else in the piece of music is disjoint from (i.e., non-overlapping with) at least one of its other appearance(s) Transposed means that a constant positive or negative value is added to every note value in the theme subsequence. Given a melody, compute the length (number of notes) of the longest theme. One second time limit for this problem’s solutions! PROGRAM NAME: themeINPUT FORMATThe first line of the input file contains the integer N. Each subsequent line (except potentially the last) contains 20 integers representing the sequence of notes. The last line contains the remainder of the notes, potentially fewer than 20. SAMPLE INPUT (file theme.in)1233025 27 30 34 39 45 52 60 69 79 69 60 52 45 39 34 30 26 22 1882 78 74 70 66 67 64 60 65 80 OUTPUT FORMATThe output file should contain a single line with a single integer that represents the length of the longest theme. If there are no themes, output 0. SAMPLE OUTPUT (file theme.out)15 [The five-long theme is the last five notes of the first line and the first five notes of the second] 做法做法很多。 下面给出我的做法。 第一想法是哈希。 从而想到了二分答案。 加入现在知道了长度D，只是问存不存在2个长度为D的串可能。 那么存不存在呢？ 如果简单的哈希，难的就是因为有可能转调 经过思考，查询一些题解，找到了一个好的方法 ——转自nocow—— ​ 这个题考虑到相同的旋律之间的差是常数，可以把读入的序列变换一下。就是每个元素与其前一个元素做差。例如原序列 {3,5,7,3,4,4,6,8,4}，做差后是{2,2,-4,1,0,2,2,-4}。这样就可以在变换后的序列中直接查找最长的重复序列即可。上述例子中是2,2,-4，长度为3，对应原序列中3,5,7,3，长度为4。 上述转化后我们就可以通过寻找最长重复串来做到。 做法1 ​ 可以通过上述转化后，以每一个为截开的位置，跑KMP。(N^2) 做法2 ​ 还是我刚才那个想法，每次二分后O(N)扫描，得到这个点以及这个点一直到前面总D个长度的哈希值——如果哈希值相同，很大可能是和前面的重复的，然后D+1就是最终的答案。(N log N) ​ 我后来写这种做法遇到了好多坑——建议大家多练习一下hash的题目，特别是应该多取几个模数，当然我取了2个bit。具体的细节很繁琐，可以看一下代码。 ​ 虽然速度比较快，但是我不推荐这种做法，更简单的做法往下看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/*ID:cqz15311LANG:C++PROG:theme*/#include&lt;bits/stdc++.h&gt;const int Mod = (1e6+7);//好像1e7就超空间了.const int bit1 = 17;const int bit2 = 23;//但位17好像第八个点过了，第九个点WA了//其实可以多重哈希，多取几个模数。//我弄了2个bit就能过USACO所有数据了——其实最好还是取模数，代码改改少 //其实如果是17，3之类的我试了一下是WA的，懒惰就改数字，其实最好是改模数//这题坑了我好久，但是说到底还是Hash的题目做得少。//或者说，以前做hash的题目都不卡单hash的。const int maxn = 5005;using namespace std;typedef long long LL;int Hash1[Mod],Hash2[Mod];LL f1[maxn],f2[maxn],a[maxn];LL Pow1[maxn],Pow2[maxn];int n,L,R,Mid;bool check(int Len)&#123; LL rec1 = 0,rec2 = 0; for (int i=1;i&lt;=Len;i++) rec1 = (rec1 * bit1 + a[i]) % Mod,rec2 = (rec2 * bit2 + a[i]) % Mod; f1[Len] = rec1; f2[Len] = rec2; for (int i=Len+1;i&lt;=n;i++)&#123; rec1 = (((rec1 - Pow1[Len-1] * a[i - Len]) % Mod + Mod) % Mod * bit1 + a[i]) % Mod; rec2 = (((rec2 - Pow2[Len-1] * a[i - Len]) % Mod + Mod) % Mod * bit2 + a[i]) % Mod; f1[i] = rec1; //注意是Len-1不是Len——卡了N久 f2[i] = rec2; &#125; bool flag = false; for (int i=Len;i&lt;=n;i++)&#123; if (Hash1[f1[i]] == -1) Hash1[f1[i]] = i; if (Hash2[f2[i]] == -1) Hash2[f2[i]] = i; if ((Hash1[f1[i]] &lt; i - Len/*+1*/) &amp;&amp; (Hash2[f2[i]] &lt; i - Len)) flag = true; /*不能加一，因为差分过的最后一个等于前面最前面的一个*/ &#125; for (int i=Len;i&lt;=n;i++)&#123; Hash1[f1[i]] = -1; Hash2[f2[i]] = -1; &#125; if (flag) return true; else return false;&#125;int main()&#123; freopen(\"theme.in\",\"r\",stdin); freopen(\"theme.out\",\"w\",stdout); Pow1[0] = 1,Pow2[0] = 1; memset(Hash1,-1,sizeof(Hash1)); memset(Hash2,-1,sizeof(Hash2)); for (int i=1;i&lt;=5000;i++)Pow1[i] = Pow1[i-1] * bit1 % Mod; for (int i=1;i&lt;=5000;i++)Pow2[i] = Pow2[i-1] * bit2 % Mod; scanf(\"%d\",&amp;n); a[0] = 0; for (int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; for (int i=n-1;i&gt;=1;i--)&#123; a[i] = a[i] - a[i-1]; a[i] = (a[i] % Mod + Mod) % Mod; &#125;//a0没用 n--; L = 1; R = n; while (L &lt; R)&#123; Mid = (L + R + 1) &gt;&gt; 1; if (check(Mid))&#123; L = Mid; &#125; else R = Mid - 1; &#125; if (L+1 &lt; 5) puts(\"0\"); else printf(\"%d\\n\",L + 1); fclose(stdin); fclose(stdout); return 0;&#125; 算法3 考虑用DP[i,j]表示左边匹配到i，右边匹配到j的最大匹配数。——直接跑，都不用转化…… Let theme(i,j) be the length of the longest theme which occurs starting at both note i and j. Note that if note[i+1]-note[i] == note[j+1]-note[j], than theme(i,j) = 1+theme(i+1,j+1). Otherwise, theme(i,j) = 1. Thus, we order the search in such a way that theme(i,j) is tested immediately after theme(i+1,j+1), keeping track of the length of the current theme, as well as the length of the longest theme found so far. http://train.usaco.org/usacoanal2?a=2ocZH3qaoaJ&amp;S=theme 12345678910111213141516171819202122232425262728293031323334353637#include &lt;fstream.h&gt;int n;int note[5000];int main () &#123; ifstream filein (\"theme.in\"); filein &gt;&gt; n; for (int i = 0; i &lt; n; ++i) filein &gt;&gt; note[i]; filein.close (); int longest = 1; for (int i = 1; i &lt; n; ++i) &#123; int length = 1; for (int j = n - i - 1 - 1; j &gt;= 0; --j) &#123; if (note[j] - note[j + 1] == note[j + i] - note[j + i + 1]) &#123; ++length; if (length &gt; i) length = i; if (longest &lt; length) longest = length; &#125; else &#123; length = 1; &#125; &#125; &#125; ofstream fileout (\"theme.out\"); fileout &lt;&lt; ((longest &gt;= 5) ? longest : 0) &lt;&lt; endl; fileout.close (); exit (0);&#125; 算法4+ ​ 一些我听说过的名词：好像也只是听说过——————后缀数组。后缀自动机。……","raw":"---\ntitle: USACO5.1.3\ndate: 2017-08-14 15:10:03\ntags:\n - USACO\n - hash\n - 差分\n---\n\n# Musical Themes\n\n**题意**\n\n​\t给定一个长度为N（N<=5000)的数字串(0~88)，问最长的一个子串，使得除了这个子串外，还有一个与该子串重合位置的另一个长度相同子串的对应位置都是该子串的对应位置增加\n\n<!--more-->\n\n# 原题\n\n**Brian Dean**\n\nA musical melody is represented as a sequence of N (1 <= N <= 5000) notes that are integers in the range 1..88, each representing a key on the piano. It is unfortunate but true that this representation of melodies ignores the notion of musical timing; but, this programming task is about notes and not timings.\n\nMany composers structure their music around a repeating \"theme\", which, being a subsequence of an entire melody, is a sequence of integers in our representation. A subsequence of a melody is a theme if it:\n\n- is at least five notes long\n- appears (potentially transposed -- see below) again somewhere else in the piece of music\n- is disjoint from (i.e., non-overlapping with) at least one of its other appearance(s)\n\nTransposed means that a constant positive or negative value is added to every note value in the theme subsequence.\n\nGiven a melody, compute the length (number of notes) of the longest theme.\n\nOne second time limit for this problem's solutions!\n\n### PROGRAM NAME: theme\n\n### INPUT FORMAT\n\nThe first line of the input file contains the integer N. Each subsequent line (except potentially the last) contains 20 integers representing the sequence of notes. The last line contains the remainder of the notes, potentially fewer than 20.\n\n### SAMPLE INPUT (file theme.in)\n\n```\n30\n25 27 30 34 39 45 52 60 69 79 69 60 52 45 39 34 30 26 22 18\n82 78 74 70 66 67 64 60 65 80\n\n```\n\n### OUTPUT FORMAT\n\nThe output file should contain a single line with a single integer that represents the length of the longest theme. If there are no themes, output 0.\n\n### SAMPLE OUTPUT (file theme.out)\n\n```\n5\n\n```\n\n[The five-long theme is the last five notes of the first line and the first five notes of the second] \n\n<!--more-->\n\n# 做法\n\n做法很多。\n\n下面给出我的做法。\n\n\n\n第一想法是**哈希**。\n\n从而想到了二分答案。\n\n加入现在知道了长度D，只是问存不存在2个长度为D的串可能。\n\n那么存不存在呢？\n\n如果简单的哈希，难的就是因为有可能转调\n\n经过思考，查询一些题解，找到了一个好的方法\n\n——转自nocow——\n\n-----------------\n\n​\t这个题考虑到相同的旋律之间的差是常数，可以把读入的序列变换一下。就是每个元素与其前一个元素做差。例如原序列 {3,5,7,3,4,4,6,8,4}，做差后是{2,2,-4,1,0,2,2,-4}。这样就可以在变换后的序列中直接查找最长的重复序列即可。上述例子中是2,2,-4，长度为3，对应原序列中3,5,7,3，长度为4。\n\n----------\n\n上述转化后我们就可以通过寻找最长重复串来做到。\n\n**做法1**\n\n​\t可以通过上述转化后，以每一个为截开的位置，跑KMP。(N^2)\n\n**做法2**\n\n​\t还是我刚才那个想法，每次二分后O(N)扫描，得到这个点以及这个点一直到前面总D个长度的哈希值——如果哈希值相同，很大可能是和前面的重复的，然后D+1就是最终的答案。(N log N)\n\n​\t我后来写这种做法遇到了好多坑——建议大家多练习一下hash的题目，特别是应该多取几个模数，当然我取了2个bit。具体的细节很繁琐，可以看一下代码。\n\n​\t虽然速度比较快，但是我不推荐这种做法，更简单的做法往下看\n\n```cpp\n/*\nID:cqz15311\nLANG:C++\nPROG:theme\n*/\n#include<bits/stdc++.h>\nconst int Mod = (1e6+7);\n//好像1e7就超空间了.\nconst int bit1 = 17;\nconst int bit2 = 23;\n//但位17好像第八个点过了，第九个点WA了\n//其实可以多重哈希，多取几个模数。\n//我弄了2个bit就能过USACO所有数据了——其实最好还是取模数，代码改改少 \n//其实如果是17，3之类的我试了一下是WA的，懒惰就改数字，其实最好是改模数\n//这题坑了我好久，但是说到底还是Hash的题目做得少。\n//或者说，以前做hash的题目都不卡单hash的。\nconst int maxn = 5005;\nusing namespace std;\ntypedef long long LL;\nint Hash1[Mod],Hash2[Mod];\nLL f1[maxn],f2[maxn],a[maxn];\nLL Pow1[maxn],Pow2[maxn];\nint n,L,R,Mid;\nbool check(int Len){\n\tLL rec1 = 0,rec2 = 0;\n\tfor (int i=1;i<=Len;i++) rec1 = (rec1 * bit1 + a[i]) % Mod,rec2 = (rec2 * bit2 + a[i]) % Mod;\n\tf1[Len] = rec1;\n\tf2[Len] = rec2;\n\tfor (int i=Len+1;i<=n;i++){\n\t\trec1 = (((rec1 - Pow1[Len-1] * a[i - Len]) % Mod + Mod) % Mod * bit1 + a[i]) % Mod;\n\t\trec2 = (((rec2 - Pow2[Len-1] * a[i - Len]) % Mod + Mod) % Mod * bit2 + a[i]) % Mod;\n\t\tf1[i] = rec1;\t//注意是Len-1不是Len——卡了N久 \n\t\tf2[i] = rec2;\n\t}\n\tbool flag = false;\n\tfor (int i=Len;i<=n;i++){\n\t\tif (Hash1[f1[i]] == -1) Hash1[f1[i]] = i;\n\t\tif (Hash2[f2[i]] == -1) Hash2[f2[i]] = i;\n\t\tif ((Hash1[f1[i]] < i - Len/*+1*/) && (Hash2[f2[i]] < i - Len)) flag = true;\n\t\t\t\t/*不能加一，因为差分过的最后一个等于前面最前面的一个*/\n\t}\n\tfor (int i=Len;i<=n;i++){\n\t\tHash1[f1[i]] = -1;\n\t\tHash2[f2[i]] = -1;\n\t}\n\tif (flag) return true; else return false;\n}\n\nint main(){\n\tfreopen(\"theme.in\",\"r\",stdin);\n\tfreopen(\"theme.out\",\"w\",stdout);\n\tPow1[0] = 1,Pow2[0] = 1;\n\tmemset(Hash1,-1,sizeof(Hash1));\n\tmemset(Hash2,-1,sizeof(Hash2));\n\tfor (int i=1;i<=5000;i++)Pow1[i] = Pow1[i-1] * bit1 % Mod;\n\tfor (int i=1;i<=5000;i++)Pow2[i] = Pow2[i-1] * bit2 % Mod;\n\tscanf(\"%d\",&n);\n\ta[0] = 0;\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor (int i=n-1;i>=1;i--){\n\t\ta[i] = a[i] - a[i-1];\n\t\ta[i] = (a[i] % Mod + Mod) % Mod;\n\t}//a0没用\n\tn--;\n\tL = 1;\n\tR = n;\n\twhile (L < R){\n\t\tMid = (L + R + 1) >> 1;\n\t\tif (check(Mid)){\n\t\t\tL = Mid;\n\t\t} else \n\t\t\tR = Mid - 1;\n\t}\n\tif (L+1 < 5)  puts(\"0\"); else printf(\"%d\\n\",L + 1);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n```\n\n\n\n**算法3**\n\n考虑用DP[i,j]表示左边匹配到i，右边匹配到j的最大匹配数。——直接跑，都不用转化……\n\n--------\n\nLet theme(i,j) be the length of the longest theme which occurs starting at both note i and j. Note that if note[i+1]-note[i] == note[j+1]-note[j], than theme(i,j) = 1+theme(i+1,j+1). Otherwise, theme(i,j) = 1. Thus, we order the search in such a way that theme(i,j) is tested immediately after theme(i+1,j+1), keeping track of the length of the current theme, as well as the length of the longest theme found so far.\n\n------\n\nhttp://train.usaco.org/usacoanal2?a=2ocZH3qaoaJ&S=theme\n\n```cpp\n#include <fstream.h>\n\nint     n;\nint     note[5000];\n\nint \nmain () {\n    ifstream filein (\"theme.in\");\n    filein >> n;\n    for (int i = 0; i < n; ++i) \n\tfilein >> note[i];\n    filein.close ();\n\n    int     longest = 1;\n\n    for (int i = 1; i < n; ++i) {\n\tint     length = 1;\n\tfor (int j = n - i - 1 - 1; j >= 0; --j) {\n\t    if (note[j] - note[j + 1] == note[j + i] - note[j + i + 1]) {\n\t\t++length;\n\t\tif (length > i) \n\t\t    length = i;\n\t\tif (longest < length)\n\t\t    longest = length;\n\t    }\n\t    else {\n\t\tlength = 1;\n\t    }\n\t}\n    }\n\n    ofstream fileout (\"theme.out\");\n    fileout << ((longest >= 5) ? longest : 0) << endl;\n    fileout.close ();\n\n    exit (0);\n}\n```\n\n\n\n**算法4+**\n\n​\t一些我听说过的名词：好像也只是听说过——————后缀数组。后缀自动机。……\n","link":"","tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"},{"name":"差分","slug":"差分","permalink":"http://yoursite.com/tags/差分/"}]},{"title":"USACO5.1.2","date":"2017-08-14T04:49:06.000Z","path":"2017/08/14/USACO/5/USACO5.1.2/starry/","text":"Starry Night给定H*W的一幅图，让你给图中的一些极大联通快（8联通）编号，已知如果两个联通快经过旋转，对称等可以相同，说明两个联通快是同一个编号的。 原题：——大家仔细理解一下样例 Starry NightIOI 98 High up in the night sky, the shining stars appear in clusters of various shapes. A cluster is a non-empty group of neighbouring stars, adjacent in horizontal, vertical or diagonal direction. A cluster cannot be a part of a larger cluster. Clusters may be similar. Two clusters are similar if they have the same shape and number of stars, irrespective of their orientation. In general, the number of possible orientations for a cluster is eight, as Figure 1 exemplifies. Figure 1. Eight similar clusters The night sky is represented by a sky map, which is a two-dimensional matrix of 0’s and 1’s. A cell contains the digit 1 if it has a star, and the digit 0 otherwise. Given a sky map, mark all the clusters with lower case letters. Similar clusters must be marked with the same letter; non-similar clusters must be marked with different letters. You mark a cluster with a lower case letter by replacing every 1 in the cluster by that lower case letter. PROGRAM NAME: starryINPUT FORMATThe first two lines contain, respectively, the width W and the height H of a sky map. The sky map is given in the following H lines, of W characters each. SAMPLE INPUT (file starry.in)12345678910111213141516172315100010000000000100000000111110001111100010110101000000010001000111111000000000101010001011110000011101000100000000000001001011111000000000100000010000000000000000010100000011111001000000001000000100010011111000000011101010101000100000010011010001000000000010001110111110000000001000011100000001000000000100010000100010010100000001110001000111000 In this case, the sky map has width 23 and height 15. Just to make it clearer, notice that this input file corresponds to the following picture of the sky. Figure 2. Picture of the sky OUTPUT FORMATThe output file contains the same map as the input file, except that the clusters are marked as described in Task. There will generally be more than one way to label the clusters with letters. Your program should choose the labeling such that if the entire output file is read as a string, this string will be minimal in the lexicographical ordering. SAMPLE OUTPUT (file starry.out)123456789101112131415a000a0000000000b00000000aaaaa000ccccc000d0dd0d0a0000000c000c000dddddd000000000c0b0c000d0dddd00000eee0c000c0000000000000e00e0ccccc000000000b000000e00000000000000000b0f000000ccccc00a00000000f000000c000c00aaaaa0000000ddd0c0b0c0a000a000000b00dd0c000c0000000000g000ddd0ccccc000000000g0000ddd0000000e000000000b000d0000f000e00e0b0000000ddd000f000eee000 This is one possible result for the sample input above. Notice that this output file corresponds to the following picture. Figure 3. Picture with the clusters marked Constraints0 &lt;= W (width of the sky map) &lt;= 100 0 &lt;= H (height of the sky map) &lt;= 100 0 &lt;= Number of clusters &lt;= 500 0 &lt;= Number of non-similar clusters &lt;= 26 (a..z) 1 &lt;= Number of stars per cluster &lt;= 160 做法显然，我们可以求出每一个联通快——通过floodfill。那么问题就是哪些联通快是同构的。 容易想到哈希，如果两个联通块完全相同，我们可以通过最左上角的坐标和一些来进行Hash。 那么如果要满足旋转，对称怎么办。 大家想一下，怎么样的一个Hash可以满足？ 可能还有别的做法，但是我写此文时只想到这个。 考虑旋转对称之后，对于联通块的某一个对应的格子，它的周围8个是类似的。 可以考虑把每一个联通快的每一个是1的根据8*8范围内的1来进行Hash——可以累加或者怎么样的。 当然，可以多取几个模数来保证正确性。——反例总是有的。 发现，W*H&lt;=10000，所以是不会超时的。 下面给出我的哈希函数 123456789101112131415161718const int P[5][5] = &#123;&#123;659 ,2017,4049,2017,659 &#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;4049,3359,1 ,3359,4049&#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;659 ,2017,4049,2017,659 &#125;&#125;;int Val(int x,int y)&#123; int ans = 0; for (int i=-2;i&lt;=2;i++)&#123; for (int j=-2;j&lt;=2;j++)&#123; if ((x + i &lt; 0) || (x + i &gt;= H) || (y + j &lt; 0) || (y + j &gt;= W))continue; if (Ans[x+i][y+j] == -1)&#123; ans = ans + P[i+2][j+2]; &#125; &#125; &#125; return ans;&#125; 取一些大素数！这样可以让正确率增大许多。 Executing… Test 1: TEST OK [0.000 secs, 4332 KB] Test 2: TEST OK [0.000 secs, 4332 KB] Test 3: TEST OK [0.000 secs, 4332 KB] Test 4: TEST OK [0.000 secs, 4332 KB] Test 5: TEST OK [0.000 secs, 4332 KB] All tests OK. 事实上很快。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/*ID:cqz15311LANG:C++PROG:starry */#include&lt;bits/stdc++.h&gt;const int maxn = 105;using namespace std;const int dx[8] = &#123;-1,-1,-1, 0,0, 1,1,1&#125;;const int dy[8] = &#123;-1, 0, 1,-1,1,-1,0,1&#125;; struct Q&#123; int x,y; Q(int _x = 0,int _y = 0)&#123; x = _x; y = _y; &#125;&#125;q[maxn*maxn];char a[maxn][maxn];bool vis[maxn][maxn];int Ans[maxn][maxn];int front,rear;int W,H;void floodfill(int sx,int sy)&#123; int x,y,_x,_y;// puts(\"\"); front = rear = 0; q[rear++] = Q(sx,sy); Ans[sx][sy] = -1; while (front &lt; rear)&#123; x = q[front] . x; y = q[front] . y; front++; for (int d=0;d&lt;8;d++)&#123; _x = x + dx[d]; _y = y + dy[d]; if ((_x &lt; 0) || (_y &lt; 0) || (_x &gt;= H) || (_y &gt;= W) || (a[_x][_y] == 0) || Ans[_x][_y] == -1) continue; Ans[_x][_y] = -1; q[rear++] = Q(_x,_y); &#125; &#125;&#125;const int P[5][5] = &#123;&#123;659 ,2017,4049,2017,659 &#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;4049,3359,1 ,3359,4049&#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;659 ,2017,4049,2017,659 &#125;&#125;;int Val(int x,int y)&#123; int ans = 0; for (int i=-2;i&lt;=2;i++)&#123; for (int j=-2;j&lt;=2;j++)&#123; if ((x + i &lt; 0) || (x + i &gt;= H) || (y + j &lt; 0) || (y + j &gt;= W))continue; if (Ans[x+i][y+j] == -1)&#123; ans = ans + P[i+2][j+2]; &#125; &#125; &#125; return ans;&#125;int get_hash(int sx,int sy)&#123; int x,y,_x,_y; int rec = 0; front = rear = 0; q[rear++] = Q(sx,sy); vis[sx][sy] = true; while (front &lt; rear)&#123; x = q[front] . x; y = q[front] . y; rec = rec + Val(x,y); front++; for (int d=0;d&lt;8;d++)&#123; _x = x + dx[d]; _y = y + dy[d]; if ((_x &lt; 0) || (_y &lt; 0) || (_x &gt;= H) || (_y &gt;= W)) continue; if (Ans[_x][_y] == -1 &amp;&amp; !vis[_x][_y])&#123; vis[_x][_y] = true; q[rear++] = Q(_x,_y); &#125; &#125; &#125; return rec;&#125;void Filled(int sx,int sy,int Addval)&#123; int x,y,_x,_y; front = rear = 0; Ans[sx][sy] = Addval; q[rear++] = Q(sx,sy); while (front &lt; rear)&#123; x = q[front] . x; y = q[front] . y; front++; for (int d=0;d&lt;8;d++)&#123; _x = x + dx[d]; _y = y + dy[d]; if ((_x &lt; 0) || (_y &lt; 0) || (_x &gt;= H) || (_y &gt;= W) || Ans[_x][_y] != -1) continue; Ans[_x][_y] = Addval; q[rear++] = Q(_x,_y); &#125; &#125; &#125;int Hash[28];int find(int x)&#123; for (int i=1;i&lt;=Hash[0];i++)&#123; if (x == Hash[i]) return i + 'a' - 1; &#125; Hash[++Hash[0]] = x; return Hash[0] + 'a' - 1;&#125;int main()&#123; freopen(\"starry.in\",\"r\",stdin); freopen(\"starry.out\",\"w\",stdout); scanf(\"%d%d\",&amp;W,&amp;H); for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; a[i][j] = getchar(); while ((a[i][j] != '0') &amp;&amp; (a[i][j]!='1')) a[i][j] = getchar(); a[i][j] -= '0'; &#125; &#125; memset(Hash,0,sizeof(Hash)); memset(vis,false,sizeof(vis)); memset(Ans,0,sizeof(Ans)); for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; if (Ans[i][j] != 0 || a[i][j] == 0) continue; floodfill(i,j); //把当前联通块全部求出来，标记为-1 int Tmp = find(get_hash(i,j)); Filled(i,j,Tmp); &#125; &#125; for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; if (Ans[i][j] == 0) putchar('0'); else printf(\"%c\",Ans[i][j]); &#125; puts(\"\"); &#125; fclose(stdin); fclose(stdout); return 0;&#125;","raw":"---\ntitle: USACO5.1.2\ndate: 2017-08-14 12:49:06\ntags:\n - USACO\n - hash\n---\n\n# Starry Night\n\n给定H*W的一幅图，让你给图中的一些极大联通快（8联通）编号，已知如果两个联通快经过旋转，对称等可以相同，说明两个联通快是同一个编号的。\n\n<!--more-->\n\n原题：——大家仔细理解一下样例\n\n**Starry Night**\n**IOI 98**\n\nHigh up in the night sky, the shining stars appear in clusters of various shapes. A **cluster** is a non-empty group of neighbouring stars, adjacent in horizontal, vertical or diagonal direction. A cluster cannot be a part of a larger cluster.\n\nClusters may be similar. Two clusters are **similar** if they have the same shape and number of stars, irrespective of their orientation. In general, the number of possible orientations for a cluster is eight, as Figure 1 exemplifies.\n\n![Figure 1. Eight similar clusters](http://train.usaco.org/usaco/probs/starry-1.gif) \n*Figure 1. Eight similar clusters*\n\nThe night sky is represented by a sky map, which is a two-dimensional matrix of 0's and 1's. A cell contains the digit 1 if it has a star, and the digit 0 otherwise.\n\nGiven a sky map, mark all the clusters with lower case letters. Similar clusters must be marked with the same letter; non-similar clusters must be marked with different letters.\n\nYou mark a cluster with a lower case letter by replacing every 1 in the cluster by that lower case letter.\n\n### PROGRAM NAME: starry\n\n### INPUT FORMAT\n\nThe first two lines contain, respectively, the width **W** and the height **H** of a sky map. The sky map is given in the following **H** lines, of **W** characters each.\n\n### SAMPLE INPUT (file starry.in)\n\n```\n23\n15\n10001000000000010000000\n01111100011111000101101\n01000000010001000111111\n00000000010101000101111\n00000111010001000000000\n00001001011111000000000\n10000001000000000000000\n00101000000111110010000\n00001000000100010011111\n00000001110101010100010\n00000100110100010000000\n00010001110111110000000\n00100001110000000100000\n00001000100001000100101\n00000001110001000111000\n\n```\n\nIn this case, the sky map has width 23 and height 15. Just to make it clearer, notice that this input file corresponds to the following picture of the sky.\n\n![Figure 2. Picture of thesky](http://train.usaco.org/usaco/probs/starry-2.gif)\n*Figure 2. Picture of the sky*\n\n### OUTPUT FORMAT\n\nThe output file contains the same map as the input file, except that the clusters are marked as described in Task.\n\nThere will generally be more than one way to label the clusters with letters. Your program should choose the labeling such that if the entire output file is read as a string, this string will be minimal in the lexicographical ordering.\n\n### SAMPLE OUTPUT (file starry.out)\n\n```java\na000a0000000000b0000000\n0aaaaa000ccccc000d0dd0d\n0a0000000c000c000dddddd\n000000000c0b0c000d0dddd\n00000eee0c000c000000000\n0000e00e0ccccc000000000\nb000000e000000000000000\n00b0f000000ccccc00a0000\n0000f000000c000c00aaaaa\n0000000ddd0c0b0c0a000a0\n00000b00dd0c000c0000000\n000g000ddd0ccccc0000000\n00g0000ddd0000000e00000\n0000b000d0000f000e00e0b\n0000000ddd000f000eee000\n```\n\nThis is one possible result for the sample input above. Notice that this output file corresponds to the following picture.\n\n![img](http://train.usaco.org/usaco/probs/starry-3.gif)\n*Figure 3. Picture with the clusters marked*\n\n### Constraints\n\n0 <= \n\nW\n\n (width of the sky map) <= 100\n\n0 <= \n\nH\n\n (height of the sky map) <= 100\n\n0 <= Number of clusters <= 500\n\n0 <= Number of non-similar clusters <= 26 (a..z)\n\n1 <= Number of stars per cluster <= 160\n\n\n\n# **做法**\n\n显然，我们可以求出每一个联通快——通过floodfill。那么问题就是哪些联通快是同构的。\n\n容易想到**哈希**，如果两个联通块完全相同，我们可以通过最左上角的坐标和一些来进行Hash。\n\n那么如果要满足旋转，对称怎么办。\n\n> 大家想一下，怎么样的一个Hash可以满足？\n\n\n\n\n\n\n\n\n\n可能还有别的做法，但是我写此文时只想到这个。\n\n考虑旋转对称之后，对于联通块的某一个对应的格子，它的周围8个是类似的。\n\n可以考虑把每一个联通快的每一个是1的根据8*8范围内的1来进行Hash——可以累加或者怎么样的。\n\n当然，可以多取几个模数来保证正确性。——反例总是有的。\n\n发现，W*H<=10000，所以是不会超时的。\n\n下面给出我的哈希函数\n\n```cpp\nconst int P[5][5] = \n{{659 ,2017,4049,2017,659 },\n {2017,3169,3359,3169,2017},\n {4049,3359,1   ,3359,4049},\n {2017,3169,3359,3169,2017},\n {659 ,2017,4049,2017,659 }};\nint Val(int x,int y){\n\tint ans = 0;\n\tfor (int i=-2;i<=2;i++){\n\t\tfor (int j=-2;j<=2;j++){\n\t\t\tif ((x + i < 0) || (x + i >= H) || (y + j < 0) || (y + j >= W))continue;\n\t\t\tif (Ans[x+i][y+j] == -1){\n\t\t\t\tans = ans + P[i+2][j+2];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\n```\n\n取一些大素数！这样可以让正确率增大许多。\n\nExecuting...\n   Test 1: TEST OK [0.000 secs, 4332 KB]\n   Test 2: TEST OK [0.000 secs, 4332 KB]\n   Test 3: TEST OK [0.000 secs, 4332 KB]\n   Test 4: TEST OK [0.000 secs, 4332 KB]\n   Test 5: TEST OK [0.000 secs, 4332 KB]\n\nAll tests OK.\n\n事实上很快。\n\n```cpp\n/*\nID:cqz15311\nLANG:C++\nPROG:starry \n*/\n#include<bits/stdc++.h>\nconst int maxn = 105;\nusing namespace std;\nconst int dx[8] = {-1,-1,-1, 0,0, 1,1,1};\nconst int dy[8] = {-1, 0, 1,-1,1,-1,0,1}; \nstruct Q{\n\tint x,y;\n\tQ(int _x = 0,int _y = 0){\n\t\tx = _x;\n\t\ty = _y;\n\t}\n}q[maxn*maxn];\nchar a[maxn][maxn];\nbool vis[maxn][maxn];\nint Ans[maxn][maxn];\nint front,rear;\nint W,H;\nvoid floodfill(int sx,int sy){\n\tint x,y,_x,_y;\n//\tputs(\"\");\n\tfront = rear = 0;\n\tq[rear++] = Q(sx,sy);\n\tAns[sx][sy] = -1;\n\twhile (front < rear){\n\t\tx = q[front] . x;\n\t\ty = q[front] . y;\n\t\tfront++;\n\t\tfor (int d=0;d<8;d++){\n\t\t\t_x = x + dx[d];\n\t\t\t_y = y + dy[d];\n\t\t\tif ((_x < 0) || (_y < 0) || (_x >= H) || (_y >= W) || (a[_x][_y] == 0) || Ans[_x][_y] == -1) continue;\n\t\t\tAns[_x][_y] = -1;\n\t\t\tq[rear++] = Q(_x,_y);\n\t\t}\n\t}\n}\n\nconst int P[5][5] = \n{{659 ,2017,4049,2017,659 },\n {2017,3169,3359,3169,2017},\n {4049,3359,1   ,3359,4049},\n {2017,3169,3359,3169,2017},\n {659 ,2017,4049,2017,659 }};\nint Val(int x,int y){\n\tint ans = 0;\n\tfor (int i=-2;i<=2;i++){\n\t\tfor (int j=-2;j<=2;j++){\n\t\t\tif ((x + i < 0) || (x + i >= H) || (y + j < 0) || (y + j >= W))continue;\n\t\t\tif (Ans[x+i][y+j] == -1){\n\t\t\t\tans = ans + P[i+2][j+2];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint get_hash(int sx,int sy){\n\tint x,y,_x,_y;\n\tint rec = 0;\n\tfront = rear = 0;\n\tq[rear++] = Q(sx,sy);\n\tvis[sx][sy] = true;\n\twhile (front < rear){\n\t\tx = q[front] . x;\n\t\ty = q[front] . y;\n\t\trec = rec + Val(x,y);\n\t\tfront++;\n\t\tfor (int d=0;d<8;d++){\n\t\t\t_x = x + dx[d];\n\t\t\t_y = y + dy[d];\n\t\t\tif ((_x < 0) || (_y < 0) || (_x >= H) || (_y >= W)) continue;\n\t\t\tif (Ans[_x][_y] == -1 && !vis[_x][_y]){\n\t\t\t\tvis[_x][_y] = true;\n\t\t\t\tq[rear++] = Q(_x,_y);\n\t\t\t}\n\t\t}\n\t}\n\treturn rec;\n}\nvoid Filled(int sx,int sy,int Addval){\n\tint x,y,_x,_y;\n\tfront = rear = 0;\n\tAns[sx][sy] = Addval;\n\tq[rear++] = Q(sx,sy);\n\twhile (front < rear){\n\t\tx = q[front] . x;\n\t\ty = q[front] . y;\n\t\tfront++;\n\t\tfor (int d=0;d<8;d++){\n\t\t\t_x = x + dx[d];\n\t\t\t_y = y + dy[d];\n\t\t\tif ((_x < 0) || (_y < 0) || (_x >= H) || (_y >= W) || Ans[_x][_y] != -1) continue;\n\t\t\tAns[_x][_y] = Addval;\n\t\t\tq[rear++] = Q(_x,_y);\n\t\t}\n\t}\t\n}\nint Hash[28];\nint find(int x){\n\tfor (int i=1;i<=Hash[0];i++){\n\t\tif (x == Hash[i]) return i + 'a' - 1;\n\t}\n\tHash[++Hash[0]] = x;\n\treturn Hash[0] + 'a' - 1;\n}\n\nint main(){\n\tfreopen(\"starry.in\",\"r\",stdin);\n\tfreopen(\"starry.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&W,&H);\n\tfor (int i=0;i<H;i++){\n\t\tfor (int j=0;j<W;j++){\n\t\t\ta[i][j] = getchar();\n\t\t\twhile ((a[i][j] != '0') && (a[i][j]!='1')) a[i][j] = getchar();\n\t\t\ta[i][j] -= '0';\n\t\t}\n\t}\n\tmemset(Hash,0,sizeof(Hash));\n\tmemset(vis,false,sizeof(vis));\n\tmemset(Ans,0,sizeof(Ans));\n\tfor (int i=0;i<H;i++){\n\t\tfor (int j=0;j<W;j++){\n\t\t\tif (Ans[i][j] != 0 || a[i][j] == 0) continue;\n\t\t\tfloodfill(i,j); //把当前联通块全部求出来，标记为-1\n\t\t\tint Tmp = find(get_hash(i,j)); \n\t\t\tFilled(i,j,Tmp);\n\t\t}\n\t}\n\t\n\tfor (int i=0;i<H;i++){\n\t\tfor (int j=0;j<W;j++){\n\t\t\tif (Ans[i][j] == 0) putchar('0'); else\n\t\t\t\t\t\t\t    printf(\"%c\",Ans[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n```\n\n","link":"","tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"}]},{"title":"USACO5.1.1","date":"2017-08-14T01:17:49.000Z","path":"2017/08/14/USACO/5/USACO5.1.1/fc/","text":"Fencing the Cows 给你一些点，问包围这些点的最小花费是多少。 本题的实质是求一个凸包 为什么是凸包？ 很显然地发现，如果存在A-&gt;B-&gt;C，其中B是凹的，那么不如A-&gt;C来得赚。 凸包是什么？请大家自行Baidu Or Google 下面给出凸包的求法： 首先明确什么是叉积 对于点A，点B，它们的叉积就是 |A| |B| sin(α)① 其中|A|表示A的长度，α表示A到B的夹角 我们可以通过α的正负来判断A和B相对于原点的位置（顺时针or逆时针） 然而，叉积还有另外一个公式 A.x B.y - A.y B.x② 123double Cross(Point a,Point b,Point c)&#123;//这里以c为源点 return (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);&#125; 这个证明不给出，主要是通过单位向量之间的转换得到。 那么我们可以通过公式②的正负性得到点之间的位置。 凸包因为是凸多边形，对于相邻的3个点A，B，C（按照逆时针排序） 必然满足相对于A来说，C在B的顺时针方向。 而且我们还知道，凸包的顶点一定是给定的点中的。 因此可以整理出下面的算法框架 $选择最左的，如果相同选择最下面的——这个点一定是凸包中的点 ——好处很多，下面有提到 1234567int k = 0;for (int i=1;i&lt;n;i++)&#123; if ((P[i].x &lt; P[k].x) || (fabs(P[i].x-P[k].x)&lt;eps) &amp;&amp; (P[i].y &lt; P[k].y))&#123; k = i; &#125;&#125;tmp = P[k];P[k] = P[0];P[0] = tmp; $把其它的点与这个点之间，按照极角排序 1234bool cmp(Point a,Point b)&#123; return Cross(a,b,p[0]) &gt; 0; //大于0表示a在b的顺时针方向，所以a应该排在b的前面 &#125; $逆时针一个点一个点考虑，要满足上面提到的性质——用一个栈维护 12345678910top = 0;Stack[top] . x = P[0].x;Stack[top] . y = P[0].y;top++;for (int i=1;i&lt;n;i++)&#123; while ((top &gt;= 2) &amp;&amp; (Cross(P[i],Stack[top-1],Stack[top-2]) &gt; 0)) top--; Stack[top] . x = P[i].x; Stack[top] . y = P[i].y; top++;&#125; $直到考虑完所有点结束（不用重新考虑0号点) 大家可以考虑一下为什么不用重新考虑 上面的性质可以用一个栈来维护。 那么凸包的周长就是所有凸包上的点之间的距离和 123456double Ans = 0;for (int i=1;i&lt;top;i++)&#123; Ans = Ans + dis(Stack[i-1],Stack[i]);&#125;Ans = Ans + dis(Stack[top-1],Stack[0]);printf(\"%.2lf\\n\",Ans); 做法虽然有点繁琐，但代码很好理解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*ID:cqz15311LANG:C++PROG:fc*/#include&lt;bits/stdc++.h&gt;const double eps = 1e-8;using namespace std;struct Point&#123; double x,y;&#125;tmp,P[10005],Stack[10005];int n; double Cross(Point a,Point b,Point c)&#123;//这里以c为源点 return (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);&#125;bool cmp(Point a,Point b)&#123; return Cross(a,b,P[0]) &gt; 0; //大于0表示a在b的顺时针方向，所以a应该排在b的前面 &#125;void init()&#123; freopen(\"fc.in\",\"r\",stdin); freopen(\"fc.out\",\"w\",stdout); scanf(\"%d\",&amp;n); for (int i=0;i&lt;n;i++)&#123; scanf(\"%lf%lf\",&amp;P[i].x,&amp;P[i].y); &#125; int k = 0; for (int i=1;i&lt;n;i++)&#123; if ((P[i].x &lt; P[k].x) || (fabs(P[i].x-P[k].x)&lt;eps) &amp;&amp; (P[i].y &lt; P[k].y))&#123; k = i; &#125; &#125; tmp = P[k];P[k] = P[0];P[0] = tmp; sort(P+1,P+n,cmp);&#125;int top;void solve()&#123; top = 0; Stack[top] . x = P[0].x; Stack[top] . y = P[0].y; top++; for (int i=1;i&lt;n;i++)&#123; while ((top &gt;= 2) &amp;&amp; (Cross(P[i],Stack[top-1],Stack[top-2]) &gt; 0)) top--; Stack[top] . x = P[i].x; Stack[top] . y = P[i].y; top++; &#125;&#125;double dis(Point a,Point b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;void Write()&#123; double Ans = 0; for (int i=1;i&lt;top;i++)&#123; Ans = Ans + dis(Stack[i-1],Stack[i]); &#125; Ans = Ans + dis(Stack[top-1],Stack[0]); printf(\"%.2lf\\n\",Ans); fclose(stdin); fclose(stdout);&#125;int main()&#123; init(); solve(); Write(); return 0;&#125;","raw":"---\ntitle: USACO5.1.1\ndate: 2017-08-14 09:17:49\ntags:\n - USACO\n - 计算几何\n---\n\n**Fencing the Cows**\n\n给你一些点，问包围这些点的最小花费是多少。\n\n<!--more-->\n\n本题的实质是求一个凸包\n\n> 为什么是凸包？\n\n很显然地发现，如果存在A->B->C，其中B是凹的，那么不如A->C来得赚。\n\n> 凸包是什么？请大家自行Baidu Or Google\n\n下面给出凸包的求法：\n\n首先明确什么是叉积\n\n对于点A，点B，它们的叉积就是\n\n|A| * |B| * sin(α)①\n\n其中|A|表示A的长度，α表示A到B的夹角\n\n我们可以通过α的正负来判断A和B相对于原点的位置（顺时针or逆时针）\n\n然而，叉积还有另外一个公式\n\nA.x * B.y - A.y * B.x②\n\n```cpp\ndouble Cross(Point a,Point b,Point c){//这里以c为源点 \n\treturn (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\n}\n```\n\n这个证明不给出，主要是通过单位向量之间的转换得到。\n\n那么我们可以通过公式②的正负性得到点之间的位置。\n\n凸包因为是凸多边形，对于相邻的3个点A，B，C（按照逆时针排序）\n\n必然满足相对于A来说，C在B的顺时针方向。\n\n而且我们还知道，凸包的顶点一定是给定的点中的。\n\n因此可以整理出下面的算法框架\n\n$选择最左的，如果相同选择最下面的——这个点一定是凸包中的点\n\n——好处很多，下面有提到\n\n```cpp\n\tint k = 0;\n\tfor (int i=1;i<n;i++){\n\t\tif ((P[i].x < P[k].x) || (fabs(P[i].x-P[k].x)<eps) && (P[i].y < P[k].y)){\n\t\t\tk = i;\n\t\t}\n\t}\n\ttmp = P[k];P[k] = P[0];P[0] = tmp;\n```\n\n$把其它的点与这个点之间，按照极角排序\n\n```cpp\nbool cmp(Point a,Point b){\n\treturn Cross(a,b,p[0]) > 0;\n\t//大于0表示a在b的顺时针方向，所以a应该排在b的前面 \n}\n```\n\n$逆时针一个点一个点考虑，要满足上面提到的性质——用一个栈维护\n\n```cpp\n\ttop = 0;\n\tStack[top] . x = P[0].x;\n\tStack[top] . y = P[0].y;\n\ttop++;\n\tfor (int i=1;i<n;i++){\n\t\twhile ((top >= 2) && (Cross(P[i],Stack[top-1],Stack[top-2]) > 0)) top--;\n\t\tStack[top] . x = P[i].x;\n\t\tStack[top] . y = P[i].y;\n\t\ttop++;\n\t}\n```\n\n$直到考虑完所有点结束（不用重新考虑0号点)\n\n> 大家可以考虑一下为什么不用重新考虑\n\n上面的性质可以用一个栈来维护。\n\n那么凸包的周长就是所有凸包上的点之间的距离和\n\n```cpp\n\tdouble Ans = 0;\n\tfor (int i=1;i<top;i++){\n\t\tAns = Ans + dis(Stack[i-1],Stack[i]);\n\t}\n\tAns = Ans + dis(Stack[top-1],Stack[0]);\n\tprintf(\"%.2lf\\n\",Ans);\n```\n\n\n\n做法虽然有点繁琐，但代码很好理解\n\n```cpp\n/*\nID:cqz15311\nLANG:C++\nPROG:fc\n*/\n#include<bits/stdc++.h>\nconst double eps = 1e-8;\nusing namespace std;\nstruct Point{\n\tdouble x,y;\n}tmp,P[10005],Stack[10005];\nint n; \ndouble Cross(Point a,Point b,Point c){//这里以c为源点 \n\treturn (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\n}\nbool cmp(Point a,Point b){\n\treturn Cross(a,b,P[0]) > 0;\n\t//大于0表示a在b的顺时针方向，所以a应该排在b的前面 \n}\nvoid init(){\n\tfreopen(\"fc.in\",\"r\",stdin);\n\tfreopen(\"fc.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%lf%lf\",&P[i].x,&P[i].y);\n\t}\n\tint k = 0;\n\tfor (int i=1;i<n;i++){\n\t\tif ((P[i].x < P[k].x) || (fabs(P[i].x-P[k].x)<eps) && (P[i].y < P[k].y)){\n\t\t\tk = i;\n\t\t}\n\t}\n\ttmp = P[k];P[k] = P[0];P[0] = tmp;\n\tsort(P+1,P+n,cmp);\n}\nint top;\nvoid solve(){\n\ttop = 0;\n\tStack[top] . x = P[0].x;\n\tStack[top] . y = P[0].y;\n\ttop++;\n\tfor (int i=1;i<n;i++){\n\t\twhile ((top >= 2) && (Cross(P[i],Stack[top-1],Stack[top-2]) > 0)) top--;\n\t\tStack[top] . x = P[i].x;\n\t\tStack[top] . y = P[i].y;\n\t\ttop++;\n\t}\n}\ndouble dis(Point a,Point b){\n\treturn sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\nvoid Write(){\n\tdouble Ans = 0;\n\tfor (int i=1;i<top;i++){\n\t\tAns = Ans + dis(Stack[i-1],Stack[i]);\n\t}\n\tAns = Ans + dis(Stack[top-1],Stack[0]);\n\tprintf(\"%.2lf\\n\",Ans);\n\tfclose(stdin);\n\tfclose(stdout);\n}\nint main(){\n\tinit();\n\tsolve();\n\tWrite();\n\treturn 0;\n}\n```\n\n","link":"","tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"计算几何","slug":"计算几何","permalink":"http://yoursite.com/tags/计算几何/"}]},{"title":"USACO4.4.3","date":"2017-08-12T10:25:32.000Z","path":"2017/08/12/USACO/4/USACO4.4.3-frameup/frameup/","text":"Frame up题意： 有一些框架，大小在H*W以内，依次放入这些框架在一个格子内，得到一副图，给你这幅图，问放框架的顺序。 保证矩形的每条边都有一部分是可见的。 原题 Consider the following five picture frames shown on an 9 x 8 array: 123456789........ ........ ........ ........ .CCC....EEEEEE.. ........ ........ ..BBBB.. .C.C....E....E.. DDDDDD.. ........ ..B..B.. .C.C....E....E.. D....D.. ........ ..B..B.. .CCC....E....E.. D....D.. ....AAAA ..B..B.. ........E....E.. D....D.. ....A..A ..BBBB.. ........E....E.. DDDDDD.. ....A..A ........ ........E....E.. ........ ....AAAA ........ ........EEEEEE.. ........ ........ ........ ........ 1 2 3 4 5Now place all five picture frames on top of one another starting with 1 at the bottom and ending up with 5 on top. If any part of a frame covers another frame, it hides that part of the frame below. Viewing the stack of five frames we see the following. .CCC... ECBCBB.. DCBCDB.. DCCC.B.. D.B.ABAA D.BBBB.A DDDDAD.A E...AAAA EEEEEE.. Given a picture like this, determine the order of the frames stacked from bottom to top. Here are the rules for this challenge: The width of the frame is always exactly 1 character and the sides are never shorter than 3 characters.It is possible to see at least one part of each of the four sides of a frame. A corner is part of two sides.The frames will be lettered with capital letters, and no two frames will be assigned the same letter.PROGRAM NAME: frameup INPUT FORMAT Line 1: Two space-separated integers: the height H (3 &lt;= H &lt;=30) and the width W (3 &lt;= W &lt;= 30).Line 2..H+1: H lines, each with a string W characters wide.SAMPLE INPUT (file frameup.in) 123456789109 8.CCC....ECBCBB..DCBCDB..DCCC.B..D.B.ABAAD.BBBB.ADDDDAD.AE...AAAAEEEEEE.. OUTPUT FORMAT Print the letters of the frames in the order they were stacked from bottom to top. If there are multiple possibilities for an ordering, list all such possibilities – in alphabetical order – on successive lines. There will always be at least one legal ordering. SAMPLE OUTPUT (file frameup.out) EDABC 做法: 注意到题目保证 ​ 矩形的每条边都有一部分是可见的。 ​ 而且N&lt;=26（不然无法保存） 而且矩形的每一条边的长度为1，我们可以很显然地得到一个矩形的范围。 （通过枚举每一个N，然后得到其最左在什么地方出现，最上在什么地方出现，最右在什么地方出现，最下在什么地方出现） 那么如果在这个矩形边上的可见的，说明那个编号的矩形是当前矩形之后才摁上去的。 从而可以考虑到拓扑排序,怎么做呢？设当前处理到的矩形为i,编号为j的矩形在i的边上，而且是可见的，那么相当于从i到j有一条又向边。 通过一次拓扑排序，就可以得到结果了。 注意，该题中的字母可能不连续。 具体实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*ID:cqz15311LANG:C++PROG:frameup*/#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int from,to,nxt;&#125;edge[31*31*31*31];//邻接矩阵就行了，我是不是太浪费了 int first[255];int H,W,In[255],nume,Len;char a[31][31];bool find(char x)&#123; for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; if (a[i][j] == x) return true; &#125; &#125; return false;&#125;void add_edge(int a,int b)&#123;// printf(\"%c--&gt;%c\\n\",a,b);// if (b == 'E') printf(\"ADDing%c\\n\",a); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; first[a] = nume++; In[b]++;&#125;int cnt;bool vis[255];char ans[255];bool found[255];void dfs(int x)&#123; if (x == Len+1)&#123; for (int i=1;i&lt;=Len;i++) putchar(ans[i]); puts(\"\"); return ; &#125; for (int i='A';i&lt;='Z';i++)&#123; if (found[i] &amp;&amp; !vis[i] &amp;&amp; In[i] == 0)&#123; vis[i] = true; ans[x] = i; for (int e=first[i];e!=-1;e=edge[e].nxt) In[edge[e].to]--; dfs(x+1); for (int e=first[i];e!=-1;e=edge[e].nxt) In[edge[e].to]++; vis[i] =false; ans[x] = -1; &#125; &#125; //一位一位按照字典序枚举，得到一个解就输出，是满足字典序的。 &#125;int main()&#123; freopen(\"frameup.in\",\"r\",stdin); freopen(\"frameup.out\",\"w\",stdout); scanf(\"%d%d\",&amp;H,&amp;W); for (int i=0;i&lt;H;i++)&#123; scanf(\"%s\",&amp;a[i]); &#125; nume = 0; Len = 0; memset(found,false,sizeof(found)); memset(first,-1,sizeof(first)); for (int c='A';c&lt;='Z';c++)&#123; if (find(c))&#123;//可能不连续，所以要判断c是否存在 found[c] = true; Len++; int L,R,U,D; L = W; R = -1; U = H; D = -1; for (int i=0;i&lt;H;i++) for (int j=0;j&lt;W;j++) if (a[i][j] == c) L = min(L,j),R = max(R,j),U = min(U,i),D = max(D,i); for (int i=L;i&lt;=R;i++)&#123; if (a[U][i] != '.' &amp;&amp; a[U][i] != c) add_edge(c,a[U][i]); if (a[D][i] != '.' &amp;&amp; a[D][i] != c) add_edge(c,a[D][i]); &#125; for (int i=U;i&lt;=D;i++)&#123; if (a[i][L] != '.' &amp;&amp; a[i][L] != c) add_edge(c,a[i][L]); if (a[i][R] != '.' &amp;&amp; a[i][R] != c) add_edge(c,a[i][R]); &#125; //注意不能自己向自己连边 &#125; &#125; memset(vis,false,sizeof(vis)); dfs(1); fclose(stdin); fclose(stdout); return 0;&#125; 呼&amp;把第四章刷完了。","raw":"---\ntitle: USACO4.4.3\ndate: 2017-08-12 18:25:32\ntags: USACO\n---\n\n# Frame up\n\n题意：\n\n有一些框架，大小在H*W以内，依次放入这些框架在一个格子内，得到一副图，给你这幅图，问放框架的顺序。\n\n保证矩形的每条边都有一部分是可见的。\n\n<!--more-->\n\n**原题**\n\nConsider the following five picture frames shown on an 9 x 8 array:\n\n```\n........   ........   ........   ........   .CCC....\nEEEEEE..   ........   ........   ..BBBB..   .C.C....\nE....E..   DDDDDD..   ........   ..B..B..   .C.C....\nE....E..   D....D..   ........   ..B..B..   .CCC....\nE....E..   D....D..   ....AAAA   ..B..B..   ........\nE....E..   D....D..   ....A..A   ..BBBB..   ........\nE....E..   DDDDDD..   ....A..A   ........   ........\nE....E..   ........   ....AAAA   ........   ........\nEEEEEE..   ........   ........   ........   ........\n```\n\n   1          2           3          4          5\nNow place all five picture frames on top of one another starting with 1 at the bottom and ending up with 5 on top. If any part of a frame covers another frame, it hides that part of the frame below. Viewing the stack of five frames we see the following.\n\n           .CCC...\n           ECBCBB..\n           DCBCDB..\n           DCCC.B..\n           D.B.ABAA\n           D.BBBB.A\n           DDDDAD.A\n           E...AAAA\n           EEEEEE..\nGiven a picture like this, determine the order of the frames stacked from bottom to top.\n\nHere are the rules for this challenge:\n\nThe width of the frame is always exactly 1 character and the sides are never shorter than 3 characters.\nIt is possible to see at least one part of each of the four sides of a frame. A corner is part of two sides.\nThe frames will be lettered with capital letters, and no two frames will be assigned the same letter.\nPROGRAM NAME: frameup\n\n**INPUT FORMAT**\n\nLine 1:\tTwo space-separated integers: the height H (3 <= H <=30) and the width W (3 <= W <= 30).\nLine 2..H+1:\tH lines, each with a string W characters wide.\nSAMPLE INPUT (file frameup.in)\n\n\n\n```\n9 8\n.CCC....\nECBCBB..\nDCBCDB..\nDCCC.B..\nD.B.ABAA\nD.BBBB.A\nDDDDAD.A\nE...AAAA\nEEEEEE..\n```\n\n**OUTPUT FORMAT**\n\nPrint the letters of the frames in the order they were stacked from bottom to top. If there are multiple possibilities for an ordering, list all such possibilities -- in alphabetical order -- on successive lines. There will always be at least one legal ordering.\n\n**SAMPLE OUTPUT (file frameup.out)**\n\nEDABC\n\n**做法**:\n\n注意到题目保证\n\n​\t矩形的每条边都有一部分是可见的。\n\n​\t而且N<=26（不然无法保存）\n\n而且矩形的每一条边的长度为1，我们可以很显然地得到一个矩形的范围。\n\n（通过枚举每一个N，然后得到其最左在什么地方出现，最上在什么地方出现，最右在什么地方出现，最下在什么地方出现）\n\n那么如果在这个矩形边上的可见的，说明那个编号的矩形是当前矩形之后才摁上去的。\n\n从而可以考虑到**拓扑排序**,怎么做呢？设当前处理到的矩形为i,编号为j的矩形在i的边上，而且是可见的，那么相当于从i到j有一条又向边。\n\n通过一次拓扑排序，就可以得到结果了。\n\n 注意，该题中的字母可能不连续。\n\n\n\n具体实现：\n\n```cpp\n/*\nID:cqz15311\nLANG:C++\nPROG:frameup\n*/\n#include<bits/stdc++.h>\nusing namespace std;\nstruct Edge{\n\tint from,to,nxt;\n}edge[31*31*31*31];\n//邻接矩阵就行了，我是不是太浪费了 \nint first[255];\nint H,W,In[255],nume,Len;\nchar a[31][31];\nbool find(char x){\n\tfor (int i=0;i<H;i++){\n\t\tfor (int j=0;j<W;j++){\n\t\t\tif (a[i][j] == x) return true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid add_edge(int a,int b){\n//\tprintf(\"%c-->%c\\n\",a,b);\n//\tif (b == 'E') printf(\"ADDing%c\\n\",a);\n\tedge[nume] . from = a;\n\tedge[nume] . to = b;\n\tedge[nume] . nxt = first[a];\n\tfirst[a] = nume++;\n\tIn[b]++;\n}\n\n\nint cnt;\nbool vis[255];\nchar ans[255];\nbool found[255];\nvoid dfs(int x){\n\tif (x == Len+1){\n\t\tfor (int i=1;i<=Len;i++) putchar(ans[i]);\n\t\tputs(\"\");\n\t\treturn ;\n\t}\n\tfor (int i='A';i<='Z';i++){\n\t\tif (found[i] && !vis[i] && In[i] == 0){\n\t\t\tvis[i] = true;\n\t\t\tans[x] = i;\n\t\t\tfor (int e=first[i];e!=-1;e=edge[e].nxt) In[edge[e].to]--;\n\t\t\tdfs(x+1);\n\t\t\tfor (int e=first[i];e!=-1;e=edge[e].nxt) In[edge[e].to]++;\n\t\t\tvis[i] =false;\n\t\t\tans[x] = -1;\n\t\t}\n\t}\n\t//一位一位按照字典序枚举，得到一个解就输出，是满足字典序的。 \n}\n\nint main(){\n\tfreopen(\"frameup.in\",\"r\",stdin);\n\tfreopen(\"frameup.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&H,&W);\n\tfor (int i=0;i<H;i++){\n\t\tscanf(\"%s\",&a[i]);\n\t}\n\tnume = 0;\n\tLen = 0;\n\tmemset(found,false,sizeof(found));\n\tmemset(first,-1,sizeof(first));\n\tfor (int c='A';c<='Z';c++){\n\t\tif (find(c)){//可能不连续，所以要判断c是否存在 \n\t\t\tfound[c] = true;\n\t\t\tLen++;\n\t\t\tint L,R,U,D;\n\t\t\tL = W;\n\t\t\tR = -1;\n\t\t\tU = H;\n\t\t\tD = -1;\n\t\t\tfor (int i=0;i<H;i++)\n\t\t\t\tfor (int j=0;j<W;j++)\n\t\t\t\t\tif (a[i][j] == c)\n\t\t\t\t\t\tL = min(L,j),R = max(R,j),U = min(U,i),D = max(D,i);\n\t\t\tfor (int i=L;i<=R;i++){\n\t\t\t\tif (a[U][i] != '.' && a[U][i] != c)\tadd_edge(c,a[U][i]);\n\t\t\t\tif (a[D][i] != '.' && a[D][i] != c) add_edge(c,a[D][i]);\n\t\t\t}\n\t\t\tfor (int i=U;i<=D;i++){\n\t\t\t\tif (a[i][L] != '.' && a[i][L] != c)\tadd_edge(c,a[i][L]);\n\t\t\t\tif (a[i][R] != '.' && a[i][R] != c)\tadd_edge(c,a[i][R]);\n\t\t\t}\n\t\t\t//注意不能自己向自己连边 \n\t\t}\n\t}\n\tmemset(vis,false,sizeof(vis));\n\tdfs(1);\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n```\n\n呼&把第四章刷完了。","link":"","tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"圆桌问题","date":"2017-08-12T08:20:30.000Z","path":"2017/08/12/网络流24题/第5题/5/","text":"有n个单位，每个单位有ri的人，有m个圆桌，每个圆桌可以容纳ci个人，要求使得同一个单位的人不在一个圆桌。求一种分组方法。 考虑建立边 相当于对于s到每个单位流一条ri的边，从圆桌到t连一条ci的边，每个单位和每个圆桌连一条1的边，然后跑一遍SAP。 这题不想多说………… n和m别搞错 其实就是二分图多重匹配问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;const int maxv = 505;const int maxe = maxv*maxv;const int oo = 1&lt;&lt;30;using namespace std;struct Edge&#123; int from,to,nxt,flow,cap;&#125;;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe * 2]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123;// printf(\"%d --&gt; %d:%d\\n\",a,b,c); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; int sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=0;i&lt;n;i++) cur[i] = first[i]; int u = s; while (dist[s] != n+1)&#123;// printf(\"U = %d --&gt;\",u); if (u == t)&#123;// puts(\"Add\"); int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123;// printf(\"%d %d %d\\n\",v,path[v],edge[path[v]].from); if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;int m,n,sum; int main()&#123; scanf(\"%d%d\",&amp;m,&amp;n); G.init(m+n+2); int s = 0,t = n+m+1; for (int i=1;i&lt;=m;i++)&#123; int W; scanf(\"%d\",&amp;W); sum = sum + W; G.add_edge(s,i,W); &#125; for (int i=1;i&lt;=n;i++)&#123; int W; scanf(\"%d\",&amp;W); G.add_edge(m+i,t,W); &#125; for (int i=1;i&lt;=m;i++)&#123; for (int j=1;j&lt;=n;j++)&#123; G.add_edge(i,m+j,1); &#125; &#125; int Ans = G.sap(s,t); if (Ans == sum)&#123; puts(\"1\"); for (int i =1;i&lt;=m;i++)&#123; for (int e=G.first[i];e!=-1;e=G.edge[e].nxt)&#123; if (((e &amp; 1) == 0) &amp;&amp; (G.edge[e].cap == G.edge[e].flow))&#123; printf(\"%d \",G.edge[e].to - m); &#125; &#125; puts(\"\"); &#125; &#125; else puts(\"0\"); &#125;","raw":"---\ntitle: 圆桌问题\ndate: 2017-08-12 16:20:30\ntags:\n---\n\n有n个单位，每个单位有ri的人，有m个圆桌，每个圆桌可以容纳ci个人，要求使得同一个单位的人不在一个圆桌。求一种分组方法。\n\n<!--more-->\n\n考虑建立边\n\n相当于对于s到每个单位流一条ri的边，从圆桌到t连一条ci的边，每个单位和每个圆桌连一条1的边，然后跑一遍SAP。\n\n这题不想多说…………\n\nn和m别搞错\n\n其实就是二分图多重匹配问题。\n\n```cpp\n#include<bits/stdc++.h>\nconst int maxv = 505;\nconst int maxe = maxv*maxv;\nconst int oo = 1<<30;\nusing namespace std;\nstruct Edge{\n\tint from,to,nxt,flow,cap;\n};\nclass Graph{\n\tpublic:\n\t\t\tint first[maxv],n,Max_flow,nume;\n\t\t\tint num[maxv],dist[maxv],cur[maxv];\n\t\t\tint path[maxv];\n\t\t\tEdge edge[maxe * 2];\n\t\t\t\n\t\t\tvoid init(int n){\n\t\t\t\tthis -> n = n;\n\t\t\t\tnume = 0;\n\t\t\t\tmemset(first,-1,sizeof(first));\n\t\t\t}\n\t\t\t\n\t\t\tvoid add_edge(int a,int b,int c){\n//\t\t\t\tprintf(\"%d --> %d:%d\\n\",a,b,c);\n\t\t\t\tedge[nume] . from  = a;\n\t\t\t\tedge[nume] .   to  = b;\n\t\t\t\tedge[nume] .  nxt  = first[a];\n\t\t\t\tedge[nume] .  cap  = c;\n\t\t\t\tedge[nume] . flow  = 0;\n\t\t\t\tfirst[a] = nume++;\n\t\t\t\tedge[nume] . from  = b;\n\t\t\t\tedge[nume] .   to  = a;\n\t\t\t\tedge[nume] .  nxt  = first[b];\n\t\t\t\tedge[nume] .  cap  = 0;\n\t\t\t\tedge[nume] . flow  = 0;\n\t\t\t\tfirst[b] = nume++;\n\t\t\t}\n\t\t\t\n\t\t\tvoid Reset(){\n\t\t\t\tfor (int i=0;i<nume;i++){\n\t\t\t\t\tedge[i].flow = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sap(int s,int t){\n\t\t\t\tReset();\n\t\t\t\tMax_flow = 0;\n\t\t\t\tmemset(num,0,sizeof(num));\n\t\t\t\tnum[0] = n;\n\t\t\t\tmemset(dist,0,sizeof(dist));\n\t\t\t\tfor (int i=0;i<n;i++) cur[i] = first[i];\n\t\t\t\tint u = s;\n\t\t\t\twhile (dist[s] != n+1){\n//\t\t\t\t\tprintf(\"U = %d -->\",u);\n\t\t\t\t\tif (u == t){\n//\t\t\t\t\t\tputs(\"Add\");\n\t\t\t\t\t\tint Min_flow = oo;\n\t\t\t\t\t\tint break_point = -1;\n\t\t\t\t\t\tfor (int v = u;v!=s;v=edge[path[v]].from){\n//\t\t\t\t\t\t\tprintf(\"%d %d %d\\n\",v,path[v],edge[path[v]].from);\n\t\t\t\t\t\t\tif (Min_flow >= edge[path[v]].cap - edge[path[v]].flow){\n\t\t\t\t\t\t\t\tMin_flow = edge[path[v]].cap - edge[path[v]].flow;\n\t\t\t\t\t\t\t\tbreak_point = edge[path[v]].from;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMax_flow += Min_flow;\n\t\t\t\t\t\tfor (int v = u;v!=s;v=edge[path[v]].from){\n\t\t\t\t\t\t\tedge[path[v]] . flow += Min_flow;\n\t\t\t\t\t\t\tedge[path[v] ^ 1] . flow -= Min_flow;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tu = break_point;\n\t\t\t\t\t} else{\n\t\t\t\t\t\tbool found = false;\n\t\t\t\t\t\tfor (int e = cur[u];e!=-1;e=edge[e].nxt){\n\t\t\t\t\t\t\tif ((dist[u] == dist[edge[e].to] + 1) && (edge[e].cap > edge[e].flow)){\n\t\t\t\t\t\t\t\tcur[u] = e;\n\t\t\t\t\t\t\t\tpath[edge[e].to] = e;\n\t\t\t\t\t\t\t\tu = edge[e].to;\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!found){\n\t\t\t\t\t\t\tint tmp = n + 1;\n\t\t\t\t\t\t\tfor (int e=first[u];e!=-1;e=edge[e].nxt)\n\t\t\t\t\t\t\t\tif (edge[e].cap > edge[e].flow){\n\t\t\t\t\t\t\t\t\ttmp = min(tmp,dist[edge[e].to]+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (--num[dist[u]] == 0) return Max_flow;\n\t\t\t\t\t\t\tdist[u] = tmp;\n\t\t\t\t\t\t\tnum[tmp]++;\n\t\t\t\t\t\t\tcur[u] = first[u];\n\t\t\t\t\t\t\tif (u != s) u = edge[path[u]] . from;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Max_flow;\n\t\t\t}\n\t\t;\n}G;\nint m,n,sum; \nint main(){\n\tscanf(\"%d%d\",&m,&n);\n\tG.init(m+n+2);\n\tint s = 0,t = n+m+1;\n\tfor (int i=1;i<=m;i++){\n\t\tint W;\n\t\tscanf(\"%d\",&W);\n\t\tsum = sum + W;\n\t\tG.add_edge(s,i,W);\n\t}\n\t\n\tfor (int i=1;i<=n;i++){\n\t\tint W;\n\t\tscanf(\"%d\",&W);\n\t\tG.add_edge(m+i,t,W);\n\t}\n\t\n\tfor (int i=1;i<=m;i++){\n\t\tfor (int j=1;j<=n;j++){\n\t\t\tG.add_edge(i,m+j,1);\n\t\t}\n\t}\n\tint Ans = G.sap(s,t);\n\tif (Ans == sum){\n\t\tputs(\"1\");\n\t\tfor (int i =1;i<=m;i++){\n\t\t\tfor (int e=G.first[i];e!=-1;e=G.edge[e].nxt){\n\t\t\t\tif (((e & 1) == 0) && (G.edge[e].cap == G.edge[e].flow)){\n\t\t\t\t\tprintf(\"%d \",G.edge[e].to - m);\n\t\t\t\t}\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t} else\n\t\tputs(\"0\");\n\t\n}\n```\n\n","link":"","tags":[]},{"title":"矩形面积并","date":"2017-08-12T02:39:46.000Z","path":"2017/08/12/模拟赛/1/矩形面积并/","text":"给出一些矩形的左下角坐标和右上角坐标，求这些矩形的面积并。 做法： ​ 扫描线。 ​ 将矩形的每一条竖着的边看作一个事件，边在左边表示入边事件，边在右边表示出边时间 ​ 答案就是每次扫描线之间的面积之和 ​ 而因为矩形是规则的，每次扫描线之间的面积和就相当于一个底乘上高。 ​ 高就是扫描线之间的距离。主要考虑求底。 ​ 当坐标值比较小的时候，我们可以考虑暴力枚举出底。 ​ 当坐标值比较大的时候，我们考虑先离散化，然后再暴力枚举。 ​ 当n比较大的时候，显然每次暴力枚举行不通，怎么办呢？ ​ 因为每条扫描线只对应这一个事件。相当于除了这个事件，他和前面的扫描线的底是一样的，因此，可以考虑从前面的扫描线的底来更新当前的扫面先的底。 ​ 如何维护？ ​ 线段树。 ​ 对于线段树的一个节点，我们保存：当前这段区间的底是多少。 ​ 那么如果updata呢？ ​ 显然，当一个区间在入边的时候是最远扩展到一些节点，那么在出边的时候扩展到的也是这些节点。 ​ 因此，可以用一个cnt来保存当前节点被扩展了几次 ​ 如果当前节点被扩展了至少一次，说明这一段是底。 ​ 如果当前节点没有被扩展，那么它第底相当于左边的区间的底+右边的区间的底。 下面给出数据结构 123456struct Q&#123; LL x,a,b,type; bool operator &lt; (const Q &amp;t) const&#123; return x &lt; t.x; &#125;&#125;q[maxn*4]; 表示在x坐标的位置，有一条a到b的扫描线（a和b是离散化的），如果type是1，表示入边，-1表示出边。 1234struct T&#123; LL val; int cnt;&#125;tree[maxn * 4 * 4]; 线段树，保存当前的底和当前节点被覆盖了几次。 下面给出完整程序。 由于是区间，所以线段树向下递归的时候，是将l~R划分成L~mid~R，不是L~mid,mid+1~R。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;const int maxn = 10004;typedef long long LL;using namespace std;struct Q&#123; LL x,a,b,type; bool operator &lt; (const Q &amp;t) const&#123; return x &lt; t.x; &#125;&#125;q[maxn*4];LL numq,Ans;LL y[maxn*4],hash[maxn*4];LL find(LL v)&#123; LL l = 1,r = hash[0]; while (l &lt; r)&#123; LL mid = (l+r) &gt;&gt; 1; if (hash[mid] &gt; v) r = mid -1; else if (hash[mid] &lt; v) l = mid+1; else return mid; &#125; return l;&#125;void Add(LL x,LL a,LL b,LL d)&#123; q[numq] .x = x; q[numq] .a = a; q[numq] .b = b; q[numq] . type = d; numq++;&#125;//线段树部分------------------------------------------------ struct T&#123; LL val; int cnt;&#125;tree[maxn * 4 * 4];void update(int nod,int l,int r)&#123; if (tree[nod] . cnt &gt; 0) tree[nod] . val = hash[r] - hash[l]; else if (r - l == 1) tree[nod] .val = 0; else tree[nod] . val = tree[nod*2].val + tree[nod*2+1].val;&#125;void build(int nod,int l,int r)&#123; if (l+1 == r)&#123; tree[nod] . cnt = 0; tree[nod] . val = 0; return ; &#125; LL mid = (l + r) &gt;&gt; 1; build(nod*2,l,mid); build(nod*2+1,mid,r); update(nod,l,r);&#125;void change(int nod,int l,int r,int x,int y,int changeval)&#123; if ((l == x) &amp;&amp; (r == y))&#123; tree[nod] . cnt +=changeval; &#125; else&#123; LL mid =(l+r) &gt;&gt; 1; if ((l &lt;= x) &amp;&amp; (y &lt;= mid)) change(nod*2, l ,mid,x,y ,changeval); else if ((mid&lt;=x) &amp;&amp; (y&lt;=r)) change(nod*2+1,mid,r ,x,y ,changeval); else&#123; change(nod*2, l ,mid,x,mid,changeval); change(nod*2+1,mid,r ,mid,y,changeval); &#125; &#125; update(nod,l,r);&#125;LL solve()&#123; build(1,1,hash[0]); change(1,1,hash[0],q[0].a,q[0].b,q[0].type); for (LL i=1;i&lt;numq;i++)&#123; Ans = Ans + (q[i].x - q[i-1].x) * (tree[1].val); change(1,1,hash[0],q[i].a,q[i].b,q[i].type); &#125; return Ans;&#125;//线段树部分------------------------------------------------LL n,x1[maxn],x2[maxn],y1[maxn],y2[maxn];int main()&#123; memset(y,0,sizeof(y)); memset(hash,0,sizeof(hash)); scanf(\"%lld\",&amp;n); for (LL i=1;i&lt;=n;i++)&#123; scanf(\"%lld%lld%lld%lld\",&amp;x1[i],&amp;y1[i],&amp;x2[i],&amp;y2[i]); y[++y[0]] = y1[i]; y[++y[0]] = y2[i]; &#125; sort(y+1,y+1+y[0]); hash[0] = 0; for (LL i=1;i&lt;=y[0];i++) if ((i == 1) || (y[i] != y[i-1])) hash[++hash[0]] = y[i]; numq = 0; for (LL i=1;i&lt;=n;i++)&#123; Add(x1[i],find(y1[i]),find(y2[i]),1); Add(x2[i],find(y1[i]),find(y2[i]),-1); &#125; sort(q,q+numq); printf(\"%lld\\n\",solve());&#125; 注意，该代码只适用于坐标为整数，坐标为小数请大家自行脑补。（也不支持没有面积的矩形）","raw":"---\ntitle: 矩形面积并\ndate: 2017-08-12 10:39:46\ntags:\n - 数据结构\n---\n\n给出一些矩形的左下角坐标和右上角坐标，求这些矩形的面积并。\n\n<!--more-->\n\n做法：\n\n​\t**扫描线。**\n\n​\t将矩形的每一条竖着的边看作一个事件，边在左边表示入边事件，边在右边表示出边时间\n\n​\t答案就是每次扫描线之间的面积之和\n\n​\t而因为矩形是规则的，每次扫描线之间的面积和就相当于一个底乘上高。\n\n​\t高就是扫描线之间的距离。主要考虑求底。\n\n​\t当坐标值比较小的时候，我们可以考虑暴力枚举出底。\n\n​\t当坐标值比较大的时候，我们考虑先**离散化**，然后再暴力枚举。\n\n​\t当n比较大的时候，显然每次暴力枚举行不通，怎么办呢？\n\n​\t因为每条扫描线只对应这一个事件。相当于除了这个事件，他和前面的扫描线的底是一样的，因此，可以考虑**从前面的扫描线的底来更新当前的扫面先的底**。\n\n​\t如何维护？\n\n<!--more-->\n\n​\t线段树。\n\n​\t对于线段树的一个节点，我们保存：当前这段区间的底是多少。\n\n​\t那么如果updata呢？\n\n​\t显然，当一个区间在入边的时候是最远扩展到一些节点，那么在出边的时候扩展到的也是这些节点。\n\n​\t因此，可以用一个cnt来保存当前节点被扩展了几次\n\n​\t如果当前节点被扩展了至少一次，说明这一段是底。\n\n​\t如果当前节点没有被扩展，那么它第底相当于左边的区间的底+右边的区间的底。\n\n下面给出数据结构\n\n```cpp\nstruct Q{\n\tLL x,a,b,type;\n\tbool operator < (const Q &t) const{\n\t\treturn x < t.x;\n\t}\n}q[maxn*4];\n```\n\n表示在x坐标的位置，有一条a到b的扫描线（a和b是离散化的），如果type是1，表示入边，-1表示出边。\n\n```cpp\nstruct T{\n\tLL val;\n\tint cnt;\n}tree[maxn * 4 * 4];\n```\n\n线段树，保存当前的底和当前节点被覆盖了几次。\n\n<!--more-->\n\n下面给出完整程序。\n\n由于是区间，所以线段树向下递归的时候，是将l~R划分成L~mid~R，不是L~mid,mid+1~R。\n\n```cpp\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nconst int maxn = 10004;\ntypedef long long LL;\nusing namespace std;\nstruct Q{\n\tLL x,a,b,type;\n\tbool operator < (const Q &t) const{\n\t\treturn x < t.x;\n\t}\n}q[maxn*4];\nLL numq,Ans;\nLL y[maxn*4],hash[maxn*4];\nLL find(LL v){\n\tLL l = 1,r = hash[0];\n\twhile (l < r){\n\t\tLL mid = (l+r) >> 1;\n\t\tif (hash[mid] > v)\tr = mid -1; else\n\t\tif (hash[mid] < v)\tl = mid+1; else \n\t\t\t\t\t\t\treturn mid;\n\t}\n\treturn l;\n}\n\nvoid Add(LL x,LL a,LL b,LL d){\n\tq[numq] .x = x;\n\tq[numq] .a = a;\n\tq[numq] .b = b;\n\tq[numq] . type = d;\n\tnumq++;\n}\n//线段树部分------------------------------------------------ \nstruct T{\n\tLL val;\n\tint cnt;\n}tree[maxn * 4 * 4];\nvoid update(int nod,int l,int r){\n\tif (tree[nod] . cnt > 0) tree[nod] . val = hash[r] - hash[l]; else\n\tif (r - l == 1)\t\t \t tree[nod] .val = 0;  else\n\t\t\t\t\t\t\t tree[nod] . val = tree[nod*2].val + tree[nod*2+1].val;\n}\n\nvoid build(int nod,int l,int r){\n\tif (l+1 == r){\n\t\ttree[nod] . cnt = 0;\n\t\ttree[nod] . val = 0;\n\t\treturn ;\n\t}\n\tLL mid = (l + r) >> 1;\n\tbuild(nod*2,l,mid);\n\tbuild(nod*2+1,mid,r);\n\tupdate(nod,l,r);\n}\n\nvoid change(int nod,int l,int r,int x,int y,int changeval){\n\tif ((l == x) && (r == y)){\n\t\ttree[nod] . cnt +=changeval;\n\t} else{\n\t\tLL mid =(l+r) >> 1;\n\t\tif ((l <= x) && (y <= mid))\n\t\t\tchange(nod*2,  l  ,mid,x,y  ,changeval); else\n\t\tif ((mid<=x) && (y<=r))\n\t\t\tchange(nod*2+1,mid,r  ,x,y  ,changeval); else{\n\t\t\tchange(nod*2,  l  ,mid,x,mid,changeval);\n\t\t\tchange(nod*2+1,mid,r  ,mid,y,changeval);\n\t\t}\n\t}\n\tupdate(nod,l,r);\n}\n\nLL solve(){\n\tbuild(1,1,hash[0]);\n\tchange(1,1,hash[0],q[0].a,q[0].b,q[0].type);\n\tfor (LL i=1;i<numq;i++){\n\t\tAns = Ans + (q[i].x - q[i-1].x) * (tree[1].val);\n\t\tchange(1,1,hash[0],q[i].a,q[i].b,q[i].type);\n\t}\n\treturn Ans;\n}\n\n//线段树部分------------------------------------------------\nLL n,x1[maxn],x2[maxn],y1[maxn],y2[maxn];\nint main(){\n\tmemset(y,0,sizeof(y));\n\tmemset(hash,0,sizeof(hash));\n\tscanf(\"%lld\",&n);\n\tfor (LL i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&x1[i],&y1[i],&x2[i],&y2[i]);\n\t\ty[++y[0]] = y1[i];\n\t\ty[++y[0]] = y2[i];\n\t}\n\tsort(y+1,y+1+y[0]);\n\thash[0] = 0;\n\tfor (LL i=1;i<=y[0];i++)\n\t\tif ((i == 1) || (y[i] != y[i-1]))\n\t\t\thash[++hash[0]] = y[i];\n\t\t\t\n\tnumq = 0;\n\tfor (LL i=1;i<=n;i++){\n\t\tAdd(x1[i],find(y1[i]),find(y2[i]),1);\n\t\tAdd(x2[i],find(y1[i]),find(y2[i]),-1);\n\t}\n\tsort(q,q+numq);\n\tprintf(\"%lld\\n\",solve());\n}\n```\n\n注意，该代码只适用于坐标为整数，坐标为小数请大家自行脑补。（也不支持没有面积的矩形）","link":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"USACO4.4.1","date":"2017-08-11T13:04:04.000Z","path":"2017/08/11/USACO/4/USACO4.4.1-shuttle/shuttle/","text":"Shuttle Puzzle题意：给定n，当n=3的时候，表示从WWW_BBB到BBB_WWW的最少操作步数。每次可以将某一个W或者B移动到空格位置，但是距离得小于等于2。 n&lt;=12 这题搜索似乎要超时。 下面给出原题： USACO4.4.1 Shuttle PuzzleTraditionalThe Shuttle Puzzle of size 3 consists of 3 white marbles, 3 black marbles, and a strip of wood with 7 holes. The marbles of the same color are placed in the holes at the opposite ends of the strip, leaving the center hole empty. INITIAL STATE: WWW_BBBGOAL STATE: BBB_WWWTo solve the shuttle puzzle, use only two types of moves. Move 1 marble 1 space (into the empty hole) or jump 1 marble over 1 marble of the opposite color (into the empty hole). You may not back up, and you may not jump over 2 marbles. A Shuttle Puzzle of size N consists of N white marbles and N black marbles and 2N+1 holes. Here’s one solution for the problem of size 3 showing the initial, intermediate, and end states: WWW BBBWW WBBBWWBW BBWWBWB BWWB BWBW BWBWB WBWBWBBW WBWBBWBW WBBWBWBWBWBWB WBWB BWWB BWBWWBB WBWWBBBW WWBBB WWWWrite a program that will solve the SHUTTLE PUZZLE for any size N (1 &lt;= N &lt;= 12) in the minimum number of moves and display the successive moves, 20 per line. PROGRAM NAME: shuttle INPUT FORMAT A single line with the integer N.SAMPLE INPUT (file shuttle.in) 3OUTPUT FORMAT The list of moves expressed as space-separated integers, 20 per line (except possibly the last line). Number the marbles/holes from the left, starting with one. Output the solution that would appear first among the set of minimal solutions sorted numerically (first by the first number, using the second number for ties, and so on). SAMPLE OUTPUT (file shuttle.out) 3 5 6 4 2 1 3 5 7 6 4 2 3 5 4 一下仅表示-对于Nocow内容，我的理解- 33 5 6 4 2 1 3 5 7 6 4 2 3 5 444 6 7 5 3 2 4 6 8 9 7 5 3 1 2 4 6 8 7 5 3 4 6 555 7 8 6 4 3 5 7 9 10 8 6 4 2 1 3 5 7 9 11 10 8 6 4 2 3 5 7 9 8 6 4 5 7 666 8 9 7 5 4 6 8 10 11 9 7 5 3 2 4 6 8 10 12 13 11 9 7 5 3 1 2 4 6 8 10 12 11 9 7 5 3 4 6 8 10 9 7 5 6 8 7 进行神奇的分析 把空格的位置也算上 3：4|35|642|1357|642|35|4 4：5|46|753|2468|97531|2468|753|46|5 ……聪明的你发现规律了吗？ 是的，这是一个对称的等差数列。 要证明？？http://train.usaco.org/usacoanal2?a=lNUFVam4bZA&amp;S=shuttle 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*ID:cqz15311LANG:C++PROG:shuttle*/#include&lt;bits/stdc++.h&gt; using namespace std;int n,now,len,cnt;int main()&#123; freopen(\"shuttle.in\",\"r\",stdin); freopen(\"shuttle.out\",\"w\",stdout); scanf(\"%d\",&amp;n); now = n+1; cnt = 0; for (int i=1;i&lt;=2*n+1;i++)&#123; if (i &lt;= n+1)&#123; len = i; &#125; else len = 2 * (n+1) - i; if (i &amp; 1)&#123; for (int j=1;j&lt;=len;j++)&#123; if (i!=1)&#123; cnt++; printf(\"%d\",now); if ((i == 2*n+1) &amp;&amp; (j == len)) puts(\"\"); else if (cnt % 20 == 0) puts(\"\"); else putchar(' '); &#125; now = now - 2; &#125; now+=2; if (i &lt;= n)now--; else now++; &#125; else&#123; for (int j=1;j&lt;=len;j++)&#123; cnt++; printf(\"%d\",now); if (cnt % 20 == 0) puts(\"\"); else putchar(' '); now = now + 2; &#125; now-=2; if (i &lt;= n)now++; else now--; &#125; &#125; //puts(\"\");这个不能有！害得我没有1A fclose(stdin); fclose(stdout); return 0;&#125;/*Executing... Test 1: TEST OK [0.000 secs, 4176 KB] Test 2: TEST OK [0.000 secs, 4176 KB] Test 3: TEST OK [0.000 secs, 4176 KB] Test 4: TEST OK [0.000 secs, 4176 KB] Test 5: TEST OK [0.000 secs, 4176 KB] Test 6: TEST OK [0.000 secs, 4176 KB] Test 7: TEST OK [0.000 secs, 4176 KB] Test 8: TEST OK [0.000 secs, 4176 KB] Test 9: TEST OK [0.000 secs, 4176 KB] Test 10: TEST OK [0.000 secs, 4176 KB]All tests OK.Your program ('shuttle') produced all correct answers! This is yoursubmission #2 for this problem. Congratulations!*/","raw":"---\ntitle: USACO4.4.1\ndate: 2017-08-11 21:04:04\ntags: \n - USACO\n---\n\n# Shuttle Puzzle\n\n题意：给定n，当n=3的时候，表示从WWW_BBB到BBB_WWW的最少操作步数。每次可以将某一个W或者B移动到空格位置，但是距离得小于等于2。\n\nn<=12\n\n<!--more-->\n\n这题搜索似乎要超时。\n\n下面给出原题：\n\nUSACO4.4.1\n\n**Shuttle Puzzle**\n**Traditional**\nThe Shuttle Puzzle of size 3 consists of 3 white marbles, 3 black marbles, and a strip of wood with 7 holes. The marbles of the same color are placed in the holes at the opposite ends of the strip, leaving the center hole empty.\n\nINITIAL STATE: WWW_BBB \nGOAL STATE: BBB_WWW\nTo solve the shuttle puzzle, use only two types of moves. Move 1 marble 1 space (into the empty hole) or jump 1 marble over 1 marble of the opposite color (into the empty hole). You may not back up, and you may not jump over 2 marbles.\n\nA Shuttle Puzzle of size N consists of N white marbles and N black marbles and 2N+1 holes.\n\nHere's one solution for the problem of size 3 showing the initial, intermediate, and end states:\n\nWWW BBB\nWW WBBB\nWWBW BB\nWWBWB B\nWWB BWB\nW BWBWB\n WBWBWB\nBW WBWB\nBWBW WB\nBWBWBW \nBWBWB W\nBWB BWW\nB BWBWW\nBB WBWW\nBBBW WW\nBBB WWW\nWrite a program that will solve the SHUTTLE PUZZLE for any size N (1 <= N <= 12) in the minimum number of moves and display the successive moves, 20 per line.\n\nPROGRAM NAME: shuttle\n\n**INPUT FORMAT**\n\nA single line with the integer N.\n**SAMPLE INPUT (file shuttle.in)**\n\n3\n**OUTPUT FORMAT**\n\nThe list of moves expressed as space-separated integers, 20 per line (except possibly the last line). Number the marbles/holes from the left, starting with one.\n\nOutput the solution that would appear first among the set of minimal solutions sorted numerically (first by the first number, using the second number for ties, and so on).\n\n**SAMPLE OUTPUT (file shuttle.out)**\n\n3 5 6 4 2 1 3 5 7 6 4 2 3 5 4\n\n\n\n一下仅表示-对于Nocow内容，我的理解-\n\n3\n3 5 6 4 2 1 3 5 7 6 4 2 3 5 4\n4\n4 6 7 5 3 2 4 6 8 9 7 5 3 1 2 4 6 8 7 5 3 4 6 5\n5\n5 7 8 6 4 3 5 7 9 10 8 6 4 2 1 3 5 7 9 11 10 8 6 4 2 3 5 7 9 8 6 4 5 7 6\n6\n6 8 9 7 5 4 6 8 10 11 9 7 5 3 2 4 6 8 10 12 13 11 9 7 5 3 1 2 4 6 8 10 12 11 9 7 5 3 4 6 8 10 9 7 5 6 8 7\n\n**进行神奇的分析**\n\n把空格的位置也算上\n\n3：4|35|642|1357|642|35|4\n\n4：5|46|753|2468|97531|2468|753|46|5\n\n……聪明的你发现规律了吗？\n\n是的，这是一个对称的等差数列。\n\n要证明？？http://train.usaco.org/usacoanal2?a=lNUFVam4bZA&S=shuttle\n\n```cpp\n/*\nID:cqz15311\nLANG:C++\nPROG:shuttle\n*/\n#include<bits/stdc++.h> \nusing namespace std;\nint n,now,len,cnt;\nint main(){\n\tfreopen(\"shuttle.in\",\"r\",stdin);\n\tfreopen(\"shuttle.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tnow = n+1;\n\tcnt = 0;\n\tfor (int i=1;i<=2*n+1;i++){\n\t\tif (i <= n+1){\n\t\t\tlen = i;\n\t\t} else \n\t\t\tlen = 2 * (n+1) - i;\n\t\tif (i & 1){\n\t\t\tfor (int j=1;j<=len;j++){\n\t\t\t\tif (i!=1){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tprintf(\"%d\",now);\n\t\t\t\t\tif ((i == 2*n+1) && (j == len)) puts(\"\"); else\n\t\t\t\t\tif (cnt % 20 == 0) puts(\"\"); else\n\t\t\t\t\tputchar(' ');\n\t\t\t\t}\n\t\t\t\tnow = now - 2;\n\t\t\t}\n\t\t\tnow+=2;\n\t\t\tif (i <= n)now--; else now++;\n\t\t} else{\n\t\t\tfor (int j=1;j<=len;j++){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tprintf(\"%d\",now);\n\t\t\t\t\tif (cnt % 20 == 0) puts(\"\"); else\n\t\t\t\t\tputchar(' ');\n\t\t\t\t\tnow = now + 2;\n\t\t\t}\n\t\t\tnow-=2;\n\t\t\tif (i <= n)now++; else now--;\n\t\t}\n\t}\n\t//puts(\"\");这个不能有！害得我没有1A \n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n/*\nExecuting...\n   Test 1: TEST OK [0.000 secs, 4176 KB]\n   Test 2: TEST OK [0.000 secs, 4176 KB]\n   Test 3: TEST OK [0.000 secs, 4176 KB]\n   Test 4: TEST OK [0.000 secs, 4176 KB]\n   Test 5: TEST OK [0.000 secs, 4176 KB]\n   Test 6: TEST OK [0.000 secs, 4176 KB]\n   Test 7: TEST OK [0.000 secs, 4176 KB]\n   Test 8: TEST OK [0.000 secs, 4176 KB]\n   Test 9: TEST OK [0.000 secs, 4176 KB]\n   Test 10: TEST OK [0.000 secs, 4176 KB]\n\nAll tests OK.\nYour program ('shuttle') produced all correct answers!  This is your\nsubmission #2 for this problem.  Congratulations!\n*/ \n```\n\n","link":"","tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO4.4.2","date":"2017-08-11T12:44:20.000Z","path":"2017/08/11/USACO/4/USACO4.4.2-milk6/milk6/","text":"Pollutant Control题意：给定一张图，每条边有流量，求一个图的最小割，并且求出字典序最小一组最小割（在满足的情况下，边越少越好）。 下面给出原题： USACO4.4.2 Pollutant Control Hal Burch It’s your first day in Quality Control at Merry Milk Makers, and already there’s been a catastrophe: a shipment of bad milk has been sent out. Unfortunately, you didn’t discover this until the milk was already into your delivery system on its way to stores. You know which grocer that milk was destined for, but there may be multiple ways for the milk to get to that store. The delivery system is made up of a several warehouses, with trucks running from warehouse to warehouse moving milk. While the milk will be found quickly, it is important that it does not make it to the grocer, so you must shut down enough trucks to ensure that it is impossible for the milk to get to the grocer in question. Every route costs a certain amount to shut down. Find the minimum amount that must be spent to ensure the milk does not reach its destination, along with a set of trucks to shut down that achieves this goal at that cost. PROGRAM NAME: milk6 INPUT FORMAT Line 1: Two space separated integers, N and M. N (2 &lt;= N &lt;= 32) is the number of warehouses that Merry Milk Makers has, and M (0 &lt;= M &lt;= 1000) is the number of trucks routes run. Warehouse 1 is actually the productional facility, while warehouse N is the grocer to which which the bad milk was destined. Line 2..M+1: Truck routes: three space-separated integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si,Ei &lt;= N) correspond to the pickup warehouse and dropoff warehouse for the truck route. Ci (0 &lt;= Ci &lt;= 2,000,000) is the cost of shutting down the truck route. SAMPLE INPUT (file milk6.in) 1234564 51 3 1003 2 502 4 601 2 402 3 80 OUTPUT FORMAT The first line of the output should be two integers, C and T. C is the minimum amount which must be spent in order to ensure the our milk never reaches its destination. T is the minimum number of truck routes that you plan to shut down in order to achive this goal. The next T lines sould contain a sorted list of the indexes of the truck routes that you suggest shutting down. If there are multiple sets of truck routes that achieve the goal at minimum cost, choose one that shuts down the minimum number of routes. If there are still multiple sets, choose the one whose initial routes have the smallest index. SAMPLE OUTPUT (file milk6.out) 1260 13 分析和做法： 这题只需要最大流就可以：注意到边不超过1000个，我们可以把每条边的边权改成原来的边权*1001再加上1，那么跑一编最小割，可以得到用的边最少的。因为在边权相同的情况下，1选的越少越好。 那么答案就是最小割 / 1001。 那么如何求出字典序最小的一组最小割呢？ 显然，因为要字典序最小，我们不能用普通的BFS之类的。 考虑枚举每一条边，如果删去这条边后整个图的最小割变小了，而且变小的正好等于这条边的边权，说明这条边是最小割的一部分，然后真的把这条边从原来的网络中删去。 这里有一些注意点： 1、后面都是每行输出一个答案，不是一行里面 2、要开long long，不然会爆 3、答案的maxv和maxe不要搞错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/*ID:cqz15311LANG:C++PROG:milk6 */#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL oo = 1LL&lt;&lt;50;const int maxv = 35;const int maxe = 2005;struct Edge&#123; int from,to,nxt; LL cap,flow;&#125;;struct G&#123; int nume; int first[maxv],cur[maxv],path[maxv],num[maxv+2],n; int dist[maxv]; Edge edge[maxe * 2]; LL Max_flow; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123; edge[nume] . from = a; edge[nume] . to = b; edge[nume] . cap = c; edge[nume] . flow = 0; edge[nume] . nxt = first[a]; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . cap = 0; edge[nume] . flow = 0; edge[nume] . nxt = first[b]; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++) edge[i] . flow = 0; &#125; LL sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=1;i&lt;=n;i++) cur[i] = first[i]; int u = s; while (dist[s] &lt; n)&#123;// printf(\"%d\\n\",u); if (u == t)&#123; LL Min_flow = oo,break_point; //Augment for (int v=t;v!=s;v=edge[path[v]].from)&#123; if (edge[path[v]] . cap - edge[path[v]] . flow &lt; Min_flow)&#123; Min_flow = edge[path[v]] . cap - edge[path[v]] . flow; break_point = edge[path[v]] . from; &#125; &#125; Max_flow += Min_flow; for (int v=t;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v]^1] .flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int &amp;e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((edge[e].cap &gt; edge[e].flow) &amp;&amp; (dist[edge[e].to] + 1 == dist[u]))&#123; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n+1; for (int e=first[u];e!=-1;e=edge[e].nxt)&#123; if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to] + 1); &#125; &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125;&#125;G;int ans[maxe+1];int a[maxe],b[maxe];LL c[maxe];int main()&#123; freopen(\"milk6.in\",\"r\",stdin); freopen(\"milk6.out\",\"w\",stdout); int n,m; scanf(\"%d%d\",&amp;n,&amp;m); G.init(n); for (int i=0;i&lt;m;i++)&#123; scanf(\"%d%d%lld\",&amp;a[i],&amp;b[i],&amp;c[i]); c[i] = c[i] * 1001 + 1; G.add_edge(a[i],b[i],c[i]); &#125; LL Max_flow = G.sap(1,n); printf(\"%lld \",Max_flow / 1001); memset(ans,0,sizeof(ans)); for (int i=0;i&lt;m;i++)&#123; G.edge[i*2] . cap = 0; LL tmp = G.sap(1,n); if (Max_flow - tmp == c[i])&#123; ans[++ans[0]] = i+1; Max_flow -= c[i]; &#125; else G.edge[i*2] . cap = c[i]; &#125; printf(\"%d\\n\",ans[0]); if (ans[0] != 0)&#123; printf(\"%d\\n\",ans[1]); for (int i=2;i&lt;=ans[0];i++)&#123; printf(\"%d\\n\",ans[i]); &#125; &#125; fclose(stdin); fclose(stdout);&#125;/*Executing... Test 1: TEST OK [0.000 secs, 4328 KB] Test 2: TEST OK [0.000 secs, 4328 KB] Test 3: TEST OK [0.000 secs, 4328 KB] Test 4: TEST OK [0.000 secs, 4328 KB] Test 5: TEST OK [0.056 secs, 4328 KB] Test 6: TEST OK [0.000 secs, 4328 KB] Test 7: TEST OK [0.000 secs, 4328 KB] Test 8: TEST OK [0.000 secs, 4328 KB] Test 9: TEST OK [0.014 secs, 4328 KB] Test 10: TEST OK [0.154 secs, 4328 KB] Test 11: TEST OK [0.000 secs, 4328 KB] Test 12: TEST OK [0.000 secs, 4328 KB]All tests OK.*/","raw":"---\ntitle: USACO4.4.2\ndate: 2017-08-11 20:44:20\ntags: \n - USACO\n - 网络流\n---\n\n# Pollutant Control\n\n题意：给定一张图，每条边有流量，求一个图的最小割，并且求出字典序最小一组最小割（在满足的情况下，边越少越好）。\n\n<!-- more -->\n\n下面给出原题：\n\nUSACO4.4.2\n\n**Pollutant Control**\n\n**Hal Burch**\n\nIt's your first day in Quality Control at Merry Milk Makers, and already there's been a catastrophe: a shipment of bad milk has been sent out. Unfortunately, you didn't discover this until the milk was already into your delivery system on its way to stores. You know which grocer that milk was destined for, but there may be multiple ways for the milk to get to that store.\n\nThe delivery system is made up of a several warehouses, with trucks running from warehouse to warehouse moving milk. While the milk will be found quickly, it is important that it does not make it to the grocer, so you must shut down enough trucks to ensure that it is impossible for the milk to get to the grocer in question. Every route costs a certain amount to shut down. Find the minimum amount that must be spent to ensure the milk does not reach its destination, along with a set of trucks to shut down that achieves this goal at that cost.\n\nPROGRAM NAME: milk6\n\nINPUT FORMAT\n\n  Line 1:     \tTwo space separated integers, N and M. N (2 <= N <= 32) is the number of warehouses that Merry Milk Makers has, and M (0 <= M <= 1000) is the number of trucks routes run. Warehouse 1 is actually the productional facility, while warehouse N is the grocer to which which the bad milk was destined.\n  Line 2..M+1:\tTruck routes: three space-separated integers, Si, Ei, and Ci. Si and Ei (1 <= Si,Ei <= N) correspond to the pickup warehouse and dropoff warehouse for the truck route. Ci (0 <= Ci <= 2,000,000) is the cost of shutting down the truck route.\n\nSAMPLE INPUT (file milk6.in)\n\n```cpp\n4 5\n1 3 100\n3 2 50\n2 4 60\n1 2 40\n2 3 80\n```\n\nOUTPUT FORMAT\n\nThe first line of the output should be two integers, C and T. C is the minimum amount which must be spent in order to ensure the our milk never reaches its destination. T is the minimum number of truck routes that you plan to shut down in order to achive this goal. The next T lines sould contain a sorted list of the indexes of the truck routes that you suggest shutting down. If there are multiple sets of truck routes that achieve the goal at minimum cost, choose one that shuts down the minimum number of routes. If there are still multiple sets, choose the one whose initial routes have the smallest index.\n\nSAMPLE OUTPUT (file milk6.out)\n\n```cpp\n60 1\n3\n```\n\n\n\n\n\n<!-- more -->\n\n分析和做法：\n\n这题只需要最大流就可以：注意到边不超过1000个，我们可以把每条边的边权改成原来的边权*1001再加上1，那么跑一编最小割，可以得到用的边最少的。因为在边权相同的情况下，1选的越少越好。\n\n那么答案就是最小割 / 1001。\n\n那么如何求出字典序最小的一组最小割呢？\n\n显然，因为要字典序最小，我们不能用普通的BFS之类的。\n\n考虑枚举每一条边，如果删去这条边后整个图的最小割变小了，而且变小的正好等于这条边的边权，说明这条边是最小割的一部分，然后真的把这条边从原来的网络中删去。\n\n这里有一些注意点：\n\n1、后面都是每行输出一个答案，不是一行里面\n\n2、要开long long，不然会爆\n\n3、答案的maxv和maxe不要搞错。\n\n```cpp\n/*\nID:cqz15311\nLANG:C++\nPROG:milk6 \n*/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL oo = 1LL<<50;\nconst int maxv = 35;\nconst int maxe = 2005;\nstruct Edge{\n\tint from,to,nxt;\n\tLL cap,flow;\n};\nstruct G{\n\tint nume;\n\tint first[maxv],cur[maxv],path[maxv],num[maxv+2],n;\n\tint dist[maxv];\n\tEdge edge[maxe * 2];\n\tLL Max_flow;\n\t\n\tvoid init(int n){\n\t\tthis -> n = n;\n\t\tnume = 0;\n\t\tmemset(first,-1,sizeof(first));\n\t}\n\tvoid add_edge(int a,int b,int c){\n\t\tedge[nume] . from = a;\n\t\tedge[nume] . to   = b;\n\t\tedge[nume] . cap  = c;\n\t\tedge[nume] . flow = 0;\n\t\tedge[nume] . nxt  = first[a];\n\t\tfirst[a] = nume++;\n\t\tedge[nume] . from = b;\n\t\tedge[nume] . to   = a;\n\t\tedge[nume] . cap  = 0;\n\t\tedge[nume] . flow = 0;\n\t\tedge[nume] . nxt  = first[b];\n\t\tfirst[b] = nume++;\n\t}\n\tvoid Reset(){\n\t\tfor (int i=0;i<nume;i++) edge[i] . flow = 0;\n\t}\n\tLL sap(int s,int t){\n\t\tReset();\n\t\tMax_flow = 0;\n\t\tmemset(num,0,sizeof(num));\n\t\tnum[0] = n;\n\t\tmemset(dist,0,sizeof(dist));\n\t\tfor (int i=1;i<=n;i++) cur[i] = first[i];\n\t\tint u = s;\n\t\twhile (dist[s] < n){\n//\t\t\tprintf(\"%d\\n\",u);\n\t\t\tif (u == t){\n\t\t\t\tLL Min_flow = oo,break_point;\n\t\t\t\t//Augment\n\t\t\t\tfor (int v=t;v!=s;v=edge[path[v]].from){\n\t\t\t\t\tif (edge[path[v]] . cap - edge[path[v]] . flow < Min_flow){\n\t\t\t\t\t\tMin_flow = edge[path[v]] . cap - edge[path[v]] . flow;\n\t\t\t\t\t\tbreak_point = edge[path[v]] . from;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMax_flow += Min_flow;\n\t\t\t\tfor (int v=t;v!=s;v=edge[path[v]].from){\n\t\t\t\t\tedge[path[v]] . flow += Min_flow;\n\t\t\t\t\tedge[path[v]^1] .flow -= Min_flow;\n\t\t\t\t}\n\t\t\t\tu = break_point;\n\t\t\t} else{\n\t\t\t\tbool found = false;\n\t\t\t\tfor (int &e = cur[u];e!=-1;e=edge[e].nxt){\n\t\t\t\t\tif ((edge[e].cap > edge[e].flow) && (dist[edge[e].to] + 1 == dist[u])){\n\t\t\t\t\t\tpath[edge[e].to] = e;\n\t\t\t\t\t\tu = edge[e].to;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found){\n\t\t\t\t\tint tmp = n+1;\n\t\t\t\t\tfor (int e=first[u];e!=-1;e=edge[e].nxt){\n\t\t\t\t\t\tif (edge[e].cap > edge[e].flow){\n\t\t\t\t\t\t\ttmp = min(tmp,dist[edge[e].to] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (--num[dist[u]] == 0) return Max_flow;\n\t\t\t\t\tdist[u] = tmp;\n\t\t\t\t\tnum[tmp]++;\n\t\t\t\t\tcur[u] = first[u];\n\t\t\t\t\tif (u != s) u = edge[path[u]] . from;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Max_flow;\n\t}\n}G;\nint ans[maxe+1];\nint a[maxe],b[maxe];\nLL c[maxe];\nint main(){\n\tfreopen(\"milk6.in\",\"r\",stdin);\n\tfreopen(\"milk6.out\",\"w\",stdout);\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tG.init(n);\n\tfor (int i=0;i<m;i++){\n\t\tscanf(\"%d%d%lld\",&a[i],&b[i],&c[i]);\n\t\tc[i] = c[i] * 1001 + 1;\n\t\tG.add_edge(a[i],b[i],c[i]);\n\t}\n\tLL Max_flow = G.sap(1,n);\n\tprintf(\"%lld \",Max_flow / 1001);\n\tmemset(ans,0,sizeof(ans));\n\tfor (int i=0;i<m;i++){\n\t\tG.edge[i*2] . cap = 0;\n\t\tLL tmp = G.sap(1,n);\n\t\tif (Max_flow - tmp == c[i]){\n\t\t\tans[++ans[0]] = i+1;\n\t\t\tMax_flow -= c[i];\n\t\t} else\n\t\t\tG.edge[i*2] . cap = c[i];\n\t}\n\tprintf(\"%d\\n\",ans[0]);\n\tif (ans[0] != 0){\n\t\tprintf(\"%d\\n\",ans[1]);\n\t\tfor (int i=2;i<=ans[0];i++){\n\t\t\tprintf(\"%d\\n\",ans[i]);\n\t\t}\n\t} \n\tfclose(stdin);\n\tfclose(stdout);\n}\n/*\n\nExecuting...\n   Test 1: TEST OK [0.000 secs, 4328 KB]\n   Test 2: TEST OK [0.000 secs, 4328 KB]\n   Test 3: TEST OK [0.000 secs, 4328 KB]\n   Test 4: TEST OK [0.000 secs, 4328 KB]\n   Test 5: TEST OK [0.056 secs, 4328 KB]\n   Test 6: TEST OK [0.000 secs, 4328 KB]\n   Test 7: TEST OK [0.000 secs, 4328 KB]\n   Test 8: TEST OK [0.000 secs, 4328 KB]\n   Test 9: TEST OK [0.014 secs, 4328 KB]\n   Test 10: TEST OK [0.154 secs, 4328 KB]\n   Test 11: TEST OK [0.000 secs, 4328 KB]\n   Test 12: TEST OK [0.000 secs, 4328 KB]\nAll tests OK.\n\n*/\n```\n\n","link":"","tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"网络流练习4","date":"2017-08-11T07:46:09.000Z","path":"2017/08/11/网络流24题/第4题/4/","text":"魔术球问题有n根柱子，每次可以依次放入编号为1,2,3……个球，每次只能在最上面放球，要求同一根柱子中相邻两球的编号和为完全平方数，问n根柱子上最多能放多少球。 假设有 n 根柱子，现要按下述规则在这 n 根柱子中依次放入编号为 1，2，3，…的球。（1）每次只能在某根柱子的最上面放球。（2）在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。试设计一个算法，计算出在 n 根柱子上最多能放多少个球。例如，在 4 根柱子上最多可放 11 个球。对于给定的 n，计算在 n 根柱子上最多能放多少个球。 样例输入 ​ 4 样例输出 ​ 11 ​ 1 8 ​ 2 7 9 ​ 3 6 10 ​ 4 5 11 数据范围 ​ N&lt;=60 分析： ​ 我们可以考虑把两个可以相邻的点连上一条有向边，那么答案就是用n条路径覆盖1~Ans所有点。 ​ 可以考虑二分出Ans，然后判断前Ans个是否可行（用最小路径覆盖解决，可以见网络流练习3），可以发现，随着Ans的增大，需要的路劲数是单调非递减的。 ​ 就是从原来的模型——&gt;最小路径覆盖——&gt;二分图匹配——&gt;最大流 ​ 但是其实二分答案，因为每次都要重新建图，所以比较慢，可以考虑每次加入2个点，加入一些边，然后把dist数组重新弄成0，在原来的图的基础上继续找增广路。然后继续找增广路。这样最早得到一个不可行的Ans，Ans-1就是答案。 ​ 最后再把最后2个点删掉，重新跑一边最大流，然后输出方案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;bits/stdc++.h&gt;const int maxAns = 5000;const int maxv = maxAns*2+5;const int maxe = 3200000;const int oo = 1&lt;&lt;30;using namespace std;struct Edge&#123; int from,to,nxt,flow,cap;&#125;;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe * 2]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123;// printf(\"%d:%d --&gt; %d:%d\\n\",nume,a,b,c);// printf(\"Add:Edge[0] . from = %d\",edge[0].from); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; void init_sap()&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); memset(path,0,sizeof(path)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=0;i&lt;n;i++) cur[i] = first[i]; &#125; int sap(int s,int t)&#123; memset(dist,0,sizeof(dist)); int u = s; while (dist[s] != n+1)&#123; if (u == t)&#123; int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123; if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;int n,m;bool vis[maxv];int main()&#123; int s = 0,t = maxAns *2 + 1; G.init(maxAns*2+2); scanf(\"%d\",&amp;n); G.Reset(); int i; for (i=1;i&lt;=maxAns;i++)&#123; G.add_edge(s,i,1); G.add_edge(maxAns + i,t,1); for (int j=1;j&lt;i;j++)&#123; int t = (int)sqrt(1.0*(i+j)); if (t * t == (i+j))&#123; G.add_edge(j,i + maxAns,1); &#125; &#125; int rec = i - G.sap(s,t); if (rec &gt; n)&#123; break; &#125; &#125; //Ans = i int Ans = i-1; for (int j=0;j&lt;G.nume;j++)&#123; if ((G.edge[j].to == i) || (G.edge[j].to == i+maxAns) || (G.edge[j].from == i) || (G.edge[j].from == i+maxAns))&#123; G.edge[j].cap = 0; G.edge[j].flow = 0; &#125; &#125; G.Reset(); G.sap(s,t); /* for (int j=0;j&lt;G.nume;j++)&#123; if ((G.edge[j].to == i) || (G.edge[j].to == i+maxAns) || (G.edge[j].from == i) || (G.edge[j].from == i+maxAns))&#123; G.edge[j].cap = -1; G.edge[j].flow = -1; printf(\"Delete%d--&gt;%d\\n\",G.edge[j].from,G.edge[j].to); &#125; &#125;*/ memset(vis,false,sizeof(vis)); vis[i] = true; printf(\"%d\\n\",Ans); for (int i=1;i&lt;=Ans;i++)&#123; if (vis[i]) continue; int u = i; // printf(\"find(%d) = %d\\n\",i,u); while (true)&#123;// printf(\"%d,%d \\n\",vis[u],u); printf(\"%d \",u); vis[u] = true; bool found = false; for (int e=G.first[u];e!=-1;e=G.edge[e].nxt)&#123;// printf(\"%d--(%d,%d)-&gt;%d\\n\",u,G.edge[e].cap,G.edge[e].flow,G.edge[e].to); if (((e &amp; 1) == 0) &amp;&amp; (G.edge[e].cap == G.edge[e].flow) &amp;&amp; (!vis[G.edge[e].to - maxAns]))&#123; u = G.edge[e].to - maxAns; found = true; break; &#125; &#125; if (!found) break; &#125;// printf(\"\\n%d**\",i); puts(\"\"); &#125;&#125;","raw":"---\ntitle: 网络流练习4\ndate: 2017-08-11 15:46:09\ntags: 网络流\n---\n\n# 魔术球问题\n\n有n根柱子，每次可以依次放入编号为1,2,3……个球，每次只能在最上面放球，要求同一根柱子中相邻两球的编号和为完全平方数，问n根柱子上最多能放多少球。\n\n<!--more-->\n\n假设有 n 根柱子，现要按下述规则在这 n 根柱子中依次放入编号为 1，2，3，…的球。 \n（1）每次只能在某根柱子的最上面放球。 \n（2）在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。 \n试设计一个算法，计算出在 n 根柱子上最多能放多少个球。例如，在 4 根柱子上最多可放 11 个球。 \n对于给定的 n，计算在 n 根柱子上最多能放多少个球。\n\n样例输入\n\n​\t4\n\n样例输出\n\n​\t11\n\n​\t1 8\n\n​\t2 7 9\n\n​\t3 6 10\n\n​\t4 5 11\n\n数据范围\n\n​\tN<=60\n\n\n\n<!-- more -->\n\n分析：\n\n​\t我们可以考虑把两个可以相邻的点连上一条有向边，那么答案就是用n条路径覆盖1~Ans所有点。\n\n​\t可以考虑二分出Ans，然后判断前Ans个是否可行（用最小路径覆盖解决，可以见网络流练习3），可以发现，随着Ans的增大，需要的路劲数是单调非递减的。\n\n​\t就是从原来的模型——>最小路径覆盖——>二分图匹配——>最大流\n\n​\t但是其实二分答案，因为每次都要重新建图，所以比较慢，可以考虑每次加入2个点，加入一些边，然后把dist数组重新弄成0，在原来的图的基础上继续找增广路。然后继续找增广路。这样最早得到一个不可行的Ans，Ans-1就是答案。\n\n​\t最后再把最后2个点删掉，重新跑一边最大流，然后输出方案。\n\n```cpp\n#include<bits/stdc++.h>\nconst int maxAns = 5000;\nconst int maxv = maxAns*2+5;\nconst int maxe = 3200000;\nconst int oo = 1<<30;\nusing namespace std;\nstruct Edge{\n\tint from,to,nxt,flow,cap;\n};\nclass Graph{\n\tpublic:\n\t\t\tint first[maxv],n,Max_flow,nume;\n\t\t\tint num[maxv],dist[maxv],cur[maxv];\n\t\t\tint path[maxv];\n\t\t\tEdge edge[maxe * 2];\n\t\t\t\n\t\t\tvoid init(int n){\n\t\t\t\tthis -> n = n;\n\t\t\t\tnume = 0;\n\t\t\t\tmemset(first,-1,sizeof(first));\n\t\t\t}\n\t\t\t\n\t\t\tvoid add_edge(int a,int b,int c){\n//\t\t\t\tprintf(\"%d:%d --> %d:%d\\n\",nume,a,b,c);\n//\t\t\t\tprintf(\"Add:Edge[0] . from = %d\",edge[0].from);\n\t\t\t\tedge[nume] . from  = a;\n\t\t\t\tedge[nume] .   to  = b;\n\t\t\t\tedge[nume] .  nxt  = first[a];\n\t\t\t\tedge[nume] .  cap  = c;\n\t\t\t\tedge[nume] . flow  = 0;\n\t\t\t\tfirst[a] = nume++;\n\t\t\t\tedge[nume] . from  = b;\n\t\t\t\tedge[nume] .   to  = a;\n\t\t\t\tedge[nume] .  nxt  = first[b];\n\t\t\t\tedge[nume] .  cap  = 0;\n\t\t\t\tedge[nume] . flow  = 0;\n\t\t\t\tfirst[b] = nume++;\n\t\t\t}\n\t\t\t\n\t\t\tvoid Reset(){\n\t\t\t\tfor (int i=0;i<nume;i++){\n\t\t\t\t\tedge[i].flow = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid init_sap(){\n\t\t\t\tReset();\n\t\t\t\tMax_flow = 0;\n\t\t\t\tmemset(num,0,sizeof(num));\n\t\t\t\tmemset(path,0,sizeof(path));\n\t\t\t\tnum[0] = n;\n\t\t\t\tmemset(dist,0,sizeof(dist));\n\t\t\t\tfor (int i=0;i<n;i++) cur[i] = first[i];\n\t\t\t}\n\n\t\t\tint sap(int s,int t){\n\t\t\t\tmemset(dist,0,sizeof(dist));\n\t\t\t\tint u = s;\n\t\t\t\twhile (dist[s] != n+1){\n\t\t\t\t\tif (u == t){\n\t\t\t\t\t\tint Min_flow = oo;\n\t\t\t\t\t\tint break_point = -1;\n\t\t\t\t\t\tfor (int v = u;v!=s;v=edge[path[v]].from){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (Min_flow >= edge[path[v]].cap - edge[path[v]].flow){\n\t\t\t\t\t\t\t\tMin_flow = edge[path[v]].cap - edge[path[v]].flow;\n\t\t\t\t\t\t\t\tbreak_point = edge[path[v]].from;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMax_flow += Min_flow;\n\t\t\t\t\t\tfor (int v = u;v!=s;v=edge[path[v]].from){\n\t\t\t\t\t\t\tedge[path[v]] . flow += Min_flow;\n\t\t\t\t\t\t\tedge[path[v] ^ 1] . flow -= Min_flow;\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tu = break_point;\n\t\t\t\t\t} else{\n\t\t\t\t\t\tbool found = false;\n\t\t\t\t\t\tfor (int e = cur[u];e!=-1;e=edge[e].nxt){\n\t\t\t\t\t\t\tif ((dist[u] == dist[edge[e].to] + 1) && (edge[e].cap > edge[e].flow)){\n\t\t\t\t\t\t\t\tcur[u] = e;\n\t\t\t\t\t\t\t\tpath[edge[e].to] = e;\n\t\t\t\t\t\t\t\tu = edge[e].to;\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!found){\n\t\t\t\t\t\t\tint tmp = n + 1;\n\t\t\t\t\t\t\tfor (int e=first[u];e!=-1;e=edge[e].nxt)\n\t\t\t\t\t\t\t\tif (edge[e].cap > edge[e].flow){\n\t\t\t\t\t\t\t\t\ttmp = min(tmp,dist[edge[e].to]+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (--num[dist[u]] == 0) return Max_flow;\n\t\t\t\t\t\t\tdist[u] = tmp;\n\t\t\t\t\t\t\tnum[tmp]++;\n\t\t\t\t\t\t\tcur[u] = first[u];\n\t\t\t\t\t\t\tif (u != s) u = edge[path[u]] . from;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Max_flow;\n\t\t\t}\n\t\t;\n}G;\n\nint n,m;\nbool vis[maxv];\nint main(){\n\tint s = 0,t = maxAns *2 + 1;\n\tG.init(maxAns*2+2);\n\tscanf(\"%d\",&n);\n\tG.Reset(); \n\tint i;\n\tfor (i=1;i<=maxAns;i++){\n\t\tG.add_edge(s,i,1);\n\t\tG.add_edge(maxAns + i,t,1);\n\t\tfor (int j=1;j<i;j++){\n\t\t\tint t = (int)sqrt(1.0*(i+j));\n\t\t\tif (t * t == (i+j)){\n\t\t\t\tG.add_edge(j,i + maxAns,1);\n\t\t\t}\n\t\t}\n\t\tint rec = i - G.sap(s,t);\n\t\tif (rec > n){\n\t\t\tbreak;\n\t\t}\n\t}\n\t//Ans = i \n\tint Ans = i-1;\n\n\tfor (int j=0;j<G.nume;j++){\n\t\tif ((G.edge[j].to == i) || (G.edge[j].to == i+maxAns) ||\n\t\t   (G.edge[j].from == i) || (G.edge[j].from == i+maxAns)){\n\t\t   \t\tG.edge[j].cap  = 0;\n\t\t   \t\tG.edge[j].flow = 0;\n\t\t   }\n\t}\n\t\n\tG.Reset(); \n\tG.sap(s,t);\n\t/*\n\tfor (int j=0;j<G.nume;j++){\n\t\tif ((G.edge[j].to == i) || (G.edge[j].to == i+maxAns) ||\n\t\t   (G.edge[j].from == i) || (G.edge[j].from == i+maxAns)){\n\t\t   \t\t\n\t\t   \t\tG.edge[j].cap  = -1;\n\t\t\t\tG.edge[j].flow = -1;\n\t\t\t\tprintf(\"Delete%d-->%d\\n\",G.edge[j].from,G.edge[j].to);\n\t\t   }\n\t}*/\n\tmemset(vis,false,sizeof(vis));\n\tvis[i] = true;\n\tprintf(\"%d\\n\",Ans);\n\tfor (int i=1;i<=Ans;i++){\n\t\tif (vis[i]) continue;\n\t\tint u = i; \n//\t\tprintf(\"find(%d) = %d\\n\",i,u);\n\t\twhile (true){\n//\t\t\tprintf(\"%d,%d \\n\",vis[u],u);\n\t\t\tprintf(\"%d \",u);\n\t\t\tvis[u] = true;\n\t\t\tbool found = false;\n\t\t\tfor (int e=G.first[u];e!=-1;e=G.edge[e].nxt){\n//\t\t\t\tprintf(\"%d--(%d,%d)->%d\\n\",u,G.edge[e].cap,G.edge[e].flow,G.edge[e].to);\n\t\t\t\tif (((e & 1) == 0) && (G.edge[e].cap == G.edge[e].flow) && (!vis[G.edge[e].to - maxAns])){\n\t\t\t\t\tu = G.edge[e].to - maxAns;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) break;\n\t\t}\n//\t\tprintf(\"\\n%d**\",i);\n\t\tputs(\"\");\n\t}\n}\n\n```\n\n","link":"","tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"网络流练习3","date":"2017-08-11T05:40:43.000Z","path":"2017/08/11/网络流24题/第3题/3/","text":"最小路径覆盖问题给定一个DAG，问这个DAG的最小路劲覆盖数，以及哪些最小路劲（任意输出一个） 输入描述 第1 行有2个正整数n和m。n是给定有向无环图G 的顶点数，m是G 的边数。接下来的m行，每行有2 个正整数i和j，表示一条有向边(i,j)。 输出描述 将最小路径覆盖输出。从第1 行开始，每行输出一条路径。文件的最后一行是最少路径数。 样例输入 11 121 21 31 42 53 64 75 86 97 108 119 1110 11 样例输出 1 4 7 10 112 5 83 6 93 数据范围 n&lt;=150,m&lt;=6000 问题模型转化： 将一个点拆开，差成2个点，记为X,X’ 如果1到2有一条边，1到3有一条边，2到3有一条边 相当于建立一副二分图 1到2’有边权为1的边 1到3’有边权为1的边 2到3‘有边权为1的边 如果两个点之间有一条边，意味着两个点可以同时在一条路劲上存在。 因此 DAG最小路劲覆盖数=总点数-一个神奇的二分图的最大匹配。 这里只考虑方案数，因为方案其实只需要做完之后顺着一个点正向反向BFS几一下，然后最长的即可。 下面给出只考虑方案的代码： http://codevs.cn/problem/1904/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;const int maxv = 350;const int maxe = maxv*maxv;const int oo = 1&lt;&lt;30;using namespace std;struct Edge&#123; int from,to,nxt,flow,cap;&#125;;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe * 2]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123;// printf(\"%d --&gt; %d:%d\\n\",a,b,c); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; int sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=0;i&lt;n;i++) cur[i] = first[i]; int u = s; while (dist[s] != n+1)&#123;// printf(\"U = %d --&gt;\",u); if (u == t)&#123;// puts(\"Add\"); int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123;// printf(\"%d %d %d\\n\",v,path[v],edge[path[v]].from); if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123;// printf(\"\\nU = %d --&gt;**\\n\",u); bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e;// printf(\"\\n%d--&gt;path[%d] = %d:%d\\n\",u,edge[e].to,e,edge[e].from); u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;int n,m;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); G.init(2*n+2); int s = 0,t = n*2+1; for (int i=1;i&lt;=m;i++)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); G.add_edge(a,n+b,1); &#125; for (int i=1;i&lt;=n;i++)&#123; G.add_edge(s,i,1); G.add_edge(i+n,t,1); &#125; printf(\"%d\\n\",n - G.sap(s,t));&#125;","raw":"---\ntitle: 网络流练习3\ndate: 2017-08-11 13:40:43\ntags: 网络流\n---\n\n# 最小路径覆盖问题\n\n给定一个DAG，问这个DAG的最小路劲覆盖数，以及哪些最小路劲（任意输出一个）\n\n<!--more-->\n\n输入描述\n\n第1 行有2个正整数n和m。n是给定有向无环图\nG 的顶点数，m是G 的边数。接下来的m行，每行有2 个正整数i和j，表示一条有向边(i,j)。\n\n输出描述\n\n将最小路径覆盖输出。从第1 行开始，每行输出\n一条路径。文件的最后一行是最少路径数。\n\n样例输入\n\n11 12\n1 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 11\n10 11\n\n样例输出\n\n1 4 7 10 11\n2 5 8\n3 6 9\n3\n\n数据范围\n\nn<=150,m<=6000\n\n\n\n问题模型转化：\n\n将一个点拆开，差成2个点，记为X,X'\n\n如果1到2有一条边，1到3有一条边，2到3有一条边\n\n相当于建立一副二分图\n\n1到2'有边权为1的边\n\n1到3'有边权为1的边\n\n2到3‘有边权为1的边\n\n如果两个点之间有一条边，意味着两个点可以同时在一条路劲上存在。\n\n因此\n\nDAG最小路劲覆盖数=总点数-一个神奇的二分图的最大匹配。\n\n这里只考虑方案数，因为方案其实只需要做完之后顺着一个点正向反向BFS几一下，然后最长的即可。\n\n下面给出只考虑方案的代码：\n\n\n\nhttp://codevs.cn/problem/1904/\n\n```cpp\n#include<bits/stdc++.h>\nconst int maxv = 350;\nconst int maxe = maxv*maxv;\nconst int oo = 1<<30;\nusing namespace std;\nstruct Edge{\n\tint from,to,nxt,flow,cap;\n};\nclass Graph{\n\tpublic:\n\t\t\tint first[maxv],n,Max_flow,nume;\n\t\t\tint num[maxv],dist[maxv],cur[maxv];\n\t\t\tint path[maxv];\n\t\t\tEdge edge[maxe * 2];\n\t\t\t\n\t\t\tvoid init(int n){\n\t\t\t\tthis -> n = n;\n\t\t\t\tnume = 0;\n\t\t\t\tmemset(first,-1,sizeof(first));\n\t\t\t}\n\t\t\t\n\t\t\tvoid add_edge(int a,int b,int c){\n//\t\t\t\tprintf(\"%d --> %d:%d\\n\",a,b,c);\n\t\t\t\tedge[nume] . from  = a;\n\t\t\t\tedge[nume] .   to  = b;\n\t\t\t\tedge[nume] .  nxt  = first[a];\n\t\t\t\tedge[nume] .  cap  = c;\n\t\t\t\tedge[nume] . flow  = 0;\n\t\t\t\tfirst[a] = nume++;\n\t\t\t\tedge[nume] . from  = b;\n\t\t\t\tedge[nume] .   to  = a;\n\t\t\t\tedge[nume] .  nxt  = first[b];\n\t\t\t\tedge[nume] .  cap  = 0;\n\t\t\t\tedge[nume] . flow  = 0;\n\t\t\t\tfirst[b] = nume++;\n\t\t\t}\n\t\t\t\n\t\t\tvoid Reset(){\n\t\t\t\tfor (int i=0;i<nume;i++){\n\t\t\t\t\tedge[i].flow = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sap(int s,int t){\n\t\t\t\tReset();\n\t\t\t\tMax_flow = 0;\n\t\t\t\tmemset(num,0,sizeof(num));\n\t\t\t\tnum[0] = n;\n\t\t\t\tmemset(dist,0,sizeof(dist));\n\t\t\t\tfor (int i=0;i<n;i++) cur[i] = first[i];\n\t\t\t\tint u = s;\n\t\t\t\twhile (dist[s] != n+1){\n//\t\t\t\t\tprintf(\"U = %d -->\",u);\n\t\t\t\t\tif (u == t){\n//\t\t\t\t\t\tputs(\"Add\");\n\t\t\t\t\t\tint Min_flow = oo;\n\t\t\t\t\t\tint break_point = -1;\n\t\t\t\t\t\tfor (int v = u;v!=s;v=edge[path[v]].from){\n//\t\t\t\t\t\t\tprintf(\"%d %d %d\\n\",v,path[v],edge[path[v]].from);\n\t\t\t\t\t\t\tif (Min_flow >= edge[path[v]].cap - edge[path[v]].flow){\n\t\t\t\t\t\t\t\tMin_flow = edge[path[v]].cap - edge[path[v]].flow;\n\t\t\t\t\t\t\t\tbreak_point = edge[path[v]].from;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMax_flow += Min_flow;\n\t\t\t\t\t\tfor (int v = u;v!=s;v=edge[path[v]].from){\n\t\t\t\t\t\t\tedge[path[v]] . flow += Min_flow;\n\t\t\t\t\t\t\tedge[path[v] ^ 1] . flow -= Min_flow;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tu = break_point;\n\t\t\t\t\t} else{\n//\t\t\t\t\tprintf(\"\\nU = %d -->**\\n\",u);\n\t\t\t\t\t\tbool found = false;\n\t\t\t\t\t\tfor (int e = cur[u];e!=-1;e=edge[e].nxt){\n\t\t\t\t\t\t\tif ((dist[u] == dist[edge[e].to] + 1) && (edge[e].cap > edge[e].flow)){\n\t\t\t\t\t\t\t\tcur[u] = e;\n\t\t\t\t\t\t\t\tpath[edge[e].to] = e;\n//\t\t\t\t\t\t\t\tprintf(\"\\n%d-->path[%d] = %d:%d\\n\",u,edge[e].to,e,edge[e].from);\n\t\t\t\t\t\t\t\tu = edge[e].to;\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!found){\n\t\t\t\t\t\t\tint tmp = n + 1;\n\t\t\t\t\t\t\tfor (int e=first[u];e!=-1;e=edge[e].nxt)\n\t\t\t\t\t\t\t\tif (edge[e].cap > edge[e].flow){\n\t\t\t\t\t\t\t\t\ttmp = min(tmp,dist[edge[e].to]+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (--num[dist[u]] == 0) return Max_flow;\n\t\t\t\t\t\t\tdist[u] = tmp;\n\t\t\t\t\t\t\tnum[tmp]++;\n\t\t\t\t\t\t\tcur[u] = first[u];\n\t\t\t\t\t\t\tif (u != s) u = edge[path[u]] . from;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Max_flow;\n\t\t\t}\n\t\t;\n}G;\n\nint n,m;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tG.init(2*n+2);\n\tint s = 0,t = n*2+1;\n\tfor (int i=1;i<=m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tG.add_edge(a,n+b,1);\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tG.add_edge(s,i,1);\n\t\tG.add_edge(i+n,t,1);\n\t}\n\tprintf(\"%d\\n\",n - G.sap(s,t));\n}\n```\n\n","link":"","tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"网络流练习2","date":"2017-08-10T13:12:28.000Z","path":"2017/08/10/网络流24题/第2题/2/","text":"最大权闭合子图最大权闭合子图问题，有n个实验，每个实验要一些工具，每个工具需要花费，每个实验可以得到收益，求最大化收益。 W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 E={E1，E2，…，Em}，和进行这些实验需要使用的全部仪器的集合 I={I1， I2，… I n } 。实验 Ej需要用到的仪器是 I 的子集 Rj˝I。配置仪器 Ik的费用为 ck美元。实验 Ej的赞助商已同意为该实验结果支付 pj美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。 对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。 输入描述 Input Description 第 1 行有 2 个正整数 m和 n。m 是实验数，n 是仪器数。接下来的 m 行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的 n 个数是配置每个仪器的费用。 输出描述 Output Description 第 1 行是实验编号；第 2行是仪器编号；最后一行是净收益。 样例输入 Sample Input 2 3 10 1 2 25 2 3 5 6 7 样例输出 Sample Output 1 2 1 2 3 17 这题是典型的最大权闭合子图。 这题我们可以这样考虑如果全部做，不买物品，总收益为S 对于一个实验，要么是实验做（相当于花费购买器械的价格），要么是实验不做（相当于减去这个实验的收益） 然后最后我们要最大化收益，也就是使得花费最小。可以考虑到最小割——&gt;最大流 具体这样建图（样例）： 最后求哪些最小割我是穷举每条边重新跑的，其实没有必要，因为这题有SPJ（不一定字典序最小之类），所以一般只需要重新开始沿着没有被割的边BFS即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;bits/stdc++.h&gt; using namespace std;const int maxv = 150;const int maxe = 30000;struct Edge&#123; int from,to,nxt,cap,flow;&#125;; int Mark[maxv],Sum;bool choice[maxv],C[maxv];const int oo = 1&lt;&lt;25;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123; edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; int sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); memset(dist,0,sizeof(dist)); for (int i=1;i&lt;=n;i++) cur[i] = first[i]; int u = s; while (dist[s] != n+1)&#123; if (u == t)&#123; int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123; if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u!=s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;char c = '.';int read(int x)&#123; while ((!((c&gt;='0') &amp;&amp; (c&lt;='9'))) &amp;&amp; ((c!='\\n') || (x == 1))) c=getchar(); if (c == '\\n') return -1; int a = 0; while ((c&gt;='0') &amp;&amp; (c&lt;='9'))&#123; a = a * 10 + c - 48; c=getchar(); &#125; return a;&#125;int m,n;int Son[maxv][maxv];int main()&#123; m = read(1);n = read(1); Sum = 0; G.init(1+m+n+1); for (int u=1;u&lt;=m;u++)&#123; Son[u][0] = 0; int value = read(1); Sum = Sum + value; G.add_edge(1,1+u,value); for (Son[u][++Son[u][0]] = read(0);Son[u][Son[u][0]]!=-1;Son[u][++Son[u][0]]=read(0))&#123; G.add_edge(1+u,1+m+Son[u][Son[u][0]],oo); &#125; &#125; for (int i=1;i&lt;=n;i++)&#123; int dis = read(1); G.add_edge(1+m+i,1+n+m+1,dis); &#125; int Max_flow = G.sap(1,1+n+m+1); for (int e=G.first[1];e!=-1;e=G.edge[e].nxt) if ((e &amp; 1) == 0)&#123;//如果是正向边 //尝试去掉这条边 int tmp1 = G.edge[e].cap; G.edge[e].cap = 0; int tmp2 = G.sap(1,1+n+m+1); G.edge[e].cap = tmp1; if (G.edge[e].cap - G.edge[e].flow != tmp2) choice[G.edge[e].to-1] = true; &#125; memset(C,0,sizeof(C)); for (int i=1;i&lt;=m;i++)&#123; if (choice[i])&#123; printf(\"%d \",i); for (int j=1;j&lt;=Son[i][0];j++)&#123; C[Son[i][j]] = true; &#125; &#125; &#125; puts(\"\"); for (int i=1;i&lt;=n;i++)&#123; if (C[i]) printf(\"%d \",i); &#125; puts(\"\"); printf(\"%d\\n\",Sum-Max_flow);&#125;/*2 310 1 225 2 35 6 7*/","raw":"---\ntitle: 网络流练习2\ndate: 2017-08-10 21:12:28\ntags: 网络流\n---\n\n# 最大权闭合子图\n\n最大权闭合子图问题，有n个实验，每个实验要一些工具，每个工具需要花费，每个实验可以得到收益，求最大化收益。\n\n<!-- more -->\n\nW 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 E={E1，E2，…，Em}，和进行这些实验需要使用的全部仪器的集合 I={I1， I2，… I n } 。实验 Ej需要用到的仪器是 I 的子集 Rj˝I。配置仪器 Ik的费用为 ck美元。实验 Ej的赞助商已同意为该实验结果支付 pj美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。  \n\n对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。\n\n输入描述 Input Description\n\n第 1 行有 2 个正整数 m和 n。m 是实验数，n 是仪器数。接下来的 m 行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的 n 个数是配置每个仪器的费用。\n\n输出描述 Output Description\n\n第 1 行是实验编号；第 2行是仪器编号；最后一行是净收益。\n\n样例输入 Sample Input\n\n2 3\n\n10 1 2\n\n25 2 3\n\n5 6 7\n\n样例输出 Sample Output\n\n1 2  \n\n1 2 3 \n\n17\n\n\n\n<!-- more --> \n\n这题是典型的最大权闭合子图。\n\n这题我们可以这样考虑如果全部做，不买物品，总收益为S\n\n对于一个实验，要么是实验做（相当于花费购买器械的价格），要么是实验不做（相当于减去这个实验的收益）\n\n然后最后我们要最大化收益，也就是使得花费最小。可以考虑到最小割——>最大流\n\n具体这样建图（样例）：\n\n![img](/_posts/网络流24题/第二题/图片.png) \n\n最后求哪些最小割我是穷举每条边重新跑的，其实没有必要，因为这题有SPJ（不一定字典序最小之类），所以一般只需要重新开始沿着没有被割的边BFS即可。\n\n```cpp\n#include<bits/stdc++.h> \nusing namespace std;\nconst int maxv = 150;\nconst int maxe = 30000;\nstruct Edge{\n\tint from,to,nxt,cap,flow;\n}; \n\nint Mark[maxv],Sum;\nbool choice[maxv],C[maxv];\nconst int oo = 1<<25;\nclass Graph{\n\tpublic:\n\t\t\tint first[maxv],n,Max_flow,nume;\n\t\t\tint num[maxv],dist[maxv],cur[maxv];\n\t\t\tint path[maxv];\n\t\t\tEdge edge[maxe];\n\t\t\t\n\t\t\tvoid init(int n){\n\t\t\t\tthis -> n = n;\n\t\t\t\tnume = 0;\n\t\t\t\tmemset(first,-1,sizeof(first));\n\t\t\t}\n\t\t\t\n\t\t\tvoid add_edge(int a,int b,int c){\n\t\t\t\tedge[nume] . from  = a;\n\t\t\t\tedge[nume] .   to  = b;\n\t\t\t\tedge[nume] .  nxt  = first[a];\n\t\t\t\tedge[nume] .  cap  = c;\n\t\t\t\tedge[nume] . flow  = 0;\n\t\t\t\tfirst[a] = nume++;\n\t\t\t\tedge[nume] . from  = b;\n\t\t\t\tedge[nume] .   to  = a;\n\t\t\t\tedge[nume] .  nxt  = first[b];\n\t\t\t\tedge[nume] .  cap  = 0;\n\t\t\t\tedge[nume] . flow  = 0;\n\t\t\t\tfirst[b] = nume++;\n\t\t\t}\n\t\t\t\n\t\t\tvoid Reset(){\n\t\t\t\tfor (int i=0;i<nume;i++){\n\t\t\t\t\tedge[i].flow = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sap(int s,int t){\n\t\t\t\tReset();\n\t\t\t\tMax_flow = 0;\n\t\t\t\tmemset(num,0,sizeof(num));\n\t\t\t\tmemset(dist,0,sizeof(dist));\n\t\t\t\tfor (int i=1;i<=n;i++) cur[i] = first[i];\n\t\t\t\tint u = s;\n\t\t\t\twhile (dist[s] != n+1){\n\t\t\t\t\tif (u == t){\n\t\t\t\t\t\tint Min_flow = oo;\n\t\t\t\t\t\tint break_point = -1;\n\t\t\t\t\t\tfor (int v = u;v!=s;v=edge[path[v]].from){\n\t\t\t\t\t\t\tif (Min_flow >= edge[path[v]].cap - edge[path[v]].flow){\n\t\t\t\t\t\t\t\tMin_flow = edge[path[v]].cap - edge[path[v]].flow;\n\t\t\t\t\t\t\t\tbreak_point = edge[path[v]].from;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMax_flow += Min_flow;\n\t\t\t\t\t\tfor (int v = u;v!=s;v=edge[path[v]].from){\n\t\t\t\t\t\t\tedge[path[v]] . flow += Min_flow;\n\t\t\t\t\t\t\tedge[path[v] ^ 1] . flow -= Min_flow;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tu = break_point;\n\t\t\t\t\t} else{\n\t\t\t\t\t\tbool found = false;\n\t\t\t\t\t\tfor (int e = cur[u];e!=-1;e=edge[e].nxt){\n\t\t\t\t\t\t\tif ((dist[u] == dist[edge[e].to] + 1) && (edge[e].cap > edge[e].flow)){\n\t\t\t\t\t\t\t\tcur[u] = e;\n\t\t\t\t\t\t\t\tpath[edge[e].to] = e;\n\t\t\t\t\t\t\t\tu = edge[e].to;\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!found){\n\t\t\t\t\t\t\tint tmp = n + 1;\n\t\t\t\t\t\t\tfor (int e=first[u];e!=-1;e=edge[e].nxt)\n\t\t\t\t\t\t\t\tif (edge[e].cap > edge[e].flow){\n\t\t\t\t\t\t\t\t\ttmp = min(tmp,dist[edge[e].to]+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (--num[dist[u]] == 0) return Max_flow;\n\t\t\t\t\t\t\tdist[u] = tmp;\n\t\t\t\t\t\t\tnum[tmp]++;\n\t\t\t\t\t\t\tcur[u] = first[u];\n\t\t\t\t\t\t\tif (u!=s) u = edge[path[u]] . from;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Max_flow;\n\t\t\t}\n\t\t;\n}G;\nchar c = '.';\nint read(int x){\n\twhile ((!((c>='0') && (c<='9'))) && ((c!='\\n') || (x == 1))) c=getchar();\n\tif (c == '\\n') return -1;\n\tint a = 0;\n\twhile ((c>='0') && (c<='9')){\n\t\ta = a * 10 + c - 48;\n\t\tc=getchar();\n\t}\n\treturn a;\n}\nint m,n;\nint Son[maxv][maxv];\nint main(){\n\tm = read(1);n = read(1);\n\tSum = 0;\n\tG.init(1+m+n+1);\n\tfor (int u=1;u<=m;u++){\n\t\tSon[u][0] = 0;\n\t\tint value = read(1);\n\t\tSum = Sum + value;\n\t\tG.add_edge(1,1+u,value);\n\t\tfor (Son[u][++Son[u][0]] = read(0);Son[u][Son[u][0]]!=-1;Son[u][++Son[u][0]]=read(0)){\n\t\t\tG.add_edge(1+u,1+m+Son[u][Son[u][0]],oo);\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tint dis = read(1);\n\t\tG.add_edge(1+m+i,1+n+m+1,dis);\n\t}\n\tint Max_flow = G.sap(1,1+n+m+1);\n\tfor (int e=G.first[1];e!=-1;e=G.edge[e].nxt)\n\t\tif ((e & 1) == 0){//如果是正向边 \n\t\t//尝试去掉这条边\n\t\tint tmp1 = G.edge[e].cap;\n\t\tG.edge[e].cap = 0;\n\t\tint tmp2 =  G.sap(1,1+n+m+1);\n\t\tG.edge[e].cap = tmp1;\n\t\tif (G.edge[e].cap - G.edge[e].flow != tmp2) choice[G.edge[e].to-1] = true;\n\t}\n\tmemset(C,0,sizeof(C));\n\tfor (int i=1;i<=m;i++){\n\t\tif (choice[i]){\n\t\t\tprintf(\"%d \",i);\n\t\t\tfor (int j=1;j<=Son[i][0];j++){\n\t\t\t\tC[Son[i][j]] = true;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"\");\n\tfor (int i=1;i<=n;i++){\n\t\tif (C[i]) printf(\"%d \",i);\n\t}\n\tputs(\"\");\n\tprintf(\"%d\\n\",Sum-Max_flow);\n}\n\n/*\n2 3\n10 1 2\n25 2 3\n5 6 7\n*/\n```\n\n \n\n ","link":"","tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"网络流练习1","date":"2017-08-10T12:36:55.000Z","path":"2017/08/10/网络流24题/第1题/1/","text":"二分图最大匹配问题​ 从前一个和谐的班级，有 nl 个是男生，有 nr 个是女生。编号分别为 1,…,nl 和 1,…,nr。 有若干个这样的条件：第 v 个男生和第 u个女生愿意结为配偶。 请问这个班级里最多产生多少对配偶？ 输入格式第一行三个正整数，nl,nr,m。 ​ 接下来 m 行，每行两个整数 v,u 表示第 v 个男生和第 u 个女生愿意结为配偶。保证 1≤v≤nl1≤v≤nl，1≤u≤nr1≤u≤nr，保证同一个条件不会出现两次。 输出格式第一行一个整数，表示最多产生多少对配偶。 接下来一行 nl个整数，描述一组最优方案。第 v 个整数表示 v 号男生的配偶的编号。如果 v 号男生没配偶请输出 0。 考虑2种做法，第一种是建图+SAP，最后判断哪些边是被流满了的。 如图： 用Dinic或者SAP，速度是比较快的，大概是sqrt(n)*m，但是代码比较长，这里推荐第二种做法：匈牙利 匈牙利算法主要是基于增广路，也就是每次经过男生~女生~男生~女生，一直到一个未匹配的女生，结束，然后两两对应匹配。时间复杂度O(n^3)——邻接表（数组模拟链表）存和邻接矩阵存差不多，下面给出邻接表的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt; const int maxv = 505;int nl,nr,m,ans; int Map[maxv][maxv],link[maxv],Ans[maxv]; bool vis[maxv]; using namespace std; bool Hungary(int u)&#123; for (int v=1;v&lt;=nr;v++)&#123; if (!vis[v] &amp;&amp; Map[u][v])&#123; vis[v] = true; if (link[v] == -1 || Hungary(link[v]))&#123; link[v] = u; return true; &#125; &#125; &#125; return false; &#125; int c,x; int main()&#123; memset(Map,false,sizeof(Map)); scanf(\"%d%d%d\",&amp;nl,&amp;nr,&amp;m); for (int i=1;i&lt;=m;i++)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); Map[a][b] = true; &#125; ans = 0; memset(link,-1,sizeof(link)); for (int k=1;k&lt;=nl;k++)&#123; memset(vis,false,sizeof(vis)); if (Hungary(k)) ans++; &#125; printf(\"%d\\n\",ans); memset(Ans,0,sizeof(Ans)); for (int i=1;i&lt;=nr;i++)&#123; Ans[link[i]] = i; &#125; for (int i=1;i&lt;=nl;i++)&#123; printf(\"%d \",Ans[i]); &#125; return 0; &#125; 推荐在UOJ上提交，事实上各大OJ一般都有。","raw":"---\ntitle: 网络流练习1\ndate: 2017-08-10 20:36:55\ntags: 网络流\n---\n\n# 二分图最大匹配问题\n\n​\t从前一个和谐的班级，有 nl 个是男生，有 nr 个是女生。编号分别为 1,…,nl 和 1,…,nr。\n\n有若干个这样的条件：第 v 个男生和第 u个女生愿意结为配偶。\n\n请问这个班级里最多产生多少对配偶？\n\n<!-- more -->\n\n输入格式\n第一行三个正整数，nl,nr,m。\n\n​\t接下来 m 行，每行两个整数 v,u 表示第 v 个男生和第 u 个女生愿意结为配偶。保证 1≤v≤nl1≤v≤nl，1≤u≤nr1≤u≤nr，保证同一个条件不会出现两次。\n\n输出格式\n第一行一个整数，表示最多产生多少对配偶。\n\n接下来一行 nl个整数，描述一组最优方案。第 v 个整数表示 v 号男生的配偶的编号。如果 v 号男生没配偶请输出 0。\n\n\n\n<!-- more -->\n\n考虑2种做法，第一种是建图+SAP，最后判断哪些边是被流满了的。\n\n如图：\n\n![img](\\_posts\\网络流24题\\第一题\\1.jpg)\n\n用Dinic或者SAP，速度是比较快的，大概是sqrt(n)*m，但是代码比较长，这里推荐第二种做法：匈牙利\n\n匈牙利算法主要是基于增广路，也就是每次经过男生~女生~男生~女生，一直到一个未匹配的女生，结束，然后两两对应匹配。时间复杂度O(n^3)——邻接表（数组模拟链表）存和邻接矩阵存差不多，下面给出邻接表的代码\n\n```cpp\n#include<bits/stdc++.h>  \nconst int maxv = 505;\nint nl,nr,m,ans;  \nint Map[maxv][maxv],link[maxv],Ans[maxv];  \nbool vis[maxv];  \nusing namespace std;  \nbool Hungary(int u){  \n    for (int v=1;v<=nr;v++){  \n        if (!vis[v] && Map[u][v]){  \n            vis[v] = true;  \n            if (link[v] == -1 || Hungary(link[v])){  \n                link[v] = u;  \n                return true;  \n            }  \n        }  \n    }  \n    return false;  \n}  \nint c,x;  \nint main(){  \n    memset(Map,false,sizeof(Map));  \n    scanf(\"%d%d%d\",&nl,&nr,&m);  \n    for (int i=1;i<=m;i++){\n    \tint a,b;\n    \tscanf(\"%d%d\",&a,&b);\n    \tMap[a][b] = true;\n    }\n    ans = 0;  \n    memset(link,-1,sizeof(link));  \n    for (int k=1;k<=nl;k++){  \n        memset(vis,false,sizeof(vis));  \n        if (Hungary(k)) ans++;  \n    }  \n    printf(\"%d\\n\",ans);\n    memset(Ans,0,sizeof(Ans));\n    for (int i=1;i<=nr;i++){\n    \tAns[link[i]] = i;\n    }\n    for (int i=1;i<=nl;i++){\n    \tprintf(\"%d \",Ans[i]);\n    }\n\treturn 0; \n}\n```\n\n推荐在UOJ上提交，事实上各大OJ一般都有。","link":"","tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"SAP算法总结","date":"2017-08-09T12:56:24.000Z","path":"2017/08/09/学习/SAP算法总结/","text":"ISAP算法，一种最大流的优秀算法。 概念1：增广路，不解释 概念2：当前弧​ 对于一个点，必然存在当前要处理的弧，一开始，最早的当前弧是它的第一条弧，然后如果下一次他要到下一条边处理，它的当前弧变成下一条边。 具体实现： ·一开始，先跑一发BFS，得到每一个点到汇点的最短距离，这里用最短距离为n+1表示与汇点不联通。 ·在满足源点到汇点联通的情况下（dist[s] != n+1)，每一个节点从那个节点的当前弧开始跑增广路，跑增广路的时候，保存其当前弧，以及整条增广路的路劲。 ·如果到了节点t，那么从节点t开始，一直到s（也就是遍历整条增广路）得到可以增广的量最少的，同时记录这条边的开始那个节点），记为Min_flow和break_point。 ·对整条增广路上的所有路劲减去Min_flow，并同时从break_point开始继续增广。 ·如果当前节点找不到一个后继节点使得dist[u] +1 = dist[nxt]，那么让dist[u]变成它后继节点的dist的最小值+1，如果没有，或者后继节点都到不了t，那么变为n+1。同时，原先那个层次的点的个数-1，当前这个层次的点的个数+1。这个点的当前弧从第一条弧重新开始（如果原先那个层次没有点，说明有断层，直接return即可） ·一直找，直到出现断层。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt; using namespace std;#define maxv 205#define maxe 205struct Edge&#123; int from,to,cap,flow,nxt; //表示从from到to有一条容量为cap，当前流量为flow的边（数组模拟链表的下一个是nxt） &#125;edge[maxe * 2];//总共有maxe条边，还有maxe条反向边 int nume,first[maxv];//边的数量和某个点开始最早的边 int dist[maxv];//当前点到汇点的dist int n,m,path[maxv],cur[maxv];//节点个数，边的个数，增广路以及当前弧 void init()&#123; nume = 0; memset(first,-1,sizeof(first));&#125;//预处理 void add_edge(int a,int b,int c)&#123; edge[nume] . from = a; edge[nume] . to = b; edge[nume] . cap = c; edge[nume] . flow = 0; edge[nume] . nxt = first[a]; first[a] = nume++; //正边 edge[nume] . from = b; edge[nume] . to = a; edge[nume] . cap = 0; edge[nume] . flow = 0; edge[nume] . nxt = first[b]; first[b] = nume++; //反向边 &#125;const int oo = 1&lt;&lt;20;int ISAP(int s,int t)&#123; int u,v,break_point; int num[maxv]; for (int i=1;i&lt;=n;i++) cur[i] = first[i]; int Ans = 0;// bfs(t);//反向BFS，可以不要。 memset(num,0,sizeof(num)); for (int i=1;i&lt;=n;i++) num[dist[i]] ++;//预处理得到每个层次的数量 u = s;//从源点开始 while (dist[s] &lt; n)&#123; if (u == t)&#123;//找到一条增广路 v = u; int Min_flow = oo; while (v!=s)&#123; int e = path[v]; if (edge[e].cap - edge[e].flow &lt; Min_flow)&#123; Min_flow = edge[e].cap - edge[e].flow; break_point = edge[e] . from; &#125; v = edge[e] . from; &#125;//遍历整个增广路，找到Min_flow和break_point Ans = Ans + Min_flow;//增加答案 v = u; while (v!=s)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; v = edge[path[v]] . from; &#125;//改变整条增广路上的flow。 u = break_point;//回到端点 &#125;//end of (u = t) else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; v = edge[e].to; if ((dist[v] == dist[u] - 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; //找到一条可以走的路（满足是下一个，并且容量大于流量） path[v] = e; cur[u] = e; u = v; found = true; break; &#125; &#125; if (!found)&#123;//Retreat int tmp = n+1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; v = edge[e].to; tmp = min(tmp,dist[v] + 1); &#125;//得到其子节点的所有dist中最小的+1 num[dist[u]]--;//原来层次的点数-1 if ((num[dist[u]]) == 0) return Ans;//断点优化，也叫做GAP优化 dist[u] = tmp;//更新层次 num[tmp] = num[tmp] + 1;//新的层次的点数增加 cur[u] = first[u];//当前弧从头开始 if (u != s) u = edge[path[u]].from;//前面的点也要改过 &#125; &#125; &#125; return Ans;//返回结果 &#125;int main()&#123; init(); scanf(\"%d%d\",&amp;m,&amp;n); for (int i=1;i&lt;=m;i++)&#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); add_edge(a,b,c); &#125; printf(\"%d\\n\",ISAP(1,n));&#125;","raw":"---\ntitle: SAP算法总结\ndate: 2017-08-09 20:56:24\ntags:\n---\n\nISAP算法，一种最大流的优秀算法。\n\n<!-- more -->\n\n概念1：增广路，不解释\n\n概念2：当前弧\n​\t对于一个点，必然存在当前要处理的弧，一开始，最早的当前弧是它的第一条弧，然后如果下一次他要到下一条边处理，它的当前弧变成下一条边。\n\n具体实现：\n\n·一开始，先跑一发BFS，得到每一个点到汇点的最短距离，这里用最短距离为n+1表示与汇点不联通。\n\n·在满足源点到汇点联通的情况下（dist[s] != n+1)，每一个节点从那个节点的当前弧开始跑增广路，跑增广路的时候，保存其当前弧，以及整条增广路的路劲。\n\n·如果到了节点t，那么从节点t开始，一直到s（也就是遍历整条增广路）得到可以增广的量最少的，同时记录这条边的开始那个节点），记为Min_flow和break_point。\n\n![img](/img/1.png)\n\n·对整条增广路上的所有路劲减去Min_flow，并同时从break_point开始继续增广。\n\n·如果当前节点找不到一个后继节点使得dist[u] +1 = dist[nxt]，那么让dist[u]变成它后继节点的dist的最小值+1，如果没有，或者后继节点都到不了t，那么变为n+1。同时，原先那个层次的点的个数-1，当前这个层次的点的个数+1。这个点的当前弧从第一条弧重新开始（如果原先那个层次没有点，说明有断层，直接return即可）\n\n·一直找，直到出现断层。\n\n<!-- more -->\n\n\n\n```cpp\n#include<bits/stdc++.h> \nusing namespace std;\n#define maxv 205\n#define maxe 205\nstruct Edge{\n\tint from,to,cap,flow,nxt;\n\t//表示从from到to有一条容量为cap，当前流量为flow的边（数组模拟链表的下一个是nxt） \n}edge[maxe * 2];\n//总共有maxe条边，还有maxe条反向边 \nint nume,first[maxv];//边的数量和某个点开始最早的边 \nint dist[maxv];//当前点到汇点的dist \nint n,m,path[maxv],cur[maxv];\n//节点个数，边的个数，增广路以及当前弧 \n\nvoid init(){\n\tnume = 0;\n\tmemset(first,-1,sizeof(first));\n}//预处理 \n\nvoid add_edge(int a,int b,int c){\n\tedge[nume] . from = a;\n\tedge[nume] . to   = b;\n\tedge[nume] . cap  = c;\n\tedge[nume] . flow = 0;\n\tedge[nume] . nxt  = first[a];\n\tfirst[a] = nume++;\n\t//正边 \n\tedge[nume] . from = b;\n\tedge[nume] . to   = a;\n\tedge[nume] . cap  = 0;\n\tedge[nume] . flow = 0;\n\tedge[nume] . nxt  = first[b];\n\tfirst[b] = nume++;\n\t//反向边 \n}\n\nconst int oo = 1<<20;\nint ISAP(int s,int t){\n\tint u,v,break_point;\n\tint num[maxv];\n\tfor (int i=1;i<=n;i++) cur[i] = first[i];\n\tint Ans = 0;\n//\tbfs(t);//反向BFS，可以不要。 \n\tmemset(num,0,sizeof(num)); \n\tfor (int i=1;i<=n;i++) num[dist[i]] ++;//预处理得到每个层次的数量\n\tu = s;//从源点开始 \n\twhile (dist[s] < n){\n\t\tif (u == t){//找到一条增广路 \n\t\t\tv = u;\n\t\t\tint Min_flow = oo; \n\t\t\twhile (v!=s){\n\t\t\t\tint e = path[v];\n\t\t\t\tif (edge[e].cap - edge[e].flow < Min_flow){\n\t\t\t\t\tMin_flow = edge[e].cap - edge[e].flow;\n\t\t\t\t\tbreak_point = edge[e] . from;\n\t\t\t\t}\n\t\t\t\tv = edge[e] . from;\n\t\t\t}//遍历整个增广路，找到Min_flow和break_point \n\t\t\t\n\t\t\tAns = Ans + Min_flow;//增加答案 \n\t\t\tv = u; \n\t\t\twhile (v!=s){\n\t\t\t\tedge[path[v]] . flow += Min_flow;\n\t\t\t\tedge[path[v] ^ 1] . flow -= Min_flow;\n\t\t\t\tv = edge[path[v]] . from; \n\t\t\t}//改变整条增广路上的flow。 \n\t\t\tu = break_point;//回到端点 \n\t\t}//end of (u = t) \n\t\telse{\n\t\t\tbool found = false;\n\t\t\tfor (int e = cur[u];e!=-1;e=edge[e].nxt){\n\t\t\t\tv = edge[e].to;\n\t\t\t\tif ((dist[v] == dist[u] - 1) && (edge[e].cap > edge[e].flow)){\n\t\t\t\t\t//找到一条可以走的路（满足是下一个，并且容量大于流量） \n\t\t\t\t\tpath[v] = e;\n\t\t\t\t\tcur[u] = e;\n\t\t\t\t\tu = v;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found){//Retreat\n\t\t\t\tint tmp = n+1; \n\t\t\t\tfor (int e=first[u];e!=-1;e=edge[e].nxt)\n\t\t\t\t\tif (edge[e].cap > edge[e].flow){\n\t\t\t\t\t\tv = edge[e].to; \n\t\t\t\t\t\ttmp = min(tmp,dist[v] + 1);\n\t\t\t\t\t}//得到其子节点的所有dist中最小的+1\n\t\t\t\t\t \n\t\t\t\tnum[dist[u]]--;//原来层次的点数-1 \n\t\t\t\tif ((num[dist[u]]) == 0) return Ans;//断点优化，也叫做GAP优化 \n\t\t\t\tdist[u] = tmp;//更新层次 \n\t\t\t\tnum[tmp] = num[tmp] + 1;//新的层次的点数增加 \n\t\t\t\tcur[u] = first[u];//当前弧从头开始 \n\t\t\t\tif (u != s) u = edge[path[u]].from;//前面的点也要改过 \n\t\t\t}\n\t\t}\n\t}\n\treturn Ans;//返回结果 \n}\n\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&m,&n);\n\tfor (int i=1;i<=m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tadd_edge(a,b,c);\n\t}\n\tprintf(\"%d\\n\",ISAP(1,n));\n}\n```\n\n","link":"","tags":[]}]