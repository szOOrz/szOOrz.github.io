{"meta":{"title":"Emoairx","subtitle":null,"description":"OI Lover","author":"EMOAIRX","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2017-08-29T05:49:28.211Z","updated":"2017-08-29T05:49:28.211Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"试题库问题","slug":"OI/网络流24题/第7题/7","date":"2017-11-16T10:31:59.549Z","updated":"2017-11-16T12:45:54.900Z","comments":true,"path":"2017/11/16/OI/网络流24题/第7题/7/","link":"","permalink":"http://yoursite.com/2017/11/16/OI/网络流24题/第7题/7/","excerpt":"","text":"提交地址：https://www.luogu.org/problemnew/show/P2763，https://loj.ac/problem/6006`不解为什么过不了`等 题目描述假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。 输入格式第 $1$ 行有 $2$ 个正整数 $k$ 和 $n$ 。$k$ 表示题库中试题类型总数，$n$ 表示题库中试题总数。第 $2$ 行有 $k$ 个正整数，第 $i$ 个正整数表示要选出的类型 $i$ 的题数。这 $k$ 个数相加就是要选出的总题数 $m$。 接下来的 $n$ 行给出了题库中每个试题的类型信息。每行的第 $1$ 个正整数 $p$ 表明该题可以属于 $p$ 类，接着的 $p$ 个数是该题所属的类型号。 输出格式第 $i$ 行输出 $i:$ 后接类型 $i$ 的题号。如果有多个满足要求的方案，只要输出一个方案。如果问题无解，则输出 No Solution!。 样例样例输入12345678910111213141516173 153 3 42 1 21 31 31 31 33 1 2 32 2 32 1 31 21 22 1 22 1 32 1 21 13 1 2 3 样例输出1231: 1 6 82: 7 9 103: 2 3 4 5 数据范围与提示$2≤k≤20,k≤n≤1000$ 做法这题类似一种套路题。 怎么处理呢？ 我们从源点到每一个题目一条容量为1的边，每个题目到相应类别一条容量为1的边，相应类别到汇点容量为响应需要数的边，然后跑一遍最大流。 考虑如果最大流不是m，那么No solution 否则的话，考虑哪些是可行的，可以通过寻找哪些类别和题目之间的边是相连的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std;const int maxn = 1005;struct Edge&#123; int from,to,nxt,cap,flow;&#125;;struct Graph&#123; Edge edge[maxn*maxn*2]; int first[maxn],cur[maxn],path[maxn],nume,dist[maxn],cnt[maxn]; static const int inf = 0x3fffffff; int N;//总的节点数(0~N-1) void init(int x)&#123; N = x;// printf(\"%d---\",N); nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123; edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++;// printf(\"%d , %d %d\\n\",a,b,c); &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++) edge[i].flow = 0; &#125; int SAP(int s,int t)&#123; int u,v,Max_flow,Min_flow; Reset(); memset(dist,0,sizeof(dist)); memset(cnt,0,sizeof(cnt)); for (int i=0;i&lt;N;i++) cur[i] = first[i]; cnt[0] = N; u = s; Max_flow = 0; while (dist[s]!=N+1)&#123;// printf(\"%d(%d)\\n\",u,dist[u]); if (u==t)&#123; Min_flow = inf; for (int v=u;v!=s;v=edge[path[v]].from)&#123; Min_flow = min(Min_flow,edge[path[v]].cap - edge[path[v]].flow); &#125; Max_flow += Min_flow; for (int v=u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]].flow += Min_flow; edge[path[v]^1].flow -= Min_flow; &#125; u = s; &#125;else&#123; bool found = false; for (int &amp;e=cur[u];~e;e=edge[e].nxt)&#123; if (dist[edge[e].to]+1==dist[u]&amp;&amp;edge[e].cap&gt;edge[e].flow)&#123; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = N+1; for (int e=first[u];~e;e=edge[e].nxt)&#123; if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; &#125; cnt[dist[u]]--; if (cnt[dist[u]] == 0) return Max_flow; dist[u] = tmp; cnt[dist[u]]++; cur[u] = first[u]; if (u!=s) u = edge[path[u]].from; &#125; &#125; &#125; return Max_flow; &#125;&#125;G;int k,n,x,p;int Ans[21][1005];int main()&#123; scanf(\"%d%d\",&amp;k,&amp;n); G.init(k+n+2); int sum = 0; for (int i=1;i&lt;=k;i++)&#123; scanf(\"%d\",&amp;x); G.add_edge(n+i,n+k+1,x); sum+=x; &#125; for (int i=1;i&lt;=n;i++)&#123; G.add_edge(0,i,1); scanf(\"%d\",&amp;p); while (p--)&#123; scanf(\"%d\",&amp;x); G.add_edge(i,n+x,1); &#125; &#125; x = G.SAP(0,n+k+1); if (x!=sum)&#123;puts(\"No Solution!\");return 0;&#125; memset(Ans,0,sizeof(Ans)); for (int i=1;i&lt;=n;i++)&#123; for (int e=G.first[i];~e;e=G.edge[e].nxt)&#123; if (G.edge[e].cap==G.edge[e].flow)&#123; int v = G.edge[e].to - n; Ans[v][++Ans[v][0]] = i; &#125; &#125; &#125; for (int i=1;i&lt;=k;i++)&#123; sort(Ans[i],Ans[i]); &#125; for (int i=1;i&lt;=k;i++)&#123; printf(\"%d:\",i); for (int j=1;j&lt;=Ans[i][0];j++)&#123; printf(\" %d\",Ans[i][j]); &#125; puts(\"\"); &#125; return 0; &#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"最长不下降子序列","slug":"OI/网络流24题/第6题/6","date":"2017-11-14T10:51:30.432Z","updated":"2017-11-16T12:45:40.977Z","comments":true,"path":"2017/11/14/OI/网络流24题/第6题/6/","link":"","permalink":"http://yoursite.com/2017/11/14/OI/网络流24题/第6题/6/","excerpt":"","text":"题目描述注：网上是最长递增子序列，但是好像都要是等于，所以干脆把题目改成最长不下降子序列了。 下面出现的递增，均看作不下降即可。 提交地址：http://codevs.cn/problem/1906/，https://www.luogu.org/problemnew/show/2766等 给定正整数序列x1,…,xn 。求 （1）计算其最长递增子序列的长度s。 （2）计算从给定的序列中最多可取出多少个长度为s的递增子序列。 （3）如果允许在取出的序列中多次使用x1和xn，则从给定序列中最多可取出多少个长度为s的递增子序列。 输入输出格式输入格式： 第1 行有1个正整数n，表示给定序列的长度。接下来的1 行有n个正整数n:x1, …, xn。 输出格式： 第1 行是最长递增子序列的长度s。第2行是可取出的长度为s 的递增子序列个数。第3行是允许在取出的序列中多次使用x1和xn时可取出的长度为s 的递增子序列个数。 输入输出样例输入样例： 1243 6 2 5 输出样例： 123223 说明$n≤500$ 做法：第一问是经典的DP，可以n log n解决，也可以直接N^2。不累赘。 对于有多少个可以的。——网络流 注意到每一个点只能被用一次，这非常重要。 我们把每个点拆成2个，左边的向右边的连一条容量为1的边。 对于$dp[i]$和$dp[j]$，满足$i$能转移到$j$($dp[j]=dp[i]+1$，并且$a[i]&lt;=a[j]$)，那么在$i$的第二个点到$j$的第一个点建立一条长度为1的边，然后对于$dp[i]=1$的，从S点到这个点的第一个点一条无穷大的边，如果$dp[i]=Ans1$的，从这个点的第二个点到T点一条无穷大的边。 对于问题2，只需要把1,n这两个点自己之间的边权改成无穷大即可，可以通过直接加边快速实现。 跑最大流，比如说SAP。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std;const int maxn = 1305;int n,LIS,dp[maxn],a[maxn];struct Edge&#123; int from,to,nxt,cap,flow;&#125;;struct Graph&#123; Edge edge[maxn*maxn*2]; int first[maxn],cur[maxn],path[maxn],nume,dist[maxn],cnt[maxn]; static const int inf = 0x3fffffff; int N;//总的节点数(0~N-1) ， void init(int x)&#123; N = x; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123; edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++) edge[i].flow = 0; &#125; int SAP(int s,int t)&#123; int u,v,Max_flow,Min_flow; Reset(); memset(dist,0,sizeof(dist)); memset(cnt,0,sizeof(cnt)); for (int i=0;i&lt;N;i++) cur[i] = first[i]; cnt[0] = N; u = s; Max_flow = 0; while (dist[s]!=N+1)&#123;//把N打成n好惨。// printf(\"%d(%d)\\n\",u,dist[u]); if (u==t)&#123; Min_flow = inf; for (int v=u;v!=s;v=edge[path[v]].from)&#123; Min_flow = min(Min_flow,edge[path[v]].cap - edge[path[v]].flow); &#125; Max_flow += Min_flow; for (int v=u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]].flow += Min_flow; edge[path[v]^1].flow -= Min_flow; &#125; u = s; &#125;else&#123; bool found = false; for (int &amp;e=cur[u];~e;e=edge[e].nxt)&#123; if (dist[edge[e].to]+1==dist[u]&amp;&amp;edge[e].cap&gt;edge[e].flow)&#123; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = N+1; for (int e=first[u];~e;e=edge[e].nxt)&#123; if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; &#125; cnt[dist[u]]--; if (cnt[dist[u]] == 0) return Max_flow; dist[u] = tmp; cnt[dist[u]]++; cur[u] = first[u]; if (u!=s) u = edge[path[u]].from; &#125; &#125; &#125; return Max_flow; &#125;&#125;G;int main()&#123; scanf(\"%d\",&amp;n); dp[0] = 0; LIS = 0; for (int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); dp[i] = 0; for (int j=0;j&lt;i;j++) if (a[i] &gt;= a[j]) dp[i] = max(dp[i],dp[j]+1); LIS = max(LIS,dp[i]); &#125; printf(\"%d\\n\",LIS); if (LIS == 1)&#123;printf(\"%d\\n%d\\n\",n,n);return 0;&#125; G.init(n+n+2); int s = 0,t = n*2+1; for (int i=1;i&lt;=n;i++)&#123; if (dp[i]==1) G.add_edge(0,i,10000000); for (int j=1;j&lt;i;j++)&#123; if (dp[i] == dp[j] + 1 &amp;&amp; a[i] &gt;= a[j])&#123; G.add_edge(j+n,i,1); &#125; &#125; if (dp[i] == LIS) G.add_edge(i+n,2*n+1,10000000); G.add_edge(i,i+n,1); &#125; printf(\"%d\\n\",G.SAP(s,t)); G.add_edge(1,1+n,10000000); G.add_edge(n,n+n,10000000); printf(\"%d\\n\",G.SAP(s,t));&#125;/*网上有的数据怎么都是最长不下降子序列——坑惨*/","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"","slug":"OI/NOIP/国王游戏/国王游戏做法","date":"2017-11-04T09:10:54.296Z","updated":"2017-11-04T09:50:02.191Z","comments":true,"path":"2017/11/04/OI/NOIP/国王游戏/国王游戏做法/","link":"","permalink":"http://yoursite.com/2017/11/04/OI/NOIP/国王游戏/国王游戏做法/","excerpt":"","text":"���ǿ���S��ʾ�����˵����ֵĳ˻� ���ǲ���������ĳһ��˳�������ŵ� $A[1] A[2] A[3] A[4] A[5]����$ $B[1] B[2] B[3] B[4] B[5]����$ �𰸵Ĺ�����:��$C[1] = A[1] B[1] ;C[2]= A[1] A[2] B[1] ;C[3] = A[1] A[2] A[3] B[3] , ��������max$ �����и��ŵ�һ�ֽ⣬������$i$��$j$$(i&lt;j)$ ��ô����$i$֮ǰ��$j$֮���Ķ���û��Ӱ���� ������$$\\large T = \\prod _{k=1}^{i-1} A[k]$$ ��ô�м���һ�ε�ÿһ��ֵ�Ĺ��׶��ֱ������ˣ� ��$i$���Ĺ��ױ�����$C’[i] = C[i] B[j] A[i] / (A[i] * B[i])$ ��$j$���Ĺ��ױ�����$C’[j] = C[j] B[j] / A[i] A[j] / B[i]$ $= C[j] * (A[j] * B[j] ) / (A[i] * B[i])$ �м�����Щ�Ĺ��ױ����� $C’[k] = C[k] A[j] B[i] / (A[i] *B[i])$ ��������֮�е�����ֵ�ǶԴ𰸵Ĺ���֮һ ����$i$��$j$ ����$C[i] &gt; C[j]$ ��$A[i]B[i]&gt;A[j]B[j]$��ʱ��","categories":[],"tags":[]},{"title":"","slug":"OI/BZOJ/3143/BZOJ5043","date":"2017-10-26T13:55:30.329Z","updated":"2017-10-26T13:56:14.965Z","comments":true,"path":"2017/10/26/OI/BZOJ/3143/BZOJ5043/","link":"","permalink":"http://yoursite.com/2017/10/26/OI/BZOJ/3143/BZOJ5043/","excerpt":"","text":"这题考虑each edge的经过期望，可以通过每一个点的期望算，每一个点的期望可以高斯消元来做。","categories":[],"tags":[]},{"title":"","slug":"OI/Codeforces/NO725/CF725E","date":"2017-10-07T08:09:50.906Z","updated":"2017-10-07T08:10:48.183Z","comments":true,"path":"2017/10/07/OI/Codeforces/NO725/CF725E/","link":"","permalink":"http://yoursite.com/2017/10/07/OI/Codeforces/NO725/CF725E/","excerpt":"","text":"选多个值不如选一个值，因为选了多个值","categories":[],"tags":[{"name":"-codeforces - 贪心","slug":"codeforces-贪心","permalink":"http://yoursite.com/tags/codeforces-贪心/"}]},{"title":"有限","slug":"杂谈/有限","date":"2017-10-06T07:52:48.761Z","updated":"2017-10-06T08:18:59.062Z","comments":true,"path":"2017/10/06/杂谈/有限/","link":"","permalink":"http://yoursite.com/2017/10/06/杂谈/有限/","excerpt":"","text":"1、求&lt;=n的水仙花数的个数(n &lt;= 10^(10^5)) ​ 三位的水仙花数共有4个：153，370，371，407； ​ 四位的四叶玫瑰数共有3个：1634，8208，9474； ​ 五位的五角星数共有3个：54748，92727，93084； ​ 六位的六合数只有1个：548834； ​ 七位的北斗七星数共有4个：1741725，4210818，9800817，9926315； ​ 八位的八仙花数共有3个：24678050，24678051，88593477 这题似乎有点无从着手，但是 ​ 最大的水仙花数有39位。十进制自然数中的所有水仙花数共有88个。 ​ 其实这也不难发现，因为总存在一个N，使得9^(N+1) &lt;= 10 ^ N ​ 是的，是有限的。 2、求&lt;=n的雪球素数的个数(n &lt;= 10^8) ​ 这题，不难用$trie$（或者$DFS$）很快的可以解决. ​ 可是若是(n&lt;=10^9呢？) ​ 不难发现，分块打表是一个好方法 ​ 可是若是(n&lt;=10^18呢？) 当n&lt;=10^9的时候，最大的雪球素数是$73939133$ 当n&lt;=10^18的时候，最大的雪球素数是$73939133$ 事实上，由上面一句话，我们已经可以猜到，当n趋向无穷大的时候，小于等于n的最大的雪球素数就是73939133 是的，他是有限的。 ​ 我们常常赞叹大自然的神奇——素数是无限的，可是却总有那么多有限的有趣的数字。 与无限相对的，是有限。 ​ $\\Large\\frac {\\sum \\times\\prod }{True?False}$ 这里留下一个问题 ​ 1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1+1-1……是多少","categories":[],"tags":[{"name":"乱七八糟","slug":"乱七八糟","permalink":"http://yoursite.com/tags/乱七八糟/"}]},{"title":"CF868","slug":"OI/Codeforces/868/Codeforces Round #438","date":"2017-10-05T11:54:52.054Z","updated":"2017-10-05T12:03:49.343Z","comments":true,"path":"2017/10/05/OI/Codeforces/868/Codeforces Round #438/","link":"","permalink":"http://yoursite.com/2017/10/05/OI/Codeforces/868/Codeforces Round #438/","excerpt":"","text":"Codeforces Round #438 by Sberbank and Barcelona Bootcamp (Div. 1 + Div. 2 combined) 这是一场失败的比赛，C题WA了3次，B题FST。 第一题：注意到只有2个元素，那就乱搞 第二题：建相邻的边然后跑floyd，可惜有这么多的错误： 1、数组应该开13开成了12 2、分针是直接除以5，但是如果是0应该变成12. 第三题：只需要考虑两个就行了。 然后我很麻烦的分类讨论 事实上只需要for i:=0 to 16 do然后&amp;一下是不是0就行了啊！ 我的算法，因为循环应该是0~3，而我打成1~4错了一次。多判断了只有一个的，错了一次，然后…………………… 这场比赛，充分暴露了我的不足。 至于D题没写完，F题看上去是四边形不等式优化（虽然我并不会神奇的DP优化方法） A题代码 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char x[10],y[10],n;int main()&#123; scanf(\"%s\",&amp;x); scanf(\"%d\",&amp;n); bool f1 = false,f2 = false; for (int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",&amp;y); if (y[0] == x[0] &amp;&amp; y[1] == x[1])&#123; puts(\"YES\"); return 0; &#125; if (y[1] == x[0]) f1 = true; if (y[0] == x[1]) f2 = true; &#125; if (f1 &amp;&amp; f2) puts(\"YES\"); else puts(\"NO\"); return 0;&#125; B题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;int dist[13][13];int pre(int x)&#123; if (x == 1) return 12; else return x-1;&#125;int nxt(int x)&#123; if (x == 12) return 1; else return x+1;&#125;int h,m,s,t1,t2;int main()&#123; scanf(\"%d%d%d%d%d\",&amp;h,&amp;m,&amp;s,&amp;t1,&amp;t2);// printf(\"h = %d\\n\",h); memset(dist,0,sizeof(dist)); for (int i=1;i&lt;=12;i++)&#123; dist[i][nxt(i)] = 1; dist[nxt(i)][i] = 1; dist[i][i] = 1; &#125;// printf(\"h = %d\\n\",h);/* for (int i=1;i&lt;=12;i++)&#123; for (int j=1;j&lt;=12;j++)&#123; printf(\"%d %d:%d\\n\",i,j,dist[i][j]); &#125; &#125;*/ // printf(\"h = %d\\n\",h); if (m == 0 &amp;&amp; s == 0)&#123; dist[pre(h)][h] = 0; dist[h][pre(h)] = 0; dist[nxt(h)][h] = 0; dist[h][nxt(h)] = 0; &#125; else&#123; dist[nxt(h)][h] = 0; dist[h][nxt(h)] = 0;// printf(\"(%d)(%d)\\n\",h,nxt(h)); &#125; if (m % 5 == 0 &amp;&amp; s == 0)&#123; m /= 5; if (m == 0) m = 12; dist[pre(m)][m] = 0; dist[m][pre(m)] = 0; dist[nxt(m)][m] = 0; dist[m][nxt(m)] = 0; &#125; else&#123; m /= 5; if (m == 0) m = 12; dist[nxt(m)][m] = 0; dist[m][nxt(m)] = 0; &#125; if (s % 5 == 0)&#123; s /= 5; if (s == 0) s = 12; dist[pre(s)][s] = 0; dist[s][pre(s)] = 0; dist[nxt(s)][s] = 0; dist[s][nxt(s)] = 0; &#125; else&#123; s /= 5; if (s == 0) s = 12; dist[nxt(s)][s] = 0; dist[s][nxt(s)] = 0; &#125; // for (int i=1;i&lt;=12;i++)&#123;// if (dist[pre(i)][i]) printf(\"%d-&gt;%d:%d\\n\",pre(i),i,dist[pre(i)][i]);// &#125; for (int k=1;k&lt;=12;k++)&#123; for (int i=1;i&lt;=12;i++)&#123; for (int j=1;j&lt;=12;j++)&#123; if (dist[i][k]==1 &amp;&amp; dist[k][j]==1) dist[i][j] = 1; &#125; &#125; &#125;// for (int i=1;i&lt;=12;i++)&#123;// for (int j=1;j&lt;=12;j++)&#123;// printf(\"%d %d:%d\\n\",i,j,dist[i][j]);// &#125;// &#125; if (dist[t1][t2]) puts(\"YES\"); else puts(\"NO\"); return 0;&#125; C题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;using namespace std;int Encode(int a = 0,int b = 0,int c = 0,int d = 0)&#123; return d * 8 + c * 4 + b * 2 + a;&#125;int N,K,a[1000],t;int main()&#123; scanf(\"%d%d\",&amp;N,&amp;K); memset(a,0,sizeof(a)); for (int i=1;i&lt;=N;i++)&#123; t = 0; for (int j=1;j&lt;=K;j++)&#123; int x; scanf(\"%d\",&amp;x); t = t * 2 + x; &#125; a[t] ++; &#125; if (K == 1)&#123; if (a[0]) puts(\"YES\"); else puts(\"NO\"); return 0; &#125; if (K == 2)&#123; if (a[Encode(0,0)]) puts(\"YES\"); else if (a[Encode(1,0)] &amp;&amp; a[Encode(0,1)]) puts(\"YES\"); else puts(\"NO\"); return 0; &#125; if (K == 3)&#123; if (a[Encode(0,0,0)]) puts(\"YES\"); else if (a[Encode(0,0,1)] &amp;&amp; a[Encode(0,1,0)]) puts(\"YES\"); else if (a[Encode(0,0,1)] &amp;&amp; a[Encode(1,0,0)]) puts(\"YES\"); else if (a[Encode(1,0,0)] &amp;&amp; a[Encode(0,1,0)]) puts(\"YES\"); else if (a[Encode(1,1,0)] &amp;&amp; a[Encode(0,0,1)]) puts(\"YES\"); else if (a[Encode(1,0,1)] &amp;&amp; a[Encode(0,1,0)]) puts(\"YES\"); else if (a[Encode(0,1,1)] &amp;&amp; a[Encode(1,0,0)]) puts(\"YES\"); else puts(\"NO\"); return 0; &#125; if (K == 4)&#123; if (a[Encode(0,0,0)]) &#123;puts(\"YES\");return 0;&#125; for (int i=0;i&lt;4;i++)&#123; for (int j=0;j&lt;4;j++)&#123; if (i == j) continue; if (a[1&lt;&lt;i] &amp;&amp; a[1&lt;&lt;j]) &#123;puts(\"YES\");return 0;&#125; &#125; &#125; for (int i=0;i&lt;4;i++)&#123; for (int j=0;j&lt;4;j++)&#123; for (int k=0;k&lt;4;k++)&#123; if (i == j) continue; if (i == k) continue; if (j == k) continue; if (a[(1&lt;&lt;i) + (1&lt;&lt;j)] &amp;&amp; a[1&lt;&lt;k]) &#123;puts(\"YES\");return 0;&#125;// if (a[(1&lt;&lt;i) + (1&lt;&lt;j) + (1&lt;&lt;k)]) &#123;puts(\"YES\");return 0;&#125; &#125; &#125; &#125; for (int i=0;i&lt;4;i++)&#123; for (int j=0;j&lt;4;j++)&#123; for (int k=0;k&lt;4;k++)&#123; for (int l=0;l&lt;4;l++)&#123; if (i == j || i == k || j == k || i == l || j == l || k == l) continue; if (a[(1&lt;&lt;i) + (1&lt;&lt;j)] &amp;&amp; a[(1&lt;&lt;k) + (1&lt;&lt;l)]) &#123;puts(\"YES\");return 0;&#125; if (a[(1&lt;&lt;i) + (1&lt;&lt;j) + (1&lt;&lt;k)] &amp;&amp; a[(1&lt;&lt;l)]) &#123;puts(\"YES\");return 0;&#125;// if (a[(1&lt;&lt;i) + (1&lt;&lt;j) + (1&lt;&lt;k) + (1&lt;&lt;l)]) &#123;puts(\"YES\");return 0;&#125; &#125; &#125; &#125; &#125; &#125; puts(\"NO\"); return 0;&#125; 至于我的代码是多么的冗长，我也不知道了。 还是祝愿我NOIP能有个好成绩。","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"我好弱啊","slug":"OI/USACO/月赛/USACO月赛","date":"2017-10-02T03:53:24.235Z","updated":"2017-10-02T03:57:44.097Z","comments":true,"path":"2017/10/02/OI/USACO/月赛/USACO月赛/","link":"","permalink":"http://yoursite.com/2017/10/02/OI/USACO/月赛/USACO月赛/","excerpt":"","text":"USACO 2002 February 题目名称 题目描述 算法 Fiber Communications N个人围成一个环，有M对人想要联系，但每次只能连接相邻两个人。问要满足这M对关系最少要连接几条边。 枚举每个可能的断点i 然后扫描每一条线j ，对于先left~right，如果两者有小于i的，先加上n，然后将f[min(left,right)]+1，f[max(left,right)+1]-1 就是类似线段覆盖的样子。判断没有被覆盖过的点的个数 然后扫描一遍n，对前缀和为0的，tot加一，最后tot求得的是最大断点。 Power Hungry Cows 初始时只有X和1，每次你能从现有的两个数中选两个(可以重复)，通过乘或者除替换掉其中某个数。问最少要操作几次能得到X^P。 BFS，用一个flag数组标记有没有遍历过，一开始加入1,0，然后有很多种分支。如果入队的等于n，那么输出。值得一提的是，我们保存的时候把一个分为两部分，一部分是大的，一部分是小的，大的不会超过40000，因为剩余的都是无效的，小的不会超过200 Cow Cycling 有N头奶牛，他们需要跑D圈，刚开始每头奶牛的体力值都为E。如果跑X圈，那么领跑的奶牛每分钟消耗的体力为X*X，后面的奶牛每分钟消耗的体力是X。求跑完这D圈最少需要的时间。 用F[i,j,k]表示第i头牛领头，领头的牛的能量为j，跑了k圈，需要的最短时间。我们可以知道，不管是后面的先带头还是前面的先带头是一样的，因此，我们假设带头的人是按顺序的。1、领导人交换则f[i,E-k,k]=min(f[i-1,j,k])\\ 0&lt;=j&lt;E\\ 2、那么我如果要跑t圈，那么F[i,j-tt,k+t]=min(f[i,j-tt,k+t],f[i,j,k]+1);，因为转移是多次的，即可以不同的转移，因此，对于j我们倒着枚举，因为t是大于等于1的，所以k不会自身转移，当然前提是j-t*t&gt;=0最后输出的是，f[i,j,D]中的最大值，第三维一定是D，因为如果大于D，必然有消耗更少的能量，到达D的方式。 Rebuilding Roads 有一棵树，你需要砍掉一些边得到一棵节点个数为P的子树。问最少需要砍掉几条边。 用于bfs求深度 //dp[i,j]表示第i个节点，如果子树节点个数为j，最小需要分割几次。 //要么是子树y砍掉了，即： //要么是子树y没砍掉， 注意要防止重复。值得一提的是，假设一棵n个节点的树中有k0个叶节点，k1个有一个儿子的结点……ki个有i个儿子的结点，那么k00+k11+……+ki*i……=n-1，因此，枚举子节点和枚举所有节点，加起来的时间复杂度还是线性的。 Triangular Pastures 有N条长度为Li的线段，你要用这些线段拼出一个三角形，使得这个三角形面积最大。求最大面积。 设dp[j][k]表示长度为j和k能组成那么对于第i条线，要么dp[j+a[k]][k]=true;dp[j][k+a[i]]=true;所有小棒一定要用上，所以可以求得第三条判断能否组成三角形利用海伦公式求出面积。 Chores 有N个任务，除了任务1以外的其他任务都有一些任务需要在这个任务之前完成。求完成所有任务至少需要多少时间。 DP，表示做到这个需要的最短时间，DP[i]=max{DP[k]}+T[i]，其中，k是所有i的前缀。 Dessert 你要在数字1..N之间插入’+’,’-’或者’.’，使得最后的结果为0。 DFS，保存当前的数，当前位置，以及前面的符号，要注意的是，和两位数连接的话，要乘的不是10，而是100. Extra Krunch 给一句话，要求你把这句话缩减，使得不出现元音字母，而且每个字母如果不是第一次出现就删掉。 细节很多很多很多！ BUY LOW,BUY LOWER 求不同的最长下降子序列的长度和个数。不能重复。 dp数组保存到i位置的最长长度。 num[i]保存长度为dp[i]的子序列，到i为止，这种有多少个 为了防止重复，在程序中加一个特判，即dp的时候，倒着枚举（从i-1到1枚举），如果扫描到一个，h和i的h相等，并且我当前的这个和之前这一段还是1，也就是会和前面那个重复，这时候去掉后面那个，也就是让i的num数组赋值为0，并且不管当前是否只有1跳出循环。（如果不跳的话，哪怕前面有更优的，必然重复） USACO 2003 Fall 题目名称 题目描述 算法 Cow Exhibition 有N对数字(Ai,Bi)，你要选出几对数字，设TS=sigma(Aj)，TF=sigma(Bj)，求TS,TF&gt;=0的情况下TS+TF的最大值。 算法1：用DP[i][j]表示到前i个中，左边的和为j，右边最大的和是多少，可以通过01背包转移。2、因为类似01背包，压缩成滚动数组，根据s[i]是正的倒的分别处理。3、因为有负数，先全部加上100000.4、最后求解。 Milking Grid 给出一个字母矩阵，要求找出最小的子矩阵，使得这个子矩阵经过无限复制扩张之后包含原来的矩阵。 Popular Cows N个点的有向图，找出所有能被其他点都能到达的点。 首先，我们需要知道一个叫做Tarjan的算法，所谓Tarjan，是通过dfs来找强连通块的。那么，我们找到了强连通块，然后我们只需要找出出度为0的点，如果有多个，就说明有几个强连通块不能连在一起，所以不行，如果有1个，那么这一个点所包含的所有点都是满足条件的，如果没有——那是不可能的。我们这里需要用数组模拟链表。Tarjan算法。 Beauty Contest 求最远点对。 Cow Laundry 第1行的A[i]连接到了第2行的B[i]。每次只能交换相邻的两个。求最少要交换几次才能使A[i]=B[i]。 用线段树求逆序对即可。其中逆序对是指B中排列的方式与A中逆的。 Romeo Meets Juliet 有N头奶牛在吃草，有P块草坪。你要找到最长的连续草坪，这草坪内奶牛的数目不超过C。(同一块草坪内可能有多个奶牛) ISBN 一个长度为10的数字串，每一位的数字都是0~9，最后一位可以是0~10。如果sigma(i*num[i])能被11整除，那么它就是ISBN。现在去掉了其中的某一位，求出这一位，使得它成为ISBN。 按照题目意思模拟 USACO 2003 February 题目名称 题目描述 算法 Cow Math 求出所有从1到2的路径的长度的最大公约数的最小公倍数。 Cow Imposters 有一个目标串和几个现有的串。你要找出你现有的串通过XOR运算能够得到的最接近目标串的串。 Traffic Lights 在一条直道上，有些位置上有红绿灯。如果你遇到了红灯那么你就要停下来直到绿灯。你可以在第整数秒时刻改变速度，而且速度改变量都是1。如果遇到红灯了，你的速度一定要变为0。求到达终点时速度为0的最少时间。 Farm Tour 找一条最短的从1到N再从N到1的路，路不能重复走（无向图）。 可以很容易得证明，第一次走的一定是最短路，第二次走的一定是在去掉第一次走的之后的最短路，因此可以跑spfa即可。。——没写 Vertical Histogram 统计每个字母出现的次数。 按照题目统计，PS：字符其实就是一个数字，一般按照其ascal码转换，可以直接用的。要找出每一行最后一个在哪儿，完了之后就不要有空格了。 Cowties 有N头奶牛，现在要把它们连成一个环，1-2-3-…-N-1。每头奶牛都要在自己喜欢的位置上。求把它们连成环的最小长度。 Travel Games 给你一个串和一个单词表。每次你能在串中任何位置插入一个字符，使得这个串在单词表中是存在的。求能变成的最长的串。 USACO 2003 March 题目名称 题目描述 算法 Best Cow Fences 有一个长度为N的序列，你要找出一个连续子序列，使得这个子序列的平均值最大，而且这个子序列的长度要大于等于F。 Cornfields 一个N*N的网格，每个格子都有一个海拔高度。有K个询问，询问以(x,y)为坐上角，以B为边长的正方形中最高海拔高度与最低海拔高度的差是多少。B是一个固定的数。 单调队列2次（n^2)，求出以i,j为顶点的扩展后的最大值和最小值，保存在数组中，输出只需要O(1)调用即可。 Six Degrees of Cowvin Bacon 有N头奶牛和M场电影。如果两头奶牛看过同一场电影，那么它们之间的距离就是1。否则就是它们之间的最短距离。删去一个点的代价是它与其他所有点的总距离和。求最小的代价。 Herd Sums 求存在多少种几个连续正整数的和为n。 共枚举15次，对于每一次，分奇偶性讨论，如果可以分成k个数字，并且最小的数字也大于0，那么结果就加一。 Message Decowding 输入对应的密码表，以及密码，请根据密码表求出对应的原码 模拟，字符串处理用gets获得字符串，然后枚举所有位（strlen），要判断大小写。 USACO 2003 U S Open 题目名称 题目描述 算法 Mountain Walking N*N的网格，每个格子有一个高度。你要从(1,1)走到(N,N)，求最小的高度差。高度差是指这条路径中最高的与最低的差。 二分答案，枚举下界，然后BFS，时间复杂度100110100*log 110，远远不超 Millenium Leapcow N*N的格子，每个格子都有一个数值。现在有一个骑士，每次只能跳到比现在所在格子数值大的格子，求最长的路径。如果有多组解，输出字典序最小的。 Optimal Milking 有K个机器和C头奶牛，每个机器都可以“加工”M头奶牛。奶牛要被加工就要从走到那个机器里。求走得最远的奶牛的最小距离。 Bale Figures 给你一个正方体的放法，求出暴露在外面的面积。 Jumping Cows 有N个数字，你要按顺序取。使得第奇数个取的数字和减去第偶数个取的数字和的差最大。 设f[i,0]表示前i个数，取到当前为偶数个的最高高度。f[i,1]表示前i个数，取到当前为奇数个的最高高度，那么很容易得到 f[i][0]=max(f[i-1][0],f[i-1][1]-h[i])f[i][1]=max(f[i-1][1],f[i-1][0]+h[i])其中, f[0][0]=0;f[0][1]=-oo;最后要求的结果是f[n,0]和f[n,1]中的最大值。 Lost Cows 有一个序列1..N，你知道每一位之前有几个数字比它小，还原这个序列。 首先，对于所有可能的1~n全部赋值为1，然后，倒着搜索，对于每个输入的a[i]，求出第a[i]+1个1，那么结果就是这个位置，然后把这个位置赋值成0，这里可以用二分搜索优化，保存前缀和，找到最小的前缀和等于a[i]+1的，同时，前缀和又可以用树状数组优化，所以时间复杂度为O(n log n log n) Bovine Math Geniuses 一次操作是将一个六位数取中间四位，然后平方，在取后六位，直到出现循环了。求出开始循环的这个数，循环长度与操作几次后开始循环的。 直接模拟，弄一个数组标记是第几次弄到这个数，一开始全部赋值为-1。 USACO 2004 December 题目名称 题目描述 算法 Dividing the Path 在一个长为L的线段上要装洒水机，洒水机的射程是[A,B]。还有N个区间，这些区间都必须被同一个洒水机覆盖。求最少要装几个洒水机，这些洒水机覆盖整个线段，且任意两个洒水机的不重叠。 Fence Obstacle Course 有N个栅栏，你要从S点走到点(0,0)。每次只能沿着栅栏走，走到尽头后一直往下走，直到碰到栅栏，然后再走到栅栏的尽头……求走到点(0,0)横方向至少要走几步。 Cow Ski Area 奶牛要滑雪，只能从高的地方滑到低的地方(高度相同也可以)。现在你要装滑雪电梯，滑雪电梯可以连接任意两个点。求最少要装几个才能使得任意两点之间都能互相到达。 Cleaning Shifts 有N个区间，求至少要几个区间才能覆盖[1,T]。 Bad Cowtractors 最大生成树。 用最小生成树类似的算法，但是排序的时候从大到小排序。 Tree Cutting 求在一棵树上有哪些节点删掉后，剩下的那些部分的结点个数都不超过总结点的一半。 USACO 2004 February 题目名称 题目描述 算法 Navigation Nightmare 平面上有一棵树。有K个询问，F1,F2,I，表示仅连接前I条边的时候F1和F2的曼哈顿距离是多少，如果此时这两个点还未连接，那么输出-1。 Cow Marathon 求树的最长路(直径）。 Distance Queries 求树上两点间的距离。 Distance Statistics 求树上距离小于M的点对数量。 USACO 2004 March 题目名称 题目描述 算法 Moo University – Team Tryouts 有N个数对(Hi,Wi)，求最多可以取出几对数，使得取出来的数满足A(Hi-h)+B(Wi-w)&lt;=C。h和w是取出来的数中的Hi和Wi的最小值。 Moo University - Emergency Pizza Order 有C个人，T种物品，每人都有自己喜爱的物品。你要给这些人每人K种他们喜爱的物品，且任意两个人的物品不全相同。求最多可以满足多少人。 Moo University - Financial Aid 有C个数对(Ai,Bi)，你要选出N(N为奇数)个数，使得这N个数的中位数最大且sigma(Bj)值不超过F。 USACO 2004 November 题目名称 题目描述 算法 Apple Catching 有两个格子，在时间1-T秒内每一秒都有一个苹果会落到其中的某个格子中。你现在要去接这些苹果，但你最多只能移动W次。求最多能拿到多少苹果。 DPdp[i][j][k]表示第i分钟，表示在j树下，走了k步，接到的最大苹果数 ，状态转移方程：Dp[i][j][0]=dp[i-1][j][0]+temp dp[i][j][k]=max(dp[i-1][j][k]+temp,dp[i-1][3-j][k-1]+(1-temp));其中temp表示当前分钟这棵树下有没有苹果。 Lake Counting 有一张N*M的图，找出有几个连通块。 基础DFS，对连通块进行遍历。如果要重新遍历，说明是一个新的，ans加一。 Til the Cows Come Home 求1到N的最短路。 SPFA或者迪杰斯特拉，但是注意边是双向的！ Who’s in the Middle 求中位数。 输入之后，对每一个值进行标记，然后从1到1000000扫一遍，每次加上当前值的个数，如果加上之后大于等于(n-1)/2了，那么说明这个数就是要求的。 Bull Math 两个数相乘。——高精度 纯高精度乘法，两重循环 Bank Interest 现在你有M元钱，每年你都可以得到R%的利润，问Y年后你有多少钱。 进行Y次循环，每次乘上(1+R),最后得到的结果输出即可。 USACO 2004 U S Open 题目名称 题目描述 算法 Cube Stacking 以开始有N个立方体。现在有两种操作，一种是将X所在的那堆叠放到Y所在那堆上面，第二种是询问X下面有几个立方体。 并查集，每次保存每一列的方块数，每一个方块最上面的方块，该方块上面还有几个方块。 The Cow Lineup 有一个序列，你要找出一个长度最短的序列，使得这个序列不是原序列的子序列。求这个长度。 首先，我们清楚一个事实，就是假如整个序列，可以最多分成a部分（连续），每一部分，都包含1~k（如果末尾有些不包含，那就舍去），那么，长度为a的所有都是可行的。比如说1，2，……，k-1，k 3，4，……k-1，k， 1,2，3,4……k-1，k只能分为2部分，一部分是前面1~k，第二部分是3~2，最后一部分，显然是多余的，不能算a 那么这个2就是答案。对于本题，我们的做法是，一个一个读进来，如果1~k都读到了，tot加一，然后再重新读……一直读到结束，最后输出tot+1 MooFest 有N头奶牛，奶牛在位置Xi，且它的发声响度是Vi。奶牛i和奶牛j交流需要的能量是它们之间的距离*max(Vi,Vj)。求它们两两之间都要交流所需要的总能量。 照听力排序，然后对于每一头牛，分两部分处理，一部分是它前面的牛，一部分是它后面的牛，因此，我们用2个树状数组，分别保存数量和这一区间内牛的x的前缀和，当然还要加一个总的前缀和，然后我们就通过这些数据，推出ans要累加的值。 ——当然，要long long Turning in Homework 一个教师要去教室收作业，教室的位置是Pi，每个教室的作业都要在Ti以后才能收。教师的速度是每单位时间走单位长度。求至少要多少时间才能收完所有作业，而且走到位置B。 USACO 2005 December 题目名称 题目描述 算法 Alignment of the Planets 平面上N个点，求三点共线的点有几组。 Finding Boving Roots 求最小的数，这个数开根号以后小数点后L位与给的数相同。 Cow Bowling 找一条从上到下的路，使得路径上的总和最大。 倒着DP，每次选左下角或者右下角2条路中最大的一条，然后加上去。最后输出头的结果 Cow Patterns 两个序列相同的定义：长度相同，任意两位数字的关系一样。关系是指’&lt;’,’=’,’&gt;’。求一个序列有多少个子串是与另一个序列相同的。 Barn Expansion 平面上有N个不相交的矩形，但能相碰。求有多少个矩形能向外扩张(四条边能同时向外移一段距离)。 Layout 直线上有N个点，有ML个关系A B D，表示A和B之间的距离不能超过D，有MD个关系A B D，表示A和B之间的距离不能小于D。点i不能在点i+1的右边。求1和N可能的最大距离。 Kinghts of Ni 有一张N*M的地图，2是你的出发点，3是你的终点。你要从出发点到达某个4，然后再到达终点。求最少需要的步数。 Cleaning Shifts 有N头奶牛，如果你雇佣这头奶牛，那么它会在时刻T1到T2之间工作，费用为S。求在M到E之间每个时刻都至少有一头奶牛工作的最小费用。 先按照T1排序，然后用f[i]表示以排序后第i头奶牛为结束时刻，所需要的费用。状态转移即可。 Scales 有一些砝码，求用这些砝码能得到的最大的不超过C的重量是多少？W[i]+W[i+1]&lt;=W[i+2] USACO 2005 February 题目名称 题目描述 算法 Jersey Politics Secret Milking Machine Aggressive cows Part Acquisition Rigging the Bovine Election USACO 2005 January 题目名称 题目描述 算法 Muddy Fields RC的矩阵里，有些格子有‘’，你要用最少的木板，将这些‘*’都覆盖，且不能覆盖‘.’。 The Wedding Juicer 在N*M的格子上，每个格子都有一个高度。求一场大雨后这个矩阵中有多少积水。 Naptime 有N个数字，它们是环状的。你要取B个数字。每一段你取的第一个数字的得分是不计入的。求最多的得分。 、 Sumsets 求将N分成几个2的整数幂的和的总数。 设f[n]为n分成的总数。递推对于n为奇数F[n]=f[n-1];对于n是偶数F[n]=f[n-1]+f[n div 2]; Watchcow 一张无向图，每条边可以被走两次(正反各一次)。求一条欧拉路。 Moo Volume 数轴上有N个点，求任意两点的距离总和。 排序之后Dp[i]=dp[i-1]+(i-1)*a[i]-sum[i]每次加上这一段线段的N倍（假设所有比这个小的其它点都在O点），然后减去应该减的（多加的）。最后这个结果要乘2 USACO 2005 March 题目名称 题目描述 算法 Ombrophobic Bovines 有F个牛棚，每个牛棚里刚开始有Ai头牛，但只能容纳Bi头牛，所以有些牛要到别的牛棚里去。求牛要走的最大距离的最小值。 Space Elevator 你有K种砖块，每种砖块高度为Hi，有Ci个，且最大高度不超过Ai。求能达到的最大高度。 Yogurt factory 有N天，每天制造牛奶的费用是Ci，需要的牛奶是Yi。如果这天制造的牛奶多下来了，就可以存在仓库里，但每天每单位存牛奶的费用S。求满足这N天需要的牛奶的最小费用。 Checking an Alibi 有F个牛棚，P条边。有C头牛在不同的牛棚里。找出所有的能在时间M内到达牛棚1的牛。 Out of hay 有N个节点，M条边。你要保留一些边，使得这个图连通且最大的边最小。 USACO 2005 November 题目名称 题目描述 算法 Securing the Barn 有N个字母，你要选出其中M个字母，将它们升序排列组成一个字符串，且它们之中至少有一个为元音字母。 Hopscotch 一个5*5的矩阵，可以从任意一个格子出发，每次能走到相邻的格子，走5补，得到一个6位数(格子可以重复走)。求不同的6位数有几个。 Satellite Photographs 一张NM的图，找一个’‘最多的连通块。 Asteroids 有一个N*N的网格，有些格子上有东东。每次能将某一行或某一列上的所有东东都A掉。A完所有东东最少需要几次。 最小点覆盖问题，转化为最大匹配问题，用匈牙利算法解。 Grazing on the Run 数轴上有N个点，出发点在L，速度是1。设在时间Ti走到点i。求sigma(Ti)的最小值。 Walk the Talk 有一个N*M的字符矩阵，还有一些单词表。可以从任意位置出发，每次只能往右上方跳。求能得到多少个在单词表中出现过的字符串。 City Skyline 长为W，有N中不同的高度。从Wi开始高度为Hi。求有多少个不能再扩大了的矩阵。 Cow Acrobats 有N头奶牛，每头奶牛都有一个重量Wi和承受力Si。一头奶牛站在一头奶牛上面，那么每头奶牛就有一个风险值就是在它上面的奶牛的总重量减去它的承受力。求一种方案，使得最大的风险值最小。 Ant Counting 有N个数字，数字都是1..T。求大小在A到B之间的集合有几个。 USACO 2005 October 题目名称 题目描述 算法 Bovine Birthday Max Factor Skiing Flying Right Close Encounter Allowance USACO 2005 U S Open 题目名称 题目描述 算法 Lazy Cows 在2*B的矩形里，有N个格子里有Cow,你要用K个矩形去覆盖它们。求最小的矩形面积和。 dp[i,j,k]表示到第i列（离散化之后），状态为j，总共用了k个牛棚，最少覆盖面积 Case j{0:上下都没被覆盖 (不存在） 1:上面被覆盖，下面没有被覆盖 2:上面没有被覆盖，下面被覆盖 3:上下都被（2个）牛棚覆盖4:上下都被同一个牛棚覆盖 }分类讨论转移，比较繁琐，另外，初始化的时候注意0和0x0f是完全不同的两个概念 Expedition 直线上有N个加油站，每个加油站离城市Di，有油Ei。你现在距离城市L，有油P。求最少要在几个加油站加油才能到达城市。 考虑用一个堆贪心，每次加能走到的最多可以增加的油。 Around the world 一个圆周上有N个点，有M条边，如果两个点之间有边相连，那么它们之间的边就是小于180度的那段。求最少要经过几条边使得从点1开始一圈回到自己。 Landscaping 有一座山，你要砍掉最少的石头，使得这座山的山峰个数不多于K个。 Waves 在某些时刻在水的某些位置中扔了石头，求在R时刻水波的样子。 Navigating the City 一张(2N-1)(2*M-1)的图，你要从S点走到E点。只能走到‘+’的地方，并且要有‘-’或者‘\\ ’相连。输出最短的路径。 Disease Management 有D种疾病，你要选出尽量多的牛，使得这些牛所带的疾病种类总数不超过K个。 Muddy roads 有N个区间，你要用长度为L的木条去将这些区间全部覆盖。求最少要几条木条。 USACO 2006 December 题目名称 题目描述 算法 Parkside’s Triangle 数字从S开始，一列一列地填。 如题，模拟，当i=j的时候，就需要换列了。 Wormholes 农场里有N个田地，田地之间有M条路径相连，这些路径是正的。还有W条路径相连，这些路径是负的。求是否存在负权环。 用SPFA判负环，因为一个点最多入队n-1次，如果入队n次，就说明有负环，注意的是，前面M条路是双向的，后面W条路是单向的。 The Fewest Coins 有N种钱，价值为Vi，有Ci张。要买价值为T的东东，付出的钱的张数+找回的钱的张数总和最少是多少。 Milk Patterns 一个长度为N的序列，求重复次数&gt;=K的最长的子串。(重复可以有重叠) Cow Picnic 有N个农场，M条有向边。有K头奶牛在某些农场里。求有多少个农场是这K头奶牛都能到达的。 Cow Roller Coaster 有N个区间[Xi,Xi+Wi)，代价是Ci，可供娱乐程度为Fi。现在要用这些区间完全覆盖[0,L)，区间之间不能有重叠，并且区间代价和不超过B。求最大的可供娱乐程度。 River Hopscotch 离出发点L的地方是目标位置，中间N个石头，这些石头都是需要经过的，并且不能往回跳。求拿掉M个石头后，路径中的最短距离最大是多少。 USACO 2006 February 题目名称 题目描述 算法 The Moronic Cowmpouter DNA Assembly Cow Phrasebook Cellphones Steady Cow Assignment Treats for the Cows Backward Digit Sums Stall Reservations USACO 2006 January 题目名称 题目描述 算法 Stump Removal Finicky Grazers The Water Bowls Redundant Paths Roping the Field Corral the Cows The Cow Prom Dollar Dayz The Grove USACO 2006 November 题目名称 题目描述 算法 Fence Repair 有N条木棍，长度为Li，你要用长度为sigma(Li)的木条截出这些木棍，每次截的代价就是你截的木棍的长度。求最小代价和。 把切割想象成合并，每次合并最小的两个，可以转换为贪心，维护两个单调队列，一个原来的数，一个合并了之后的数。 Corn Fields 一个N*M的田地，1表示可以选择种植。选择种植了的田地不能有相邻的。求有几种选择方式。 Roadblocks 求1到N的次短路。 Bad Hair Day 有N头奶牛，奶牛i高为Hi，它们站成一排。如果iHj且不存在Hk(i&lt;k&lt;j),那么奶牛i就能看到奶j，设Ci为奶牛i能看到的奶牛总数。求sigma(Ci)。 首先，题目要读清楚，如果是相等也是算阻隔的！我们换个方向思考，每头牛能被多少牛看到，那么显然是之前比这头牛高的。因此，我们可以建立一个递减（注意是递减，不是非递增）的单调栈，每次维护这个栈，先维护，然后每次加上这个栈的元素个数（栈里的都是可以看到Cow i的）。最后，我们只需要输出结果就行了。PS：用long long，int会超。 Big Square 一个N*N的田地，有些位置上有‘J’，有些位置上有‘B’。现在能再放上去一个‘J’。求最大的正方形，正方形的四个定点都是‘J’。正方形的边不一定要与X轴或Y轴平行。 Round Numbers 求A到B之间Round Numbers有几个。Round Numbers就是写成二进制后0的个数不少于1的个数。 dp[i][j][k]表示二进制下长度为i，有至少超过j个0，第一个1在从右往左第k位出现的roundnumber的个数，然后数位DP，即记忆化DFS即可。 USACO 2007 December 题目名称 题目描述 算法 Bookshelf 有N头奶牛，奶牛高Hi。求最少要几头奶牛，它们的高度和不小于B。 贪心。能选最高度最高的牛就选高度最高的牛。首先来一个快排。然后，用sum一直累加从高到低的牛的高度h[i]，如果大于等于b了，那么就输出i，并跳出。 Bookshelf2 有N头奶牛，奶牛高Hi。求高度和超过B的最小高度。 Card Stacking 有N头牛和K张卡片。其中有M=K/N张卡片是好的，K-M张是坏的。这N头牛围成一个环。求要将这些好牌放在哪些位置，使得这些好牌都发给了发牌人。 Sightseeing Cows 有L个点和P条有向边，每个点有权值Fi，每条边代价为Ti。求从任意点出发回到这个点的最大的sigma(Fi)/sigma(Ti)值。 Gourmet Grazers 有N头奶牛，第i头奶牛要求食物的价钱不低于Ai，鲜嫩程度不低于Bi。有M份食物，第i份食物价钱为Ci，鲜嫩程度为Di。求满足所有奶牛最少的需要多少钱。 Best Cow Line,Gold 一个长度为N的字符串，每次只能从这个串的头或尾去掉一个字符。求字典序最小的删除字符串的方案。 Charm Bracelet 有N块宝石，每块宝石重Wi，能增加魅力值Di。求重量和&lt;=M时的最大魅力值。 01背包这里用滚动数组外面套一个i的循环，里面j的倒着的循环if (j-w[i]&gt;0) Dp[j]=max(dp[j],dp[j-w[i]]+d[i]) Building Roads 有N个农场，其中有M对已经有边相连。求最少还要连边的总长度，使得任意两个农场之间都能到达。 Mud Puddles USACO 2007 February 题目名称 题目描述 算法 Building A New Barn 有N个牛棚，现在要多增加一个牛棚，使得这个牛棚和其他所有牛棚的manhattan距离和最小，且这个牛棚不能和其他牛棚重叠。输出这个最小值和方案数。 Cow Sorting 有一个序列，要将其变成一个升序序列。每次可以交换任意两个数字，代价为这两个数字的和。求最小的总代价。 Lilypad Pond M*N的池塘，1是石头，2是荷叶，3是起点，4是终点。只能跳马步的，并且只能跳到有荷叶第地方。求最少要加几个荷叶，才能从终点跳到起点，并输出方案总数。 The Cow Lexicon 有一个长度为L的字符串和N个单词。求最少要去掉几个字符，才能使这个字符串分解成单词。 Silver Cow Party 有N个农场，每个农场里都有一头奶牛，有M条有向边。每个奶牛都要从自己的农场出发，到达农场P，然后回到自己的农场。求用时最多的奶牛至少要用时多少。 两次求SPFA最短路，一次是去的路线，一次是回的路线。由于路是单向的，我们把输入的转化为2个图，第一个图是它的反向边（这样的话，等下SPFA可以直接从X开始，然后可以求得到达X的各个点需要的值），再第二次SPFA，就是返回需要的值。两次累加，求最大值就是所需要输出的答案。 USACO 2007 January 题目名称 题目描述 算法 Problem Solving 有P个问题要解决，解决某个问题需要预先支付Ai，解决以后需要再支付Bi。每个月会有M元，这些问题需要按顺序被解决。求最少需要几个月。 Cow School 有N场考试，第i场考试总分为Pi，得分为Ti。对于一个D，去掉Ti/Pi最小的D个，然后求sigma(Ti)/sigma(Pi)。对于每个0&lt;=D&lt;=N，求是否存在另一种方案比这个更优，输出所有的D。 Protecting the Flowers 有N头牛，将第i头牛每单位时间的破坏力是Di，送回牛棚需要Ti的时间，然后再用Ti的时间返回。求最少的破坏总和。 Tallest Cow 有N头牛，最高的是第I头，高度为H。有R条信息，第A头牛能看到第B头牛，也就是A与B之间的牛都比第A头牛矮，且第B头牛的高度不小于第A头牛。求每头牛的最大可能高度。 Balanced Lineup 有N头牛，第i头牛高度为Hi。有Q个询问，第A头牛到第B头牛之间最大高度与最小高度的差。 线段树，总共分为2个部分：第一部分，建树（小的和大的），第二部分，查找（小的和大的。数据得开4倍（一倍是树的构造，另外还要乘一倍是为了防溢出）），不过，由于空间有限，这里的线段树用2N的空间复杂度（保存的时候类似完全二叉树一样保存） USACO 2007 March 题目名称 题目描述 算法 Gold Balanced Lineup 有N个奶牛，K种特征，每个奶牛用一个数字来表示它所拥有的特征。如果一个子串是平衡的，那么这段奶牛中每个特征出现的次数都是相同的。求最长的平衡子串。 Ranking the Cows 有N个数字，已经知道了M对大小关系，问至少还要再比较多少对数才能把N个数字有序排列起来。 Face The Right Way 有N头奶牛，初始状态为F或B。每次能改变连续K个奶牛的状态。求用最少的操作次数，使得所有的奶牛都为F，并确定最小的K。 Cow Traffic 有N个点和M条有向边，边都是从i-&gt;j(i&lt;j)的。可以从任意一个无入度的点出发，到达N。求经过次数最多的边。 Monthly Expense 有N个数字，要将它们分成M组，每组都是连续的几个数字。要使数字和最大的组最小。 二分结果，最小是所有数的最大值，最大是所有数的总和，约等于1000000000。然后得到的值代进去验证，所以时间复杂度是log sumn≈30n,不会超。如果可行，那么right改变（同时记录最小可能值），否则left改变 USACO 2007 November 题目名称 题目描述 算法 Exploration 有N个位置，有T分钟的时间。从0位置开始，每次走到与0位置最进的没有被走到过的地方。求能走过多少个地方。 Speed Reading 书有N页，奶牛有K头。每头奶牛的读书速度是Si页/分，一次能连续读Ti分钟，之后需要休息Ri分钟。求每头牛读完这本书的时间。 模拟，如果可以读一个在周期，就读一个周期，否则一天一天读。最后得到输出。 Avoid The Lakes N*M的矩形中，有K个格子里有水。求最大的由水组成的连通块的大小。 BFS，求最大连通块的数量 Telephone Wire 有N个数字，总代价为所有两个数字差的绝对值*C。可以增大某些数字，如果这个数字被增大了X，那么代价就是X^2。求最小的代价和。 Cow Relays 有T条边的无向图，求经过N条边的从S到E的最短路。 离散化+矩阵乘法，类似于矩阵乘法的做法，因为最短路是满足结合律的。 Sunscreen 有C头奶牛，第i头奶牛适合的范围在minSPFi与maxSPFi之间。有L瓶防晒霜，值为SPFi，能供coveri头奶牛使用。求最多能满足的奶牛数量。 Cow Hurdles 有N个点，M条有向边，有T个询问，询问从Ai到Bi的路径上边权最大的最小值。 Milking Time 有N个小时，有M个挤奶时间段，从Ai开始到Bi结束，能得到Ci的奶。每次挤奶后要休息R小时。求最多可以挤多少奶。 Best Cow Line 一个长度为N的字符串，每次只能从这个串的头或尾去掉一个字符。求字典序最小的删除字符串的方案。 USACO 2007 Open 题目名称 题目描述 算法 Cheapest Palindrome 通过插入或删除字母将一个串变成回文串的最小代价。 考虑用f[i,j]表示把(i~j)这一段改成回文串最少代价是多少对于f[i,i]，f[i,i+1]直接算出，然后转移。 Dining 有N头奶牛，F种食品和D种饮料。每头奶牛都有自己喜爱的食品和饮料。要满足一头奶牛需要给这头奶牛它喜爱的食品和饮料各一种。而且每种食品和饮料都只能给一头奶牛。问最多可以满足多少头奶牛。 City Horizon 在x轴上有一些矩形，底边是从A[i]到B[i]，高度为H[i]。求这些矩形的面积并。 离散化+线段树，延迟标记，保存大的。最后把延迟标记全部推到子节点，然后累加就行了。要开longlong Catch That Cow 对于数字X，你有三种操作方法。X-1，X+1和2*X。问最少要操作几次能将N变成K。 进行BFS，不过要判断是否超出一定范围，超出一定范围可以确定一定是错的（零~一百万） Fliptile 有一个N*M的01矩阵，你要将它变成全0矩阵。如果对某个格子操作，那么这个格子及它四周的四个格子都要改变。问最少要操作几次，输出字典序最小的。 1、每个最多只会按一次。2、穷举第一行开关灯的情况，然后对于下面的其它行，可以知道，上面一个如果没关灯，这一个一定要按，否则一定不按，所以时间复杂度是2^15的枚举1514的验证。 USACO 2008 February 题目名称 题目描述 算法 Dining Cows 同Eating Together，数值只会是1或2，并且要使这个序列是非降序列。 正反两次DP，分别是正着来到i为止如果全部是1要动几次，倒着来同理。方程很好转移，就是从前一个继承过来，并判断需不需要增加1，最后求的时候，对0~n进行枚举，得到左边和右边的和。注意，一定要枚举到n，并且从0开始。因为两边都可能不变。 Long Distance Racing 每一段路都是上坡，平地或下坡中的一种。上坡时间需要U，平地时间需要F，下坡时间需要D。求在规定时间内最多能跑到多远然后回到出发点。 模拟，——注意，如果是上坡，回去的时候就变成下坡了。如果一直满足，输出t Cow Multiplication 定义一个符号‘’， AB等于一个取自A、一个取自B的所有数字对的乘积的和。计算A*B。 根据乘法分配律，求出A中所有和，B中所有和，两者相乘。（可以用getchar()） Making the Grade 一个数列A1,A2..AN。你需要求一个数列B，B序列是个不上升或不下降序列。求最小的sigma\\ Ai-Bi\\ 。 Hotel 你需要支持下列两种操作：询问第一次出现长度为D的连续空房间的位置，并将这些房间填满。将从X开始的连续D个房间清空。 Game of Lines 平面上有N个点，连接任意两个点都可以得到一条直线。求这些直线中不平行的有多少条。 考虑N^2暴力求出所有线段，然后按照斜率排序，注意斜率为无穷大要特判，还有要强制转化! Meteor Shower 有M颗流星要落到农场上，第i颗流星会在时刻Ti落在坐标为(Xi,Yi)的格子里，从Ti时刻起，这个格子以及相邻的四个格子都无法行走了。求从点(0,0)出发至少要经过多少时间才能到达一个安全的格子。 Eating Together 有N个数字，数值为1或2或3。求至少要改变多少个数字才能使得这个序列变成非降或非升序列。 用dp[i,1],dp[i,2],dp[i,3]表示从1~i，当前为1，2，3，最少要动几次，做两次，分别递增和递减。 USACO 2008 January 题目名称 题目描述 算法 Costume Party 有N头奶牛，每头奶牛长为Li。如果两头奶牛的长度和不超过S，那么她们就能穿下一套服装。求做多匹配数量 排序+二分查找先从小到大排序，然后查找出不大于s-L[i]的数，然后加上能加的个数。 Election Time 有N头奶牛候选，她们在第一轮中的期望得票数为Ai，在第二轮中的期望得票数为Bi。第一轮的前K名进入第二轮，在第二轮中得票最多的奶牛获得最终胜利。求那头胜利的奶牛的编号。 先对n头奶牛根据a排序，然后再找出1~k中最大的b的那个编号（保存编号） iCow 有N首歌曲，每首歌曲有一个Ri值。每一轮先选出Ri值最大的那首(如果有相同，选编号小的)，然后将这个值平均分给其他N-1首歌曲，它本身清零。如果无法被平分，那么就给编号前面。求每次播放的是那首歌。 模拟，对于不能整除的，先全部都加上整数部分，然后余数一个一个加过去，直到没有。 Artificial Lake 有N个平台，每个平台有一个高度和宽度。先选出一个高度最低的，然后从这里开始滴水。求出每个平台被淹没了1m的时间。 用h[i],r[i]表示它没被淹没前，它前面的平台和后面的平台，假设当前水要淹没平台Now，那么ans[now]=time+w[now]，然后再淹没一直到等于左边的平台高度或者右边的，时间加上去，然后右边的左边等于它的左边，左边的右边等于它的右边，并且有一边的宽度增加。注意要用ll Haybale Guessing 有N堆草，任意两堆草的数量都不相同。现在有M个回答，每次回答[Ql,Qh]之间的最小值为A。求这些回答是否自相矛盾。 （很奇怪的，线段树一直不能过，改成并查集就能过了，以后来看看）。离散化+二分答案，即第几句话开始是矛盾的，然后判断，怎么判断呢？先按照A值排序，然后因为每个数是独一无二的，因此可以求他们的交集，如果没有说明矛盾，否则，如果存在区间L1~R1，和区间L2~R2，满足A1&gt;A2，并且区间1包含区间2，说明矛盾，只有这两种矛盾。矛盾求交集，然后更新并集。对于第二种矛盾，可以用线段树（或者并查集）优化，但是线段树不知道为什么错 Cell Phone Network 要在一棵树中装尽量少的无线电通讯塔，使得任意一点离装通讯塔的最短距离不超过1。 树形DP，以1为根，然后对于任何节点i，DP[i,1]表示i号装了，并且它的子树都满足条件，DP[i,2]表示i号和i号的子树，DP[i,3]表示i号没有满足条件，但它的子树都满足条件。对于DP[i,1]=sum(min(dp[c,3],dp[c,2],dp[c,1]))+1DP[i,2]=min(在dp[c,1]中选一个，然后剩余的在min(dp[c,1],dp[c,2])中算一个的sum)DP[i,3]=sum(dp[c,2])其中c表示i的直接子节点，对于dp[i,2]的转移，可以先全部求后者的和，如果至少有一个选了1，那么就是这个结果，否则再从中选取(+dp[c,1]-dp[c,2])最小的那个 Cow Contest 有N头奶牛参加某个比赛，它们的水平有明确的排名。现在有M场比赛，表示A奶牛的水平比B奶牛高。问可以确定多少奶牛的排名。 这是一个有向图，每个A到B之间加一条有向边，那么对于一个点i，如果能到达i的点为x，能被i到达的点的个数为y，如果x+y=n-1，那么说明i就是能确定的。枚举所有的i，然后BFS，时间复杂度为O(n(n+m))。当然也可以用floyd，时间复杂度O(nn*n)，虽然时间复杂度大，但是编写容易，所以这里选用第二种方法。 Running 要跑N分钟，每分钟能Di的距离。每跑一分钟，疲劳度就增加1。如果休息，就必须休息到疲劳度为0为止。在任意时刻疲劳度都不能超过M。在N分钟结束时，疲劳度必须恢复到0。求最多能跑多少米。 动态规划，其中dp[i,j]表示第i天，疲劳值为j最多能跑的距离，那么两方面继承，第一方面是dp[i,0]=max(dp[i-1,j])，另一方面dp[I,j]=dp[i-1,j-1]+d[i] Telephone Lines 有N个点和M条边。你可以将其中K条边的权值变成0。你要找一条1到N的路径，要使得路径上的最大值最小。 二分答案，然后用spfa验证是否能够到达，其中 pfa的Dist数组保存最少删多少边能到达某个点，如果最少删的边数到n点小于等于k，说明可行，否则不可行，然后缩小范围。注意要考虑-1的情况。","categories":[],"tags":[{"name":"-USACO -题解","slug":"USACO-题解","permalink":"http://yoursite.com/tags/USACO-题解/"}]},{"title":"codeforces刷题记录——初三上","slug":"OI/Codeforces/题解：初三上/codeforces","date":"2017-08-31T13:43:09.283Z","updated":"2017-09-02T02:02:23.820Z","comments":true,"path":"2017/08/31/OI/Codeforces/题解：初三上/codeforces/","link":"","permalink":"http://yoursite.com/2017/08/31/OI/Codeforces/题解：初三上/codeforces/","excerpt":"","text":"Codeforces Round #430 (Div. 2) CF843C:这题我们考虑第一个节点，那么结果就是：要么什么都不删除（可以$O(n)$求解），可以只删除第一个（也是$O(n)$）求解$\\Large _{注意到，不要忘记把vis[1]赋值成true，不然会往父亲走!}$，要么是不修改第一个节点。注意到，既然不修改第一个节点，那么最后的$gcd$必然是1的因子！那么我们可以$O(sqrt(n))$来枚举所有可能的$Ans$，然后判断是否需要修改一个以上。 CF843D:这题只需要对所有的$x$求一个前缀$xor$，然后在一棵$trie$树上贪心。注意要记录这个以下的种类。 Codeforces Round #431 (Div. 2) CF849B:注意到，只有2个前缀，如果存在，那么1和2不是同一组，1和3也不是同一组，那么2和3一定是同一组。同理，可以得到1和2，2和3，1和3其中必然有一组是其中一个等差数列的开头，那么O(3)枚举，然后O(n)判断即可。 CF849C:注意到，数字先后是无关的，只需要逐个添加就行了，所以就是找到满足一些$\\sum _nn*(n-1)\\div 2$的n，然后输出。然后位数是不用考虑的，其实长度(&amp;码量)很短。 CF172D:给定a,n，求[a,a+n-1]所有数的贡献总和。一个数的贡献是其除掉所有平方因子后的部分。 ​ 考虑用类似筛法的除去所有的因子，然后暴力求解。 CF451E:有$n$种颜色的❀，第$i$种❀有$f_i$朵。求选出$s$朵❀的不同方案数。$n&lt;=20,s&lt;=1e14,f_i&lt;=1e12$ ​ CF448E:给出一个x,k，每次操作都会将x分解因数，得到新的序列，然后每次再分解序列中的每一个数，按照每一个数分解因数从小到大排，整体顺序不做调整。（如果躲过1e5个，只输出1e5个）$x&lt;=1e12, k&lt;=1e18$ ​ 考虑每次递归处理。每次到k次，然后$cnt++$，直到完了或者到了1e5个。 CF216E:给定一个进制k和一位数b。以及长度为n的序列（均小于k）求这个序列存在多少子序列，能通过变换变为d？这里的变换指的是，每次将k进制数x的每一位相加（k进制加法）得到一个新的数x’，直到最后得到一个一位数。$b&lt;k&lt;=1e9, n&lt;=100000$","categories":[],"tags":[]},{"title":"UOJ刷题记录——做了一题也算做了。","slug":"OI/UOJ/UOJ","date":"2017-08-27T12:36:02.669Z","updated":"2017-08-29T06:42:34.248Z","comments":true,"path":"2017/08/27/OI/UOJ/UOJ/","link":"","permalink":"http://yoursite.com/2017/08/27/OI/UOJ/UOJ/","excerpt":"#1. A + B Problem ​ 考虑先输入两个正整数，然后输出它们的和。","text":"#1. A + B Problem ​ 考虑先输入两个正整数，然后输出它们的和。 #2【NOI2014】起床困难综合症 ​ 注意到，因为是位运算，每一位都是独立的，因此从高位贪心，如果0比1赚（或者相同），一定选0，否则就选1，注意到复杂度是$O(n log n)$ #127. 【NOI2015】程序自动分析 ​ 对于本题，考虑用并查集，先把所有相等的关系合并在一起，再判断不想等的关系是否矛盾——因为不想等是不具有传递性的，而相等具有。注意到数据范围比较大，用一个Map来保存。 ​ 另外，如果说A不等于A，也是错的。 ​ 时间复杂都$O(n\\times log_2n+n\\times α(n))$","categories":[],"tags":[]},{"title":"CF动态规划相关——2017暑假","slug":"OI/Codeforces/题解：2017暑假/动态规划相关","date":"2017-08-27T08:47:15.261Z","updated":"2017-08-29T13:15:29.820Z","comments":true,"path":"2017/08/27/OI/Codeforces/题解：2017暑假/动态规划相关/","link":"","permalink":"http://yoursite.com/2017/08/27/OI/Codeforces/题解：2017暑假/动态规划相关/","excerpt":"规划？ 还是动态的？","text":"规划？ 还是动态的？ CF762D你有一个3*n的格子，每个格子都有权值，问从(1,1)除法，到(3,n)，路上经过的权值最大是多少。 ——听说有一种做法叫做插头DP？划掉。 考虑不会超过2次往后移动。只可能这样 ，而不可能 而且只有第二行可能往后走。 CF67D两条直线，各有n(1≤n≤10^6)个点,每个上面的点会和下面的一个点相连，构成一条线段，共n条线段，问这 n 条线段中，最多有多少线段，它们两两相交？ ——把问题转换为求LIS。然后$n log n$求解 CF41D给你一个N*M的矩阵，其中每个格点中包含0-9中一个数字，问从最下边那一层找到一个起点，一直向上走（向上走只有两种方式，要么斜左上，要么斜右上），询问一个最大值，其走到最上边一层之后，其和为k+1的倍数。并且输出起点位子，以及路径怎样走的。 CF398B给出n和m，表示在一个$n\\times n$的平面上有$n\\times n$个瓷砖，其中有$m$块已经涂色。现在随机选中一块进行涂色（如果已经涂色跳过，也消耗时间），消耗$1$个步骤。终止条件为每行每列都有至少有一块瓷砖被涂色。问说涂成满意的情况需要时间的期望。 考虑用dp[i,j]表示剩下i行，j列需要的答案。记忆化DFS转移一下。 CF317D ​ 网上的题解抄了一下QAQ。 ​ 假设 x 不是任何其它数的正整数次幂，把 x 和它的正整数次幂分成一类，显然一个数不可能同时属于两类，于是整个游戏就被分成了若干个互不干扰的子游戏，且每个子游戏的规模不超过 $log_2N$ ，打表求出 SG 函数异或起来即可，但这样时间复杂度为 $O(\\sqrt N)$ 。 CF54C给出[L,R]区间，区间里的每个数出现的概率是1/(R-L+1)，现给出n个区间[Li,Ri]现在从每个区间选取一个数，这n个数中至少百分之K的数前缀为1的概率。 ​ 考虑先得到每一个区间开头为1的概率，然后用概率DP，表示前i个中，有j个区间开头为1的概率。转移一下，最后用ceil函数得到应该至少多少个区间，累加一下。","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}]},{"title":"CF图论简单题","slug":"OI/Codeforces/题解：2017暑假/图论相关","date":"2017-08-27T00:05:43.829Z","updated":"2017-08-29T06:38:33.863Z","comments":true,"path":"2017/08/27/OI/Codeforces/题解：2017暑假/图论相关/","link":"","permalink":"http://yoursite.com/2017/08/27/OI/Codeforces/题解：2017暑假/图论相关/","excerpt":"","text":"CF208C给定一个有n个节点的无向图。选一个点成为特殊点，与特殊点相连的边称之为特殊边。求，对于所有1~n的最短路，经过的特殊边数量的平均值的最大值。$n&lt;=100, m&lt;=n(n-1)/2$ DP(2A)——注意LL ​ 对于特殊在1或者n，答案是边数/总路劲。否则就是经过某个点的边数*2/总路径。 ​ 考虑首先一次$bfs$，求出源点到某个点的距离 ​ 考虑第二次$bfs$，求出源点到某个点有多少次条路 ​ 考虑第三次$bfs$，在枚举出点的情况下，求出有多少最短路经过该点 CF154C有一个n个节点,m条边的无向图，问有多少个点对，使得除了它们之间的边之外，其他的连接方式相同$(1 ≤ n ≤ 10^6, 0 ≤ m ≤ 10^6)$","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"}]},{"title":"CF简单数据结构","slug":"OI/Codeforces/题解：2017暑假/数据结构相关","date":"2017-08-25T08:17:54.491Z","updated":"2017-08-29T06:39:00.283Z","comments":true,"path":"2017/08/25/OI/Codeforces/题解：2017暑假/数据结构相关/","link":"","permalink":"http://yoursite.com/2017/08/25/OI/Codeforces/题解：2017暑假/数据结构相关/","excerpt":"听说数据结构不能吃","text":"听说数据结构不能吃 CF538F：题意见： 12&gt; http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1533&gt; 树状数组 ​ 注意到，每个点作为父亲，最多只有n log n个父亲（调和级数）。那么我们要得到快速计算结果。 ​ 考虑把所有数排序，然后逐个加入到树状数组原来的位置里面。 同时计算它作为k（枚举）叉堆的父亲的时候其子节点的贡献。 ——当然，为了不重复计数，在值相同的情况下，我们先把上面的数据处理，再处理下面的数据，然后树状数组计算当前节点对k叉堆的贡献。 ​ $O(n log^2 n)$ CF101B:给定n,m。需要从0到n，有m种公交车。第i辆公交车从si走到ti，问有多少种方案可以选择。注意人只能坐车，不可以走。$m&lt;=100000$ DP ​ $DP[i]$表示$i$结束的种类，树状数组区间求和即可。 CF372C:给定一个n*m的地图，标有数字1~p。需要从1出发，依次经过2,3,4…直到p（至少一次）。求最少所需要的步数。$n,m&lt;=300$ DP ​ 考虑用$dp[i,j]$表示在第$i$个行，第$j$个位置的答案。——分组DP。那么对于$dp[i,j]$，设这个是x，那么从周围的x转移过来，可以拆分成左上角，右上角，左下角，右下角转移过来。 ​ 考虑把哈密顿距离分开来，对于4个方向分别用二维树状数组维护。 ​ 每次做完一组，把前一组的位置赋值成$oo$。然后把树状数组赋值成这一组的$dp$值加上一些值。 ​ 注意括号别匹配错。","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"CF543D && CF369C","slug":"OI/Codeforces/题解：2017暑假/CF543D && CF369C","date":"2017-08-25T02:30:25.509Z","updated":"2017-10-28T11:03:26.655Z","comments":true,"path":"2017/08/25/OI/Codeforces/题解：2017暑假/CF543D && CF369C/","link":"","permalink":"http://yoursite.com/2017/08/25/OI/Codeforces/题解：2017暑假/CF543D && CF369C/","excerpt":"树是什么？能吃吗","text":"树是什么？能吃吗 CF543D输入给出N和一些边的关系$(p2，p3，p4……pn）$表示$i$和$p_i$有连边.对于以i为根时，把树边黑白染色，使得任意点走到根的路径上不超过一条黑边，输出染色的方案数(mod 1e9+7) ​ 考虑树形DP，在以1为根的前提下，设$f[i]$表示以i为根的子树的$Ans$。容易得到 ​ $\\Large f[i] = \\prod _{j}^{}(f[j]+1)$ ​ 那么我们第二次DFS的时候，得到一个节点在以1为根的大树中，上面连通的哪些的$Ans$。注意到，要处理逆元。但是，可能出现0，但是不能算无解。应该重新跑一遍去算。 CF369C:给出一棵以1为根的树，形式是从节点2开始给出每个节点的父亲节点；然后是$q$次操作，操作分为两种，$1$,$v$,$x$,$k$，表示在以v为根的子树上添加，对于所有其它与$v$节点的距离为$i$的点$v$节点的后代，加上$x-ik$；$2$,$v$查询节点v的值(对1e9+7取模)。一开始都是0,$n,q&lt;=310^5$","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"tree","slug":"tree","permalink":"http://yoursite.com/tags/tree/"}]},{"title":"Codeforces-Educational-Round","slug":"OI/Codeforces/题解：2017暑假/教育场相关","date":"2017-08-24T06:48:58.885Z","updated":"2017-08-29T06:35:43.443Z","comments":true,"path":"2017/08/24/OI/Codeforces/题解：2017暑假/教育场相关/","link":"","permalink":"http://yoursite.com/2017/08/24/OI/Codeforces/题解：2017暑假/教育场相关/","excerpt":"这是用来教人怎么做人的。","text":"这是用来教人怎么做人的。 Educational Codeforces Round 1 CF598A：求数字之和，但是要不算2的倍数 模拟(1A) ​ 等差数列求和公式，再减去2次倍数即可。$log$的复杂度 CF598B：给定一个字符串s，下标从1 - |s|。有m次操作，L R k - 表示讲[L, R]里面的字符右移k次，第R位右移一次到达第L位。问你经过m次变化后的字符串。 模拟(1A) ​ 考虑把k先对长度取模，然后用一个辅助数组直接暴力O(len)移动再代入。 CF598C：找到两个向量间夹角最小的那两个向量的位置; 精度(N A) ​ 要用atan2高精度做，用long double做，极角排序后求角度即可。 CF598D：给定一个$n \\times m$的地图，有k次查询。每次查询，询问位置（x,y）的点连通块周围有多少个 flood fill(2A) ​ 先$N \\times M$把所有位置的答案算出来，然后询问直接做 CF598E：一个n*m大的巧克力，你要吃k个单元的巧克力。每次切分都会有切的那条边长度平方的代价。问最小代价。 DP(4A) ​ 考虑直接用$dp[i,j,k]$表示状态为i,j,k的时候的答案，那么只需要暴力枚举分割线，以及左边多少，右边多少，取max。注意不要数组越界 Educational Codeforces Round 3 CF609A:给你一个m大的总内存和n个USB快闪驱动器，问你至少需要多少个USB快闪驱动器才能装满或者超过总内存。 贪心(1A) ​ 排个序，然后贪心贪大的，看减多少次小于等于0即可。 CF609B:给你一堆书和他们的种类，然后要挑两本书，他们不能是相同的种类，求有多少种挑法 容斥(1A) ​ 考虑所有情况，减去2本数在一起的情况，注意到m&lt;=10，比较容易。 CF609C:给你n个元素的序列a[]，每次可以任选两个元素使得其中一个减1，另一个加1，付出代价为1。问你最小的代价使得序列最平衡。 贪心(1A) ​ 考虑直接贪心做，把最后得到的那个序列通过总和，余数等算出来，然后考虑把当前排序，贪心地得到两者之间的绝对值的sum，那么最后答案就是这个sum/2 CF609D:给定m个物品（编号从1-m）以及它们的种类和价格（美元和英镑），其中种类1意味着购买该物品需要美元，反之需要英镑。已知在n天里，每天都会有美元和英镑的兑换率a[i]和b[i]，意味着用a[i]个burle可以换取1美元，英镑的兑换同理。现在你手上只有s个burle，你需要在n天里购买k个物品，要求每个物品只能买一次，问你最早在第几天可以完成任务，并输出购买方案。 二分答案，贪心(1A) ​ 考虑每种货币都在最小的同一天进行购买——在最便宜的一天购买，这样是最赚的。 ​ 那么我们首先二分答案，那么接下来的事情就是枚举多少个英镑去买，多少个美元去买。那么同时我们之前预处理出一个前缀Min，那么$O(1)$得到在这种情况下，要花费多少burle，如果够的，那么就返回true。 ​ 注意要保存一下ID。因为答案要输出购买方案。 CF609E：给你一幅图，问对于每条边，包含这条边的最小生成树。 并查集按秩合并(5A) ​ 倍增写挂了，发现这个好写多了。 ​ 考虑先求出原图的最小生成树——按秩合并（用$m log m$的那个算法)，考虑到边权是递增的，那么每次加入一条边，这条边连接的两个联通块，那么联通块两边的点一定会经过这条边——这是有保证的。而Max也能保证。 ​ 而按秩合并，可以保证树高不会超过log，所以复杂度是$O(m log m)$级别的。 ​ 如果不是原图的边，然后就相当于去掉路劲上最大边权的点，然后加上这条边的边权。 Educational Codeforces Round 4 CF612C：给你一个只含有括号的字符串，你可以将一种类型的左括号改成另外一种类型，右括号改成另外一种右括号。问你最少修改多少次，才能使得这个字符串匹配，输出次数。 栈(1A) ​ 手工模拟一个栈，如果遇到不匹配的，那么就$Ans+1$. CF612D：给出n个区间$[li,ri]$以及一个整数k，称一个数的令人满意的如果它至少被这n个区间中的k个区间覆盖，输出所有令人满意的数构成的区间 差分(4A) ​ 运用差分思想，考虑$l[i]$的时候+1，$r[i]$的时候-1。注意到，一个点也算是一段，所以不能所谓的离散化之类的，考虑把所有读入之后按照位置排序，在位置相同的情况下，先排加，后排减。然后前缀和一发。 CF612E：定义置换的平方为1~n的排列做两次该置换得到的结果。已知一个置换的平方，求该置换。 构造(问$XZA$大佬的) ​ 大佬说，先找循环，分成不同的循环联通块。 ​ 大佬还说，对于元素个数是奇数的，只需要往后移2位就行了，对于元素个数是偶数的，把相同元素个数的两两组合在一起，轮换着放——大佬说这是参考样例1的。","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"CF组合计数相关","slug":"OI/Codeforces/题解：2017暑假/组合计数相关","date":"2017-08-24T06:46:42.456Z","updated":"2017-08-29T06:36:20.078Z","comments":true,"path":"2017/08/24/OI/Codeforces/题解：2017暑假/组合计数相关/","link":"","permalink":"http://yoursite.com/2017/08/24/OI/Codeforces/题解：2017暑假/组合计数相关/","excerpt":"我为我听说过排列组合而感到高兴。","text":"我为我听说过排列组合而感到高兴。 CF57C:给你一个数n，表示有n个数的序列，每个数范围为[1,n]，叫你求所有非降和非升序列的个数。 ​ 考虑到答案是$\\large 2\\times C(2\\times n-1,n)-n$。 ​ 引用一段网上的：我们在满足条件的n个数之前加一个虚节点1，在第n个数之后加一个虚节点n，那么考虑这n+2个数组成的非降序列：假设序列里的第i个数为a[i]，我们设$\\large xi=a[i+1]-a[i]+1$，$\\large 1&lt;=i&lt;=n+1$，则满足每个数&gt;=1,且$\\Large \\sum_{i=1}^{n+1}x[i]=2\\times n$；那么相当于求将2*n分成n个部分，且每个部分的值大于等于1，则易得非降序列总数为：$(\\Large_n^{2\\times n-1})（2\\times n-1 选 n）$ ​ 以后慢慢看吧。（估计不会来看了） CF40E:给出一个n×m的矩阵，每个元素都是1或−1，其中有k个位置元素已经确定，并且这个矩阵满足每一行、每一列元素的乘积都是−1，问有多少种不同的矩阵。$1≤n,m≤1000,0≤k&lt;max(n,m)。$，答案对$P$取模。 ​ 首先，行的1要满足$(-1)^n$和$(-1)^m$是相等的（所有的格子的乘积）——所以当n和m不是同奇偶的时候，就无解。 ​ 注意到$0&lt;=k&lt;max(n,m)$，说明必然有一行（或者一列）是空的。（我们只讨论行是空的，列的不管，转化就行了）那么这一行有什么用的? ​ 如果我们考虑到，其它行的原先是-1还是1能算出来，然后得到满足每一行的情况。（通过组合），那么这个空的行一定是固定的——用来满足列的需求。 ​ 所以答案是除了这个空行，剩下的每一行独立的情况乘起来。 CF830D:给定n，现有深度为n的满二叉树，对于一个节点，给它与它的所有父亲连一条边。 问：得到的新的图有多少条不同的简单路径（1-&gt;2和2-&gt;1算不同路径）答案$$\\mod (1,000,000,007) n≤400$$ ​ fi,j表示从i-house中选出j条不相交的路径的方案数，那么答案就是fk,1​ i-house可以从两个i-1-house中转移过来​ 枚举fi−1,j和fi−1,k​ 如果让根成为单独的一条路径，那么fi,j+k+1+=fi−1,j×fi−1,k​ 如果不选根，那么fi,j+k+=fi−1,j×fi−1,k​ 让根与左儿子中的一条路径结合或和右儿子中的一条路径结合，那么fi,j+k+=fi−1,j×fi−1,k×2×(j+k)​ 从j+k条边中选出两条，让这两条边与根结合形成新的一条边，那么$f{i,j+k−1}+=f{i−1,j}×{fi−1,k}×C^2{j+k}\\times2$ ​ 然后因为答案是$f_{k,1}$切每次转移第二位最多减一，所以$j$,$k$只要枚举到$k$就行了。这样复杂度是$n^3$的。","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"组合计数","slug":"组合计数","permalink":"http://yoursite.com/tags/组合计数/"}]},{"title":"CF数论简单题","slug":"OI/Codeforces/题解：2017暑假/数论相关","date":"2017-08-22T07:22:50.728Z","updated":"2017-08-29T13:16:43.381Z","comments":true,"path":"2017/08/22/OI/Codeforces/题解：2017暑假/数论相关/","link":"","permalink":"http://yoursite.com/2017/08/22/OI/Codeforces/题解：2017暑假/数论相关/","excerpt":"数论只会GCD……","text":"数论只会GCD…… http://codeforces.com/problemset/problem/222/C ​ 给出两个集合，第一个集合数的乘积是分子，第二个集合的数的乘积是分母，要求够造一个同样大小的集合，但是得到的分数是化简过的。 ​ 考虑先用线性筛求出素数(1e7)，然后跑质因数分解，保存在数组中，取出gcd——然后对于a和b，贪心的除去gcd。 http://codeforces.com/problemset/problem/446/C ​ 给定n个元素的数组a[]. ​ 操作1, l, r。要求对于l&lt;=i&lt;=r,a[i]] += f[i-l+1] ​ 询问2, l, r。范围Σa[i] (l&lt;=i&lt;=r) ​ $n,m&lt;=300000$ ​ 其中$f[i]$为斐波那契数列，$f[1]=1,f[2]=1$ 斐波那契数列 ​ 据说这是通项公式$\\Large fib(i)=\\frac{1}{\\sqrt 5}((\\frac{1+\\sqrt 5}{2})^n+(\\frac{1−\\sqrt 5}{2}) ^n)$ ​ 然后有一个神奇的事情是，$\\sqrt 5$在Mod$1e9+7$意义下的逆元是有解的！ ​ $sqrt(5)=383008016$ ​ $sqrt(5)/5=276601605$​ $(1+sqrt(5))/2=691504013$​ $(1-sqrt(5))/2=308495997$​ 利用公式​ 注意本题$q-1$的逆元为$q$​ 所以， $q\\times (q^n-1)/(q-1)=q^2(q^n-1)=q^(n+2)-q^2$ ​ 注意用线段树维护等比数列 http://codeforces.com/problemset/problem/711/E ​ 给定N,K，已知一年有2^N天，选取K个人，两个人的生日是在同一天的的概率要求，$1&lt;=n,k&lt;=1e18$，答案作为分数，对$1e6+3$取模——在取模之前约分！ ​ 考虑当$2^N&lt;K$的时候，显然是1,1。否则答案就是$(1- A_{2^n}^{k}) \\div (2^{nk})$，考虑如何化简这个式子。 ​ 首先，$A(2^n,k) = (2^n)∗(2^n−1)∗(2^n−2)∗ … ∗(2^n−k+1)$那么在把一个2^n约掉之后，考虑到他们的$gcd$一定也是2的幂次，显然分母所包含的2比分子包含的多所以只要看分子还有多少2即可。注意到，如果$k$是$2^m$的倍数，那么$2^n-k$也是$2^m$的倍数。所以只要看$(k-1)!$有多少个因子2即可。这个很好解决。 ​ 那么分子其实不会超过1e6+3次运算，因为可能出现0。 http://codeforces.com/problemset/problem/121/C ​ 对于一个数，如果它仅包含4或7，则称之为幸运数。求1~n的第K个置换，有多少幸运数位于的位置也是幸运数。$(n,k&lt;=1e9)$ ​ 考虑到，$13!$已经超过1e9了，所以事实上前面好多位都是不会变的。那么只要暴力加上去，再暴力算出后面的就行了。 http://codeforces.com/problemset/problem/772/C ​ 给定n个0~m-1内的数和m，构造一个尽可能长的所有元素都在0~m-1内的数列，并且使所有前缀积模m不相同且不在n个数中出现过。 ​ 考虑到所有的$gcd$都是非递减的。那么考虑小的$gcd$一定能通过乘上某个数变成其倍数的$gcd$，因此，把不同的$gcd$的个数求出来，跑一个$DP$（类似$DAG$最长路），然后可以得到一系列的前缀和。再通过前缀和，解同余方程得到最后的$Ans$。 ​ 为什么是非递减的？因为如果当前数a和$m​$的$gcd​$是x的话，那么对于1到m-1的任何一个数b，因为满足它们$gcd(a,m)=x​$，也就是要知道$gcd(ab,m) = y​$,首先，因为a和m都有公因数x，所以$\\large y=gcd(\\frac{ab}{x},\\frac{m}{x}) * x​$,这时候已经可以发现$y&gt;=x​$了。 ​ 考虑为什么一定有解？因为最终我们得到了前缀积。我们要做的是通过前缀积算出结果，设前面一个的前缀积是$a$，后面一个是$b$，那么目的是要找出满足$ax \\equiv b \\pmod {m}$，因为我们知道,$gcd(a,m)&lt;=gcd(b,m)$，所以设$gcd(a,m) = d$，$a=a/d$,$b=b/d$，那么现在还是找出$ax \\equiv b(mod m/gcd(a,b))$，那么我们要知道a关于m的逆元即可。而此时a和m已经互质，逆元可以通过$ex_gcd$求出。 http://codeforces.com/contest/396/problem/B 定义函数v(n)为不大于n的最大素数。定义函数u(n)为大于n的最小素数。求Σ1/(v(i)*u(i))(2&lt;=i&lt;=n)。$T&lt;=500,n&lt;=1e9$ ​ 裂项：这样假设有$n$，$v = v(n), u = u(n)； $ ​ $1/(23) + 1/(35) (5-3) + …… + 1/(vu) * (n-v+1) (注意最后不是u-v个）$ ​ $= 1/2 - 1/3 + 1/3 - 1/5 + …….. -1/v + 1/(vu) (n-v+1)$ ​ $= 1/2 - 1/v + 1/(vu)(n-v+1)$ ​ $p = uv + 2(n-v-u+1); q = 2uv;$","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"},{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"}]},{"title":"atcoder","slug":"OI/Atcoder/atcoder","date":"2017-08-20T13:53:20.000Z","updated":"2017-08-29T06:42:24.889Z","comments":true,"path":"2017/08/20/OI/Atcoder/atcoder/","link":"","permalink":"http://yoursite.com/2017/08/20/OI/Atcoder/atcoder/","excerpt":"","text":"AtCoder Regular Contest 081 arc081C(2提交) 贪心 ​ 考虑找出可以两两配对的棒子，取最大的贪心即可 arc081D(1提交) 递推先把最左边的特殊考虑，然后分成4份： $*^{|– }{|–}$，那么右边的乘2；$^{|| }{||}$，那么右边的乘2；$^{—- }{– –}$，那么右边的乘3；$^{–| }{–|}$，那么右边的乘1 agc019C(4提交) DP考虑找到从起点到终点（每次只能往两个方向走）的最多的圆盘的个数，然后如果个数刚好等于行差+1或者列差+1,那么表示有一个圆盘要直接走过去，剩下的都是可以转弯的时候绕过的。","categories":[],"tags":[]},{"title":"想想","slug":"想想","date":"2017-08-19T11:48:55.000Z","updated":"2017-08-19T11:48:55.325Z","comments":true,"path":"2017/08/19/想想/","link":"","permalink":"http://yoursite.com/2017/08/19/想想/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"codeforces——2017暑假","slug":"OI/Codeforces/题解：2017暑假/codeforces2017暑假","date":"2017-08-19T05:10:03.000Z","updated":"2017-08-29T13:14:17.869Z","comments":true,"path":"2017/08/19/OI/Codeforces/题解：2017暑假/codeforces2017暑假/","link":"","permalink":"http://yoursite.com/2017/08/19/OI/Codeforces/题解：2017暑假/codeforces2017暑假/","excerpt":"乱作一波题。 感觉无法忍受 不贴代码Orz","text":"乱作一波题。 感觉无法忍受 不贴代码Orz Codeforces Round #308 (Div. 2) CF552A给出一些矩阵，问这些矩阵覆盖的面积之和（不是并，重叠算多次） 模拟(1A) ​ 考虑直接把每个矩形的面积算出来，做一个和即可。 CF662B给你一个数字N，问$1$到$N$这些数字数码的长度之和是多少，1234的长度是4. 模拟(1A) ​ 分别考虑是否包含一位数，是否包含2位数……如果包含，直接求解，否则相当于剩余的有多少个x位数求解。 CF552C给你一个W和M，问是否用一些W^0,W^1,W^2……放在天平的两侧，构成M 进制转换(2A) ​ 从后到前处理每一位,如果某一位是0，不用动;如果某一位是1,那么表示右边要有这样一个砝码；如果某一位是m-1，说明左边要有这样一个砝码，但是加了左边的砝码之后，事实上相当于m加了这个值；其它情况都是无解。 CF552D给你一些点，问能构成多少个三角形。$N&lt;=2000$ 计算几何(1A) ​ 虽然$N&lt;=2000$，但是不知道为什么$O(N^3)$暴力+计算几何判断能过。 CF552E给你一些由1~9的数字，以及数字之间的’+’,’*’构成的表达式，在其中加入一个括号，使得表达式的值最大。 思维，暴力(1A) ​ 考虑到所有数都是大于等于1的，所以括号在乘法的两旁一定比在加法的两边要赚。考虑枚举所有括号，再暴力判断即可。 Codeforces Round #327 (Div. 1) CF590A:给你一个只有0和1组成的序列A，每次可以对序列A进行操作，每次操作是把A的每一个元素变成上一个序列的它，它左边，它右边3个数的中位数，其中1和n不变。问几次操作后会变成稳定——不会再改变，然后稳定时候的状态是怎么样的。 划分 ​ 对于中间的元素，只有一种情况会使得其改变：010或者101——其中它在中间。考虑可以把整个序列划分成一些稳定的两端构成的序列 如，把1010101010111010101划分成10101010101|1|1010101这3部分，然后每一部分最终都会变成4种形态:11110000或者00001111或者11111111或者00000000这种。 既然这样，就可以处理，然后答案对操作数取一个Max即可。线性O(n)扫描。 CF590B:您要从(x1,y1)到(x2,y2)，一开始风速为(vx,vy)，t秒后(wx,wy)，您的速度不超过Vmax，求最少到终点的时间，保证风速小于您的速度，风速和您的速度都是向量 二分答案 ​ 二分答案，然后假设人不动，判断是否可行。 CF590C:给定一个N*M的矩阵，这个矩阵里面有’1’,’2’,’3’,’.’,’#’,你可以把’.’改成桥，使得所有1,2,3四联通，问最少把多少个’.’改变，其中‘#’不能改变，如果不能输出-1。——其中’1’,’2’,’3’本身是连续的 BFS ​ 注意到，桥一定会在一个点交汇——这个点可能在某个国家里面，也可能在’.’位置。我们可以考虑枚举这个交汇点的位置，然后把3个国家到这个点的Dis全部加起来，取Min就是结果为什么是对的呢？这个不会有重复吗？会的。不过必然有一个点没有，那就是交汇点。我们可以预处理出某一个国家到一个点路上最少经过的’.’的个数——我用循环入队一直T，后来改成优先队列做的——事实上还有更好的方法。然后枚举每一个点，当然，如果这个点是’.’会被计算3次，要减去。 CF590D:n个数，求最多相邻两两交换S次，使前K个数的和最小 DP ​ 注意到，N*(N-1)/2&lt;=S的时候，S的大小已经没有什么用途了考虑用dp[i,j,k]表示处理到前i个数字，其中已经交换了j次的，前k个已经确定的最小数字之和考虑把第i个交换到第k个位置——或者不交换。不交换的话$dp[i,j,k] = dp[i-1,j,k]$交换的话$dp[i,j,k] = dp[i-1,j - (i-k) , k-1] + a[i]$用滚动数组优化一下答案就是$dp[N,X,K] (X&lt;=S)$ Codeforces Round #330 (Div. 1) CF594A:数轴上有N个点，N是偶数。有两个人，依次取走一个点，直到最后剩下2个点，其中第一个人（先取要最后剩下的点的距离最大），第二个人要使得距离最小，问距离最小是多少。 博弈 ​ 如果您作为第二个人，您一定会去取两端的。如果存在答案区间L,R。显然，第二个人一定会取L,R以外的。 ​ 相反，第一个人会取L,R以内的，因为L,R以外的第二个人会去取。所以答案就是在其中找一段区间，使得内部有(N-2)/2个点，然后区间最小。 CF594C平面上，给你n个点，然后你可以删除k个点然后让你用一个两边平行于坐标轴的矩形，去围住这n-k个点，问这个矩形的面积，最小可以是多少$(K&lt;=10)$ ​ 暴力，考虑到只会删除上下左右4个方向的点，先暴力得到上下删除哪些点，然后再暴力得到左右删了哪些点，用一个标记数组维护。 CF594D:给你n个数(n&lt;=200000)，每个数&lt;=1e6，给出Q个询问，每个询问给出l,r,问的值是多少。 ​ 回顾一下欧拉函数的求法 $$\\large \\varphi[n] =n* \\prod_p^{p是n的质因数}(p-1) / p$$ ​ 同样的，扩展到区间 $$\\large \\varphi[Π(A[L]-A[R])] = \\prod_{i=L}^{R}(A[i]) * \\prod_p^{p是这些乘积的质因数}(p-1)/p$$ ​ 这题没有修改操作，一切都是询问，可以考虑离线处理。我们把所有询问按照右端点排序。那么如何处理(L~R)这一段的乘积的欧拉函数呢？事实上，L~R中间的数的乘积我们可以通过前缀$O(1)$得出来，我们需要的就是L~R这一段所有数包含的质因数(p)的(p-1) / p，当然，在Mod意义下是逆元。这里，我们先假设每个数出现不同的质因数。计$Xi = (p1-1) / (p1) * (p2-1) / p2$……，其中p1,p2是ai的质因数同样的，我们可以保存前缀，算得$X1$~$Xr$的乘积，然后再算得到$X1$~$X_(l-1) $的乘积，然后可以O1求解。然而，我们要知道，每个数可能拥有同样的质因数。显然，由于我们已经按照右端点排序 ​ 我们可以把所有可能的质因子保存在最右边出现质因子的地方。用一棵树状数组维护前缀Xi的乘积。对于新加入的一个数$Ai$，考虑得到它的所有质因数，如果这些质因数还没有出现过，那么把(p-1)/p弄上去，否则，不但要把(p-1)/p弄到这个节点上，还要把p / (p-1)弄到前面出现p的节点上，以消除p的重复影响。 Codeforces Round #333 (Div. 1) CF601A有个地方有些城镇，城镇与城镇间如果有铁路相连，就不会有公路相连，没有铁路连接的城镇就会有公路相连。给你n个城镇数目，m铁路线，问同时从1出发，分别坐火车和坐汽车到达n点，两者都到达的时候最少的用时。其中火车和汽车不能同时到达中间点。 ​ 跑2次最短路即可。 CF601B给定n个hi，然后定义·if n &lt; 2, ·if n ≥ 2, over all 1 ≤ i &lt; j ≤ n 给出区间L,R，问区间L,R的所有子段的L函数之和。 脑洞，单调栈 ​ 把$i$看成横坐标，$h[i]$看作纵坐标，那么$L(h)$其实就是一个区间中的某两点之间的斜率绝对值，从而可以证明$L(h)$一定是坐标相邻的点的斜率的绝对值$L(h) = abs(h[i+1] - h[i]) ——1&lt;=i&lt; n$设$D[i] = h[i] - h[i-1].$那么答案就是各个$f[i]$的贡献和，这个可以通过单调栈做出来。通过单调栈，可以得到这个位置向左严格最大到哪边，向右不严格最大到哪边——主要是为了让每个区间都加入计数。 CF601C有$n$场比赛，每一场比赛都有$m$人参与。每场比赛的得分都是这个人的排名（没有相等的）总分是$n$场比赛的分数之和。总排名定义为：总分严格小于他的人数$+1$。已知小K在$n$场比赛中的排名。所有人的水平相同，求小K的期望总排名。 DP ​ 考虑到直接计算排名比较麻烦，设$f[i,j]$表示$i$场比赛之后，总分为$j$的期望人数，那么可以得到一个转移方程：$\\large f[i,j] = \\sum\\frac{f[i-1][j-k]}{m-1}(i&lt;=k&lt;=m,k≠a[i])$，通过这个式子观察之后我们可以发现，可以前缀和优化转移，于是采用差分方法实现。 Codeforces Round #334 (Div. 1) CF603A有一个长度为n的1,0组成的串，可以将其中连续一段翻转，使得剩下的1010交替出现的子序列最长。 DP(1A) ​ 考虑用$f[i]$,$g[i]$,$h[i]$分别表示还没有翻转，正在翻转，翻转完了的$ans$，最后取一个$max$即可。 CF603C，有n堆石子，如果某一个石子是偶数，可以选择得到k堆石子数/2个，奇偶都可以得到石子数-1个石子。没法操作者败 博弈(3A) ​ 考虑SG函数打表找规律，当i为奇数的时候，$SG[i] = mex SG[i-1]$，当i为偶数的时候,能执行第二种操作，所以$SG[i] = mex(SG[i-1],SG[i/2] xor SG[i/2]……共k个)$，由此可以得到，答案之和$k$的奇偶有关，当$k$是奇数的时候，$SG[i] = mexSG[i-1],0$，所以往后一定是01交替出现，当$k$是偶数的时候，SG当$i$是奇数的时候为0，否则只需要$SG[i/2]$递归调用，取$mex$即可，注意到，不会超过$log$次调用。 Codeforces Round #335 (Div. 1) CF605A给定$n$的一个排列，每次可以把一个数放到开头或末尾，求变为升序的最少步骤 DP(1A)​ 考虑就是寻找到一个每位都递增1的最长上升子序列，然后这些不动，其它改变。用DP求即可。 CF605B有一个$n$个点，$m$条边的图，然后$m$条边中有$n−1$条边构成了最小生成树，然后边权与是否作为$MST$的边告诉你，要构造出这个图。 构造(2A) ​ 逐个添加，如果应该作为最小生成树的，考虑可以把1和这个节点连接，如果不应该作为最小生成树的，考虑把剩下可以用的边连接，如果无法连接，就是无解。当加入一个新节点，可以用的边加入这个点到前面非1的位置的。新节点只有当最小生成树的边加入时才增加。 CF605C有$n$项工作，第ii项工作每天可以带来$ai$的经验，$bi$的钱。问最少几天可以得到$p$的经验和$q$的钱。工作天数可以是小数，每次只能进行一种工作。 二分答案，凸包(10A)——注意LL ​ 考虑把(ai,bi)看作平面上的一个点，注意到，一个点可行，当且仅当这个点是平面的凸包上的点——否则一定有2个点比这个点优。进一步，一定是凸包一个点，或者相邻两个点组合得到的。 ​ 考虑二分答案，然后用类似解二元一次方程的方法，把凸包相邻2个点，或者凸包上的一个点组合得到的算出来，输出解即可。 CF605D玩家有两个属性$x,y$，有$n$个魔法。对于第$i$个魔法，用$(ai,bi,ci,di)$描述。当$ai&lt;=x,bi&lt;=y$时，玩家能使用这个魔法。之后玩家的属性$x=ci,y=di$。求施展第n个魔法最少需要多少次。输出方案，答案不唯一。 BFS，树状数组，set(2A) ​ 相当于一个二维平面，因为是最小步数，很容易想到$BFS$，但是$BFS$的扩展节点只能扩展这个的左下方的，为了快速扩展（线段树套线段树显然可行）——用一个更容易实现的，考虑树状数组（离散化后的x坐标）套$set$，来快速维护下一个应该扩展的点，那么就是在左下角寻找一个满足条件的，（用树状数组），然后用$set$的lower_ bound快速寻找，然后扩展。时间复杂度$O(n log(n) log(n) )$ Codeforces Round #336 (Div. 1) CF607A点有位置和能量，ii个点被选择，那么在ii左边它这个能量的位置内的所有点都不能选择，如果现在从右到左依次选择点。现在可以在最右边放置一个点，能量和距离随意，问各种情况下最小摧毁的点的个数。$N&lt;=100000,ai&lt;=1000000$ DP(1A) ​ 坐标范围比较小，考虑用f[i]表示到i位置最多能放的点，简单转移一下即可。 CF607B长度为$n$的字符串，每次消去一段连续的回文串，剩下的两端重新拼接成一个新的串，问最少需要消去多少次。$n&lt;=500$ DP(1A) ​ 考虑用$dp[i,j]$表示从i到j，最多要消几次。如果$(i,j)$的长度大于2，并且$a[i]$ = $a[j]$，那么这两个可以等下并到里面去消，所以 $dp[i,j] = dp[i+1,j-1]$。或者从中间某个k，使得左右分别消， ​ $dp[i,j] = min(dp[i,k]+dp[k+1,j])$ CF607C有两个独立的坑道，由$“NSWE”$表示。两个球在各自坑道的起点。之后对两个球做相同的操作，上下左右。保证两个小球保持一致的动作，其中一个撞墙的话不用管。问能不能保证两个小球都能从起点到达终点。到达终点后，还有可能因为操作而退出。 脑洞，哈希(1A) ​ 考虑依次让两个球分别到达终点，可以猜测一个结论，无法到达当且仅当第一个球达终点后，第二个球需要到达终点的步骤，恰好使得第一个球退出（证明有些困难）。于是可以改变第一个球轨道的方向，就变成字符串匹配的问题。从而用hash使得前一个串的后缀对称后得到后一个串的后缀，那么就无解。 Good Bye 2015 CF611C:题意：有一个$n×m$的网格，‘#’不能摆。有$Q$个询问，每个询问$(r1,c1,r2,c2)$求出这个子矩形内可以有多少种方式放一个$1×2$的骨牌。$n,m&lt;=500,Q&lt;=100000$ 容斥 ​ 考虑得到$a[i,j]$，表示询问为$(1,1,i,j)$的答案。 ​ 那么对于询问，可以拆分成总的减去两个，再加上一个小的。这样还不够，因为类似的一个里面一个外面的多余了，得$O(n)$扫一遍判断。 CF611D:把一个长为$n$的数字串拆成多个串，要求这些串的数值递增的，并且没有前缀0，问有多少种分法。$n&lt;=5000$ DP，LCP。定义状态$f[i][j]$表示$[1,i]$中划分了最后$j$个的方案数。发现状态难以优化，考虑从加速转移入手。假设前一段划分的长度为$k$，注意到当$k&lt;=j−1$时，显然能够转移，即$f[i][j]=\\sum ^{j−1}_{k=1}f[i−j][k]$，这一部分可以前缀和优化。还有可能是从$f[i−j][j]$转移到$f[i][j]$，就需要比较$[i−2j+1,i−j],[i−j+1,i]$的大小。由于长度相等，实际上就是在比较字典序。而比较字典序有一个常用的方法，可以求出以$i,j$开头的最长公共前缀，记为$lcp(i,j)$，这样预处理后就可以$O(1)$转移了。 Wunder Fund Round 2016 (Div. 1 + Div. 2 combined) CF618C给定n个点$(xi,yi)$，求一个三角形ABC，满足其它的点都在三角形的外面，输出任意一个三角形三个点的下标，n&lt;=100000。 构造，计算几何 ​ 考虑排序之后，最前面的3个点一定的是满足条件的，否则如果3点共线，只需要把第3个点继续往后找即可， CF618E原来有一个N个段的长度为1的段，然后有m个操作，操作1是给定第X段，然后把第X段延长，变成多少Y，然后操作2是把某一个段按照原先的左端点旋转α°，每次操作完了询问原先最右边的端。 $n,m&lt;=300 000$ 线段树 可以用线段树维护两个点之间的相对位移这里有一些公式：假设任意点(x,y)，绕一个坐标点(rx0,ry0)逆时针旋转a角度后的新的坐标设为(x0, y0)： $x0= (x - rx0) \\times cos(a) - (y - ry0)\\times sin(a) + rx0 ;$ $y0= (x - rx0)\\times sin(a) + (y - ry0)\\times cos(a) + ry0 ;$ 显然，延长操作只是单点修改。——保存位移之后只要同比例缩放就行了.那么旋转呢？这是一个区间修改。对于后面全部整段，都是需要绕着某个点进行旋转的。其实，角度是可以叠加的:___大家可以自己画图，然后用延长用四点共圆证明……角度竟然是可以叠加的! 然后就好做多了……QAQ。——本来还想着用矩阵结合律。。。 CF618F:给定两个多重集$A,B$，每个数$∈[1,n]$。在$A$中选取一个含$Ka$个元素的非空子集。在$B$中也是如此（有$Kb$个元素）。要求使得两个子集之和相等。$n&lt;=100000$。 构造 ​ 注意，每个数是在1~n之间的。考虑把条件加强，如果只是寻找连续上面一段和下面连续一段，使得和相同。 ​ 设$SA[i]$，$SB[i]$为A串的前缀和，B串的前缀和。不妨设$SA[n] &gt;= SB[n]$——否则可以交换，那么对于每个SA，我们找到在第二个序列中，找到满足SA[i] &gt;= SB[j]的最大的j。不难发现，$0&lt;=SA[i]-SB[j]&lt;=n-1$。而算上第0项，i总共有n+1种情况，所以一定能通过连续一段来构造。 ​ 这样，我们可以通过上述策略去构造。 AIM Tech Round (Div. 1) CF623A:一个由$a,b,c$组成的字符串，可以这样生成一张图，当$s[i]$与$s[j]$不是一个$a$一个$c$时，$i$与$j$连一条边。给定生成的图，求是否存在字符串能生成这张图。$n&lt;=500$ ​ 考虑把所有和其它所有点连边的赋值成b，然后剩余的，随便选一个赋值成a，将和他有连边剩余的赋值成c，然后验证答案是否矛盾。 CF623B:有一个数列，可以删除其中一段，删一个代价为$a$。也可以选择对其中一些数进行增加或者减少1，每次代价为$b$，问最后使得所有的$gcd$比1大，最小代价是多少。 DP ​ 注意到，最后$a1$，或者$an$一定是剩余的——可能进行一些操作。所以答案的$gcd$一定是$a1-1,a1,a1+1,an-1,an,an+1$这些数的质因子中的某一个。考虑枚举出质因子后，用3个DP分别表示还删，删完了，还在删的状态。 CF623C:平面上有$n$个点$(xi,yi)$。每个点可以变成$(xi,0)$，或$(0,yi)$。所有的点变换之后，两点最大距离的平方的最小值是多少。n&lt;=100000 二分答案 ​ Codeforces Round #342 (Div. 2) CF625A你有n元，有2种包装的物品，一种是a元，一种是b元，但是花了b元能反c元，问最多能获得多少武平$(1&lt;=n&lt;=10^18)$ 模拟，贪心(1A) ​ 考虑如果b-c比a要赚，那么先选择一个b，然后加上c……最后再去选a。模拟一下就行了。 CF625B在第一个串中最少把多少个字符修改为#，才能第一个串不包含第二个串。 贪心，KMP(3A) ​ 考虑一定是越后面修改越好的，所以贪心，同时跑的时候来一发KMP加速——其实也不需要。 CF625C让你用$1-n \\times n​$这些数填充$n\\times n​$矩阵，要求每行的数字严格递增、每个数字只能用一次且保证第k列的数字和最大。 贪心(1A) ​ 考虑把小的都放在左边，那么然后能往右边再往右边，贪心选数即可。 VK Cup 2016 - Round 1 CF639B：构造一棵树，使得树有n个节点，直径是D，树高是H，不存在输出-1 构造 显然，D&gt;2*H无解。否则，考虑先把直径画好。 ​ 直径分为两部分，两部分分别画好，然后再把剩下的点弄到1号那里 ​ D=H要特殊处理。 CF639C：定义一个合法的n次多项式f(x)，满足最高项系数an!=0，所有系数ai都是整数，且绝对值不超过K。 现在给您一个合法的n次多项式P(x)，但P(2)!=0。您需要改变其中一个系数，仍然得到一个n次多项式Q(x)。满足Q(2)=0。求方案数。$n&lt;=200000$ 多项式 ​ 考虑把系数转化成二进制，除了最高位。 ​ 那么要使得可以消掉，必然是满足当前的系数左边没有1或者-1。 ​ 那么考虑把系数转化成二进制后，倒着把系数推回来，得到右边一段的系数相当于是多少，记为sum ​ sum的求值可以每次 2+当前元素得到。那么如果i左边的系数（小的系数）满足都是0，那么我们知道，当前这个Q的值显然就是$sum 2^i$。所以只要把这一位的系数减去这个sum，就能保证整个$Q(2) = 0$。 ​ 因此，我们只需要先正着扫一遍，得到最低的非0位的位置。 ​ 然后倒着扫一遍，得到sum，并统计。 ​ 注意的是，当sum&gt;2*k的时候，已经没有必要继续统计了。 CF639D：有n个人，每个人都有自己的贡献ti（任意整数）可以花费b，使得某个人的贡献+5,花费c，使得某个人的贡献+1.求至少使得k个人的贡献相等，最少需要的花费。$k&lt;=n&lt;=200000,$$1&lt;=b,c&lt;=1000$ $|t_i|&lt;=1e9$ 优先队列维护前k小的数的和 ​ 考虑首先对于输入的数排序。同时如果$b=min(b,c\\times 5)$，那么得到所有可能最后的相同的那个数（一定不会超过某个数+0,1,2,3,4,5这个范围），然后考虑枚举所有的Ans，下一步的操作是要在所有数中寻找满足条件的最小花费的k个数。可以把花费看作一些数，先变成对应的mod 5=r的数，然后再一直加上b。考虑到我们已经排序了，所以这个右指针（哪些是包含的）是会单调递增的。设x mod 5 = r;考虑预处理出每一个数到mod 5 = r的数值为t[i,r]，那么最后的最小花费必然是选出一些i，使得$min(∑(t[i,r] - a[i]) \\times c + ∑(x - t[i,r]) / 5 \\times b)$，考虑到x[i]和t[i,r]的余数是一样的，可以化简为 $$\\large k \\times （x / 5 \\times b） + \\sum _{i}^{t[i,r]&lt;=x}(t[i,r] \\times c - a[i] \\times c - t[i,r] / 5 \\times b)$$ 考虑维护5个堆，得到这5个堆中元素和，压入一个元素，加上这个sum，如果元素个数超过k，将大的弹出来，减去这个sum。 VK Cup 2016 - Round 2 CF641B原来有一个N*M的矩阵，要求满足一些操作(q个）：循环左移，循环上移，在给定位置加数，给你最后的矩阵，问最初的矩阵是？？ 模拟(1A) ​ 考虑把操作倒着执行，当然，左移变成右移，上变成下，然后就可以了。 CF641C给定n个数，1, 2, 3, 4, 5, 6,…, n。有两种操作，第一个操作是所有数向右边移动x个位置，第二个操作奇数和偶数的位置互换。$n &lt;= 1,000,000$ $q &lt;= 2,000,000$ 模拟 ​ 考虑到，比如说有序列12345678，那么不管怎么操作，1357，2468的相对位置是不变的（循环一下），所以我们只需要知道1和2的位置，就能确定所有的位置。而1和2的位置可以通过模拟出来。 CF641D:有两个不同的骰子，点数为$1~n$。得到每个点数的概率可能不同（总和一定是$1$）。掷出这两个骰子，得到点数$a$，$b$。取$max(a,b)$, $min(a,b)$。给出$max(a,b)=c$的概率分布，和min(a,b)=c的概率分布。还原两个骰子点数的概率分布。所有概率之和为$1$。$n&lt;=100,000$ 概率(1A) ​ 注意到，我们可以列出这样2个方程：​ $sumy x[p] + sumx y[p] + x[p] y[p] = Pmax$​ $x[p] + y[p] = Pmax + Pmin$​ 然后解这两个方程​ $y[p] = Pmax + Pmin - x[p]$​ $sumy x[p] + sumx (Pmax + Pmin - x[p]) + x[p] (Pmax + Pmin - x[p]) = Pmax$ ​ $p[x]^2 + (Pmax + Pmin + sumy - sumx) x[p] + ((Pmax + Pmin )sumx - Pmax) = 0$​ 注意，当b^2-4ac几乎等于0的时候(可能小于0），那么不妨让b^2-4ac等于0 CF641E:有三个操作:$1$ $x$ $y$，在第$x$秒插入一个$y$；$2$ $x$ $y$，在第$x$秒移走一个$y$ ；$3$ $x$ $y$, 问第$x$秒有多少个$y$ $(1 ≤ n ≤ 100 000) $ 树状数组，MAP(2A) ​ $multiset$的$count$复杂度竟然不是$log$的……好吧，这题把时间离散化，然后用树状数组，每个节点保存一个$MAP$，复杂度是$log^2$的，然后就可以过了。 Codeforces Round #345 (Div. 1) CF650D给定一个长度为n的数列，和m个询问，每个询问给出Ai,Bi表示把第Ai个数改成Bi之后，这个数列的最长上升子序列（严格大于,询问相互独立） 线段树 ​ 具体做法分成2部分。一方面，我们要求得改过之后经过改过的点的LIS。这个比较好实现，离散化之后排个序离线用两棵线段树正反两次扫描维护。另一方面，我们要求得不经过这个点的LIS我们再把这个分为两部分。如果原来的LIS（至少有一条）不包括那个点，那么答案就是原来的LIS。如果所有的LIS都包括那个点，那么答案就是原来的LIS-1。一个点如何可能是LIS中的一个呢？注意到，当他的前缀LIS加上后缀LIS等于总的LIS+1的时候。那么我们只需要统计，这个点是不是唯一的这个位置。怎么样算唯一呢？就是它的前缀LIS（或者后缀）长度，除了它，没有别的点了。因此，我们只需要满足2个条件，这个点就是原来的LIS-1了。 ​ $1、L(LIS)_i+R(LIS)_i=Lis+1$ $2、there.is.only.one.L(LIS)_i$ ​ 还是通过正反两次扫描实现。 IndiaHacks 2016 - Online Edition CF653E:n个点，m条不能相连的边，点1的度为k（相连的边有且仅有k条）。问是否能构成一棵树。 set维护BFS ​ 考虑将1除去之后，得到剩下的联通块，其中有一个联通块没有向1的边，说明impossible，否则，如果联通块的数量大于等于k，说明无解。——因为联通块里面是可以随意连的。那么如何求联通块呢，考虑BFS。但是普通的BFS的复杂度会到$O(N^2)$，而这题的N比较大，是撑不住的，注意到，选取点有很大的冗余——因为每个点最多只会被访问1次，那么如何选点的？考虑用一个set维护还没有被访问过的点，访问一个点，将这个点从set中删去。对于某个点开始，寻找set中的元素，如果可以访问，那么访问，同时删去。 ​ 注意到，这个时间复杂度只有$O((n+m)log n)$。 Codeforces Round #347 (Div. 1) CF663B:给定一些类似$?+?-?=n$表达式，然后知道最后一个数字为n（给定），然后在前面填（1~n)的数，问可不可能有满足条件的等式，可能输出Possible并给出一组解。给定n个数，1, 2, 3, 4, 5, 6,…, n。有两种操作，第一个操作是所有数向右边移动x个位置，第二个操作奇数和偶数的位置互换。$n &lt;= 1,000,000$ $q &lt;= 2,000,000$ 脑洞(2A) ​ 考虑对于使得表达式最小的式子，加是+1，减是-n，再考虑使得表达式最大的式子，加是+n，减是-1，那么如果n在两者之间，这个式子一定可以通过一定的改变得到，否则就是不行。 ​ 为了实现简单，只要统计加法有多少，减法有多少就可以得到了。构造主要可以这样实现，对于每一个位置，找到一个最小的使得后面依旧可以填的(这个值不会很大)。这样好实现很多。然后n去掉这个值，继续处理。虽然可以二分，但是麻烦。注意如果你是改变n的，记得保存一个n的镜像。 CF663B:给出了一个数字的后缀，要求最终这个数字大于等于1989，并且在最小的情况下，这个数字之前没有被占用过。求最终拼凑的数字。 不会QAQ CF663C:有一个n个点，m条边的无向图，一开始，每条边的颜色都是给定的，然后玩家选择一个顶点，把相邻的边的颜色反转一下，问使得所有边颜色相同最少反转几下，输出那些反转的顶点，不可以输出-1.$(1 ≤ n, m ≤ 100 000)$ 并查集(6A) ​ 不失一般性，考虑把所有边的颜色变成红色，那么可以把整个图分成不同的联通块，每个联通块分别处理。如果有一条边是蓝色的，说明这条边的左右两端的状态是不同的，如果是红色的，说明状态是相同的。对于一个联通块，显然只有2类。那么我们只需要在2类中取较小的一类即可。 ​ 考虑用2个并查集，分别维护相同类和不同类。 CF663D: 不会QAQ CF663E:有一个n*m的表格，包含0或1.每一次可以选择一行，或一列翻转(0&lt;-&gt;1)。求一些操作后，1的个数的最小值。$n&lt;=20, m&lt;=100000 $ FWT优化(4A) ​ 很容易想到一个暴力，是枚举行变化$O(2^n)$，然后贪心验证$O(n*m)$，然后利用位运算，可以通过预处理先得到$v_i$表示$i$，或者$i$的翻转包含的最少的1的个数($i$是一状压二进制)，$v_i = min(|i|,n-|i|)$，那么设某一列状压之后是$A_i$，当前枚举到行变化是$s$，那么如果用$Ans[s]$表示在s状态能够获得的最大$Ans$，用$cnt[i]$表示所有列中$i$出现了几次可以得到， $$\\large Ans[s] =\\sum{i=0}^{2^n-1} v{s⊕i} * cnt_i$$ ————然后，上面这个式子是可以通过FWT优化的，因为这个等价于存在两个向量$cnt$和$v$，然后要求它们的亦或卷积得到的另一个向量。 $$\\large Ans[s] = \\sum_{j⊕k =i}cnt_j*v_k$$ 因此，跑一个 $$FWT(A) = (FWT(A0)+FWT(A1),FWT(A0)-FWT(A1))$$ $$IFWT(A)=IFWT((A0+A1) \\div2,(A0-A1)\\div2)$$ 最后来一个统计就有结果了——虽然我也不知道怎么构造，我也不知道怎么证明。 Codeforces Round #349 (Div. 1) CF666A给一个字符串，然后你你需要切一个长度至少为5的前缀下来，然后剩下的都得切成是长度为2或者3的字符串你需要连续的切出来的字符串都不一样，问你能够切出多少不同的块 DP(1A) ​ DP，考虑后面相邻的即可。 CF666B给定一个有向图，请您选择4个不同的节点，使得从第一个点出发，经过第2，3个点，最后到达第4个点。最短路之和最大。n&lt;=3000, m&lt;=5000。按照顺序输出选择的节点。 CF666C DP(抄题解1A) ​ 首先需要看出方案数只和模式串的长度有关，和具体的字符无关。 ​ 由于模式串的长度和规模为$10^5$，则不同长度模式串最多有$\\sqrt {2*10^5}$种，因而如果如果我们若能在线性时间内推出某长度下的结果，复杂就会变成$O(n\\sqrt n)$。 ​ 具体记数的过程比较复杂，需要考虑枚举模式串为第一次匹配的情况。 ​ 若$S$为主串，模式串为$P$，$a_i$为$|S|=i$时的方案数。 ​ $ai = 0$——$i&lt;|P|$ ​ $ai=26\\times a_{i−1} + C(n−1,i−1)\\times25^{i−|P|}$—–$i⩾|P|$ ​ $26a_{i−1}$包含了第一次匹配在$S1⋯Si−1$出现的情况，最后一个位置放啥都行。 ​ $C(n−1,i−1)\\times25^{i−|P|}$ 是在$S_i$才出现第一次匹配的情况。$S1⋯S{i−1}$能匹配$P1⋯P{|P|−1}$且$Si=P|P|$。最后一位确定，然后在$S1⋯S{i−1}$选择$Pi⋯P{|P|−1}$的匹配，即$C(n−1,i−1)$，剩余的位置每个位置都含有$25$种可能，因为不能是它之后第一个确定的位置的字符。 VK Cup 2016 - Round 3 CF643B给定$N$,$K$和$a$,$b$,$c$,$d$，问是否存在这样两条路劲，使得这两条路劲经过所有城市，并且从a到b，和从c到d，长度为N，整个边数不超过K。$(4 ≤ n ≤ 1000, n - 1 ≤ k ≤ 2n - 2) $ 构造（4A） ​ 考虑分类讨论，能公用的尽量公用，注意到n=4的时候，a,b,c,d互不相同是不行的 CF643C要把1～n分成k组，每组内的数必须连续，组与组不相交且每个数必须属于一个组，并且任意i有一个参数$ti$。 如果$[l,r]$为一组，那么从l走到l+1的概率是$tl$，从$l+1$走到$l+2$的概率是$\\frac{tl+tl+1}{tl+1}$，依次类推，从$l$要么走到$l+1$，要么原地不动，那么组$[l,r]$的费用就是从$l$走到$r$的期望次数。现在要分成k组，让总费用最小，每个数仅能属于一个组。","categories":[],"tags":[{"name":"codeforces","slug":"codeforces","permalink":"http://yoursite.com/tags/codeforces/"}]},{"title":"圆桌问题","slug":"OI/网络流24题/第5题/5","date":"2017-08-18T12:02:35.615Z","updated":"2017-11-16T12:45:17.295Z","comments":true,"path":"2017/08/18/OI/网络流24题/第5题/5/","link":"","permalink":"http://yoursite.com/2017/08/18/OI/网络流24题/第5题/5/","excerpt":"有n个单位，每个单位有ri的人，有m个圆桌，每个圆桌可以容纳ci个人，要求使得同一个单位的人不在一个圆桌。求一种分组方法。","text":"有n个单位，每个单位有ri的人，有m个圆桌，每个圆桌可以容纳ci个人，要求使得同一个单位的人不在一个圆桌。求一种分组方法。 考虑建立边 相当于对于s到每个单位流一条ri的边，从圆桌到t连一条ci的边，每个单位和每个圆桌连一条1的边，然后跑一遍SAP。 这题不想多说………… n和m别搞错 其实就是二分图多重匹配问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;const int maxv = 505;const int maxe = maxv*maxv;const int oo = 1&lt;&lt;30;using namespace std;struct Edge&#123; int from,to,nxt,flow,cap;&#125;;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe * 2]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123;// printf(\"%d --&gt; %d:%d\\n\",a,b,c); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; int sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=0;i&lt;n;i++) cur[i] = first[i]; int u = s; while (dist[s] != n+1)&#123;// printf(\"U = %d --&gt;\",u); if (u == t)&#123;// puts(\"Add\"); int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123;// printf(\"%d %d %d\\n\",v,path[v],edge[path[v]].from); if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;int m,n,sum; int main()&#123; scanf(\"%d%d\",&amp;m,&amp;n); G.init(m+n+2); int s = 0,t = n+m+1; for (int i=1;i&lt;=m;i++)&#123; int W; scanf(\"%d\",&amp;W); sum = sum + W; G.add_edge(s,i,W); &#125; for (int i=1;i&lt;=n;i++)&#123; int W; scanf(\"%d\",&amp;W); G.add_edge(m+i,t,W); &#125; for (int i=1;i&lt;=m;i++)&#123; for (int j=1;j&lt;=n;j++)&#123; G.add_edge(i,m+j,1); &#125; &#125; int Ans = G.sap(s,t); if (Ans == sum)&#123; puts(\"1\"); for (int i =1;i&lt;=m;i++)&#123; for (int e=G.first[i];e!=-1;e=G.edge[e].nxt)&#123; if (((e &amp; 1) == 0) &amp;&amp; (G.edge[e].cap == G.edge[e].flow))&#123; printf(\"%d \",G.edge[e].to - m); &#125; &#125; puts(\"\"); &#125; &#125; else puts(\"0\"); &#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"魔术球问题","slug":"OI/网络流24题/第4题/4","date":"2017-08-18T12:02:35.591Z","updated":"2017-11-16T12:45:10.574Z","comments":true,"path":"2017/08/18/OI/网络流24题/第4题/4/","link":"","permalink":"http://yoursite.com/2017/08/18/OI/网络流24题/第4题/4/","excerpt":"有n根柱子，每次可以依次放入编号为1,2,3……个球，每次只能在最上面放球，要求同一根柱子中相邻两球的编号和为完全平方数，问n根柱子上最多能放多少球。","text":"有n根柱子，每次可以依次放入编号为1,2,3……个球，每次只能在最上面放球，要求同一根柱子中相邻两球的编号和为完全平方数，问n根柱子上最多能放多少球。 假设有 n 根柱子，现要按下述规则在这 n 根柱子中依次放入编号为 1，2，3，…的球。（1）每次只能在某根柱子的最上面放球。（2）在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。试设计一个算法，计算出在 n 根柱子上最多能放多少个球。例如，在 4 根柱子上最多可放 11 个球。对于给定的 n，计算在 n 根柱子上最多能放多少个球。 样例输入 ​ 4 样例输出 ​ 11 ​ 1 8 ​ 2 7 9 ​ 3 6 10 ​ 4 5 11 数据范围 ​ N&lt;=60 分析： ​ 我们可以考虑把两个可以相邻的点连上一条有向边，那么答案就是用n条路径覆盖1~Ans所有点。 ​ 可以考虑二分出Ans，然后判断前Ans个是否可行（用最小路径覆盖解决，可以见网络流练习3），可以发现，随着Ans的增大，需要的路劲数是单调非递减的。 ​ 就是从原来的模型——&gt;最小路径覆盖——&gt;二分图匹配——&gt;最大流 ​ 但是其实二分答案，因为每次都要重新建图，所以比较慢，可以考虑每次加入2个点，加入一些边，然后把dist数组重新弄成0，在原来的图的基础上继续找增广路。然后继续找增广路。这样最早得到一个不可行的Ans，Ans-1就是答案。 ​ 最后再把最后2个点删掉，重新跑一边最大流，然后输出方案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;bits/stdc++.h&gt;const int maxAns = 5000;const int maxv = maxAns*2+5;const int maxe = 3200000;const int oo = 1&lt;&lt;30;using namespace std;struct Edge&#123; int from,to,nxt,flow,cap;&#125;;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe * 2]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123;// printf(\"%d:%d --&gt; %d:%d\\n\",nume,a,b,c);// printf(\"Add:Edge[0] . from = %d\",edge[0].from); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; void init_sap()&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); memset(path,0,sizeof(path)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=0;i&lt;n;i++) cur[i] = first[i]; &#125; int sap(int s,int t)&#123; memset(dist,0,sizeof(dist)); int u = s; while (dist[s] != n+1)&#123; if (u == t)&#123; int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123; if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;int n,m;bool vis[maxv];int main()&#123; int s = 0,t = maxAns *2 + 1; G.init(maxAns*2+2); scanf(\"%d\",&amp;n); G.Reset(); int i; for (i=1;i&lt;=maxAns;i++)&#123; G.add_edge(s,i,1); G.add_edge(maxAns + i,t,1); for (int j=1;j&lt;i;j++)&#123; int t = (int)sqrt(1.0*(i+j)); if (t * t == (i+j))&#123; G.add_edge(j,i + maxAns,1); &#125; &#125; int rec = i - G.sap(s,t); if (rec &gt; n)&#123; break; &#125; &#125; //Ans = i int Ans = i-1; for (int j=0;j&lt;G.nume;j++)&#123; if ((G.edge[j].to == i) || (G.edge[j].to == i+maxAns) || (G.edge[j].from == i) || (G.edge[j].from == i+maxAns))&#123; G.edge[j].cap = 0; G.edge[j].flow = 0; &#125; &#125; G.Reset(); G.sap(s,t); /* for (int j=0;j&lt;G.nume;j++)&#123; if ((G.edge[j].to == i) || (G.edge[j].to == i+maxAns) || (G.edge[j].from == i) || (G.edge[j].from == i+maxAns))&#123; G.edge[j].cap = -1; G.edge[j].flow = -1; printf(\"Delete%d--&gt;%d\\n\",G.edge[j].from,G.edge[j].to); &#125; &#125;*/ memset(vis,false,sizeof(vis)); vis[i] = true; printf(\"%d\\n\",Ans); for (int i=1;i&lt;=Ans;i++)&#123; if (vis[i]) continue; int u = i; // printf(\"find(%d) = %d\\n\",i,u); while (true)&#123;// printf(\"%d,%d \\n\",vis[u],u); printf(\"%d \",u); vis[u] = true; bool found = false; for (int e=G.first[u];e!=-1;e=G.edge[e].nxt)&#123;// printf(\"%d--(%d,%d)-&gt;%d\\n\",u,G.edge[e].cap,G.edge[e].flow,G.edge[e].to); if (((e &amp; 1) == 0) &amp;&amp; (G.edge[e].cap == G.edge[e].flow) &amp;&amp; (!vis[G.edge[e].to - maxAns]))&#123; u = G.edge[e].to - maxAns; found = true; break; &#125; &#125; if (!found) break; &#125;// printf(\"\\n%d**\",i); puts(\"\"); &#125;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"最小路径覆盖问题","slug":"OI/网络流24题/第3题/3","date":"2017-08-18T12:02:35.533Z","updated":"2017-11-16T12:45:03.695Z","comments":true,"path":"2017/08/18/OI/网络流24题/第3题/3/","link":"","permalink":"http://yoursite.com/2017/08/18/OI/网络流24题/第3题/3/","excerpt":"给定一个DAG，问这个DAG的最小路劲覆盖数，以及哪些最小路劲（任意输出一个）","text":"给定一个DAG，问这个DAG的最小路劲覆盖数，以及哪些最小路劲（任意输出一个） 输入描述 第1 行有2个正整数n和m。n是给定有向无环图G 的顶点数，m是G 的边数。接下来的m行，每行有2 个正整数i和j，表示一条有向边(i,j)。 输出描述 将最小路径覆盖输出。从第1 行开始，每行输出一条路径。文件的最后一行是最少路径数。 样例输入 11 121 21 31 42 53 64 75 86 97 108 119 1110 11 样例输出 1 4 7 10 112 5 83 6 93 数据范围 n&lt;=150,m&lt;=6000 问题模型转化： 将一个点拆开，差成2个点，记为X,X’ 如果1到2有一条边，1到3有一条边，2到3有一条边 相当于建立一副二分图 1到2’有边权为1的边 1到3’有边权为1的边 2到3‘有边权为1的边 如果两个点之间有一条边，意味着两个点可以同时在一条路劲上存在。 因此 DAG最小路劲覆盖数=总点数-一个神奇的二分图的最大匹配。 这里只考虑方案数，因为方案其实只需要做完之后顺着一个点正向反向BFS几一下，然后最长的即可。 下面给出只考虑方案的代码： http://codevs.cn/problem/1904/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;const int maxv = 350;const int maxe = maxv*maxv;const int oo = 1&lt;&lt;30;using namespace std;struct Edge&#123; int from,to,nxt,flow,cap;&#125;;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe * 2]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123;// printf(\"%d --&gt; %d:%d\\n\",a,b,c); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; int sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=0;i&lt;n;i++) cur[i] = first[i]; int u = s; while (dist[s] != n+1)&#123;// printf(\"U = %d --&gt;\",u); if (u == t)&#123;// puts(\"Add\"); int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123;// printf(\"%d %d %d\\n\",v,path[v],edge[path[v]].from); if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123;// printf(\"\\nU = %d --&gt;**\\n\",u); bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e;// printf(\"\\n%d--&gt;path[%d] = %d:%d\\n\",u,edge[e].to,e,edge[e].from); u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;int n,m;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); G.init(2*n+2); int s = 0,t = n*2+1; for (int i=1;i&lt;=m;i++)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); G.add_edge(a,n+b,1); &#125; for (int i=1;i&lt;=n;i++)&#123; G.add_edge(s,i,1); G.add_edge(i+n,t,1); &#125; printf(\"%d\\n\",n - G.sap(s,t));&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"最大权闭合子图","slug":"OI/网络流24题/第2题/2","date":"2017-08-18T12:02:35.505Z","updated":"2017-11-16T12:44:57.263Z","comments":true,"path":"2017/08/18/OI/网络流24题/第2题/2/","link":"","permalink":"http://yoursite.com/2017/08/18/OI/网络流24题/第2题/2/","excerpt":"最大权闭合子图问题，有n个实验，每个实验要一些工具，每个工具需要花费，每个实验可以得到收益，求最大化收益。","text":"最大权闭合子图问题，有n个实验，每个实验要一些工具，每个工具需要花费，每个实验可以得到收益，求最大化收益。 W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 E={E1，E2，…，Em}，和进行这些实验需要使用的全部仪器的集合 I={I1， I2，… I n } 。实验 Ej需要用到的仪器是 I 的子集 Rj˝I。配置仪器 Ik的费用为 ck美元。实验 Ej的赞助商已同意为该实验结果支付 pj美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。 对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。 输入描述 Input Description 第 1 行有 2 个正整数 m和 n。m 是实验数，n 是仪器数。接下来的 m 行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的 n 个数是配置每个仪器的费用。 输出描述 Output Description 第 1 行是实验编号；第 2行是仪器编号；最后一行是净收益。 样例输入 Sample Input 2 3 10 1 2 25 2 3 5 6 7 样例输出 Sample Output 1 2 1 2 3 17 这题是典型的最大权闭合子图。 这题我们可以这样考虑如果全部做，不买物品，总收益为S 对于一个实验，要么是实验做（相当于花费购买器械的价格），要么是实验不做（相当于减去这个实验的收益） 然后最后我们要最大化收益，也就是使得花费最小。可以考虑到最小割——&gt;最大流 具体这样建图（样例）： 最后求哪些最小割我是穷举每条边重新跑的，其实没有必要，因为这题有SPJ（不一定字典序最小之类），所以一般只需要重新开始沿着没有被割的边BFS即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;bits/stdc++.h&gt; using namespace std;const int maxv = 150;const int maxe = 30000;struct Edge&#123; int from,to,nxt,cap,flow;&#125;; int Mark[maxv],Sum;bool choice[maxv],C[maxv];const int oo = 1&lt;&lt;25;class Graph&#123; public: int first[maxv],n,Max_flow,nume; int num[maxv],dist[maxv],cur[maxv]; int path[maxv]; Edge edge[maxe]; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123; edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; edge[nume] . cap = c; edge[nume] . flow = 0; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . nxt = first[b]; edge[nume] . cap = 0; edge[nume] . flow = 0; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++)&#123; edge[i].flow = 0; &#125; &#125; int sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); memset(dist,0,sizeof(dist)); for (int i=1;i&lt;=n;i++) cur[i] = first[i]; int u = s; while (dist[s] != n+1)&#123; if (u == t)&#123; int Min_flow = oo; int break_point = -1; for (int v = u;v!=s;v=edge[path[v]].from)&#123; if (Min_flow &gt;= edge[path[v]].cap - edge[path[v]].flow)&#123; Min_flow = edge[path[v]].cap - edge[path[v]].flow; break_point = edge[path[v]].from; &#125; &#125; Max_flow += Min_flow; for (int v = u;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((dist[u] == dist[edge[e].to] + 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; cur[u] = e; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n + 1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to]+1); &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u!=s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125; ;&#125;G;char c = '.';int read(int x)&#123; while ((!((c&gt;='0') &amp;&amp; (c&lt;='9'))) &amp;&amp; ((c!='\\n') || (x == 1))) c=getchar(); if (c == '\\n') return -1; int a = 0; while ((c&gt;='0') &amp;&amp; (c&lt;='9'))&#123; a = a * 10 + c - 48; c=getchar(); &#125; return a;&#125;int m,n;int Son[maxv][maxv];int main()&#123; m = read(1);n = read(1); Sum = 0; G.init(1+m+n+1); for (int u=1;u&lt;=m;u++)&#123; Son[u][0] = 0; int value = read(1); Sum = Sum + value; G.add_edge(1,1+u,value); for (Son[u][++Son[u][0]] = read(0);Son[u][Son[u][0]]!=-1;Son[u][++Son[u][0]]=read(0))&#123; G.add_edge(1+u,1+m+Son[u][Son[u][0]],oo); &#125; &#125; for (int i=1;i&lt;=n;i++)&#123; int dis = read(1); G.add_edge(1+m+i,1+n+m+1,dis); &#125; int Max_flow = G.sap(1,1+n+m+1); for (int e=G.first[1];e!=-1;e=G.edge[e].nxt) if ((e &amp; 1) == 0)&#123;//如果是正向边 //尝试去掉这条边 int tmp1 = G.edge[e].cap; G.edge[e].cap = 0; int tmp2 = G.sap(1,1+n+m+1); G.edge[e].cap = tmp1; if (G.edge[e].cap - G.edge[e].flow != tmp2) choice[G.edge[e].to-1] = true; &#125; memset(C,0,sizeof(C)); for (int i=1;i&lt;=m;i++)&#123; if (choice[i])&#123; printf(\"%d \",i); for (int j=1;j&lt;=Son[i][0];j++)&#123; C[Son[i][j]] = true; &#125; &#125; &#125; puts(\"\"); for (int i=1;i&lt;=n;i++)&#123; if (C[i]) printf(\"%d \",i); &#125; puts(\"\"); printf(\"%d\\n\",Sum-Max_flow);&#125;/*2 310 1 225 2 35 6 7*/","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"二分图最大匹配问题","slug":"OI/网络流24题/第1题/1","date":"2017-08-18T12:02:35.473Z","updated":"2017-11-16T12:44:50.601Z","comments":true,"path":"2017/08/18/OI/网络流24题/第1题/1/","link":"","permalink":"http://yoursite.com/2017/08/18/OI/网络流24题/第1题/1/","excerpt":"​ 从前一个和谐的班级，有 nl 个是男生，有 nr 个是女生。编号分别为 1,…,nl 和 1,…,nr。 有若干个这样的条件：第 v 个男生和第 u个女生愿意结为配偶。 请问这个班级里最多产生多少对配偶？","text":"​ 从前一个和谐的班级，有 nl 个是男生，有 nr 个是女生。编号分别为 1,…,nl 和 1,…,nr。 有若干个这样的条件：第 v 个男生和第 u个女生愿意结为配偶。 请问这个班级里最多产生多少对配偶？ 输入格式第一行三个正整数，nl,nr,m。 ​ 接下来 m 行，每行两个整数 v,u 表示第 v 个男生和第 u 个女生愿意结为配偶。保证 1≤v≤nl1≤v≤nl，1≤u≤nr1≤u≤nr，保证同一个条件不会出现两次。 输出格式第一行一个整数，表示最多产生多少对配偶。 接下来一行 nl个整数，描述一组最优方案。第 v 个整数表示 v 号男生的配偶的编号。如果 v 号男生没配偶请输出 0。 考虑2种做法，第一种是建图+SAP，最后判断哪些边是被流满了的。 如图： 用Dinic或者SAP，速度是比较快的，大概是sqrt(n)*m，但是代码比较长，这里推荐第二种做法：匈牙利 匈牙利算法主要是基于增广路，也就是每次经过男生~女生~男生~女生，一直到一个未匹配的女生，结束，然后两两对应匹配。时间复杂度O(n^3)——邻接表（数组模拟链表）存和邻接矩阵存差不多，下面给出邻接表的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt; const int maxv = 505;int nl,nr,m,ans; int Map[maxv][maxv],link[maxv],Ans[maxv]; bool vis[maxv]; using namespace std; bool Hungary(int u)&#123; for (int v=1;v&lt;=nr;v++)&#123; if (!vis[v] &amp;&amp; Map[u][v])&#123; vis[v] = true; if (link[v] == -1 || Hungary(link[v]))&#123; link[v] = u; return true; &#125; &#125; &#125; return false; &#125; int c,x; int main()&#123; memset(Map,false,sizeof(Map)); scanf(\"%d%d%d\",&amp;nl,&amp;nr,&amp;m); for (int i=1;i&lt;=m;i++)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); Map[a][b] = true; &#125; ans = 0; memset(link,-1,sizeof(link)); for (int k=1;k&lt;=nl;k++)&#123; memset(vis,false,sizeof(vis)); if (Hungary(k)) ans++; &#125; printf(\"%d\\n\",ans); memset(Ans,0,sizeof(Ans)); for (int i=1;i&lt;=nr;i++)&#123; Ans[link[i]] = i; &#125; for (int i=1;i&lt;=nl;i++)&#123; printf(\"%d \",Ans[i]); &#125; return 0; &#125; 推荐在UOJ上提交，事实上各大OJ一般都有。","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"USACO5.4","slug":"OI/USACO/training/Section5/USACO5.4/USACO5-4","date":"2017-08-18T08:43:25.000Z","updated":"2017-08-20T14:51:00.695Z","comments":true,"path":"2017/08/18/OI/USACO/training/Section5/USACO5.4/USACO5-4/","link":"","permalink":"http://yoursite.com/2017/08/18/OI/USACO/training/Section5/USACO5.4/USACO5-4/","excerpt":"[TOC]","text":"[TOC] USACO5.4.1题意给定一个图，问一条从起点到终点，再从终点到起点，除了起点和终点外，不能经过重复节点的路劲，这条路劲最长有多长。（节点&lt;=100) 而且，是东西方向的，所以不存在类似1–&gt;3–&gt;2–&gt;4的，只有1–&gt;2–&gt;3–&gt;4的。 原题USACO5.4.1-Canada Tour Canada Tour You have won a contest sponsored by an airline. The prize is a ticket to travel around Canada, beginning in the most western point served by this airline, then traveling only from west to east until you reach the most eastern point served, and then coming back only from east to west until you reach the starting city. No city may be visited more than once, except for the starting city, which must be visited exactly twice (at the beginning and the end of the trip). You are not allowed to use any other airline or any other means of transportation. Given a list of cities served by the airline and a list of direct flights between pairs of cities, find an itinerary which visits as many cities as possible and satisfies the above conditions beginning with the first city and visiting the last city on the list and returning to the first city. PROGRAM NAME: tour INPUT FORMAT Line 1: The number N of cities served by the airline and the number V of direct flights that will be listed. N will be a positive integer not larger than 100. V is any positive integer. Lines 2..N+1: Each line contains a name of a city served by the airline. The names are ordered from west to east in the input file. There are no two cities in the same meridian. The name of each city is a string of, at most, 15 digits and/or characters of the Latin alphabet; there are no spaces in the name of a city. Lines N+2..N+2+V-1: Each line contains two names of cities (taken from the supplied list), separated by a single blank space. This pair is connected by a direct, two-way airline flight. SAMPLE INPUT (file tour.in) 8 9VancouverYellowknifeEdmontonCalgaryWinnipegTorontoMontrealHalifaxVancouver EdmontonVancouver CalgaryCalgary WinnipegWinnipeg TorontoToronto HalifaxMontreal HalifaxEdmonton MontrealEdmonton YellowknifeEdmonton Calgary OUTPUT FORMAT Line 1: The number M of different cities visited in the optimal itinerary. Output 1 if no itinerary is possible. SAMPLE OUTPUT (file tour.out) 7 Namely: Vancouver, Edmonton, Montreal, Halifax, Toronto, Winnipeg, Calgary, and Vancouver (but that’s not a different city). 做法这是一个无向图——至于字符串可以用Map来解决。 那么不能经过重复节点的，要到终点的2条路。 考虑用$f[i,j]$表示2条路劲，其中一条到了i，第二条到了j最多经过的城市 考虑对于一个城市k$$f[i,j] = max(f[i,k] + 1，f[k,j]+1);$$如果j到k右边，那么左边的是可行的，如果k到j有边，那么k到j是有边的 这样是不会重复的。 可以用归纳法解决，如果f[i,k]或者f[k,j]没有重复，那么加上只有一个城市到了j，所以也是不会有重复的。 把f函数改改 可以得到这些： ​ 1、$f[i,j] = f[j,i]$ 因此只要考虑把第二个k改变即可。 $f[i,j] = max(f[i,k] + 1)$ 百度到的做法Orz 相当于（除了1和n）每个点内部有容量为1，费用为1的边，外部是容量为1费用为0的边。跑最大费用最大流$Orz$ 好了，不管下面的做法。 给出DP代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*ID:cqz15311LANG:C++PROG:tour*/#include&lt;bits/stdc++.h&gt; using namespace std;string a,b;map&lt;string,int&gt; Name; const int inf = 0x3fffffff;bool g[105][105];int f[105][105],n,m,ans;char s[105],t[105];int main()&#123; freopen(\"tour.in\",\"r\",stdin); freopen(\"tour.out\",\"w\",stdout); cin &gt;&gt; n &gt;&gt; m; for (int i=1;i&lt;=n;i++)&#123; cin &gt;&gt; s; Name[s] = i; &#125; memset(g,false,sizeof(g)); for (int i=1;i&lt;=m;i++)&#123; cin &gt;&gt; s &gt;&gt; t; g[Name[s]][Name[t]] = true; g[Name[t]][Name[s]] = true; &#125; f[1][1] = 1; for (int i=1;i&lt;=n;i++)&#123; for (int j=i+1;j&lt;=n;j++)&#123; f[i][j] = -inf; for (int k=1;k&lt;j;k++) if (g[k][j] &amp;&amp; f[i][k]&gt;0 &amp;&amp; f[i][k]&gt;f[i][j]) f[i][j] = f[i][k]; f[j][i] = ++f[i][j];// printf(\"%d %d:%d\\n\",i,j,f[i][j]); &#125; &#125; ans = 1; for (int i=1;i&lt;=n;i++) if (g[i][n] &amp;&amp; f[i][n] &gt; ans) ans = f[i][n]; cout &lt;&lt; ans &lt;&lt; endl; fclose(stdin); fclose(stdout); return 0;&#125;/*Executing... Test 1: TEST OK [0.000 secs, 4236 KB] Test 2: TEST OK [0.000 secs, 4236 KB] Test 3: TEST OK [0.000 secs, 4236 KB] Test 4: TEST OK [0.000 secs, 4236 KB] Test 5: TEST OK [0.000 secs, 4236 KB] Test 6: TEST OK [0.000 secs, 4236 KB] Test 7: TEST OK [0.000 secs, 4236 KB] Test 8: TEST OK [0.000 secs, 4236 KB] Test 9: TEST OK [0.000 secs, 4236 KB] Test 10: TEST OK [0.000 secs, 4236 KB] Test 11: TEST OK [0.000 secs, 4236 KB]All tests OK.YOUR PROGRAM ('tour') WORKED FIRST TIME! That's fantastic-- and a rare thing. Please accept these special automatedcongratulations.*/ USACO5.4.2题意图像识别：给定_,a,b,……z的完整图像，然后给出一个破损的图像 每个完整字符长 20 行。 输入文件包含一个或多个可能损坏的字符图案。一个字符图案可能以这些方式被损坏。 最多有一行可能被复制了（就接在原来那一行的下面） 最多有一行可能丢失了 有些“0”可能被改成“1” 有些“1”可能被改成“0” 不会有任何一个字符图案既多余了一行并且又丢失了一行。在测试数据的任何一个字符图案中，“0”和“1”的被改变率不超过 30%。 原题USACO5.4.2-Character Recognition 给出输入问题http://train.usaco.org/usaco/font.in 做法​ 一脸懵逼Orz ​ 第一次接触到类似的题目Orz ​ 可不可以枚举每一个答案 ​ 然后枚举是哪一行删除，哪一行复制，然后计算匹配率QAQ ​ 这样的话 ​ 复杂度是$O(2727272020)$……好像不会超 ​ 可是怎么根据匹配率搞？ ​ 说真的我只会暴力模拟 ​ 事实上我题目都错了：不会有任何一个字符图案既多余了一行并且又丢失了一行QAQ ​ 吓得我感觉百度。 ​ 下面复述一下百度到的结果。++DP ​ 说真的，看了好几天还没懂QAQ。 ​ 设$b[i]$表示给定图从第$i$行开始匹配所能得到的最小差距 ​ $c[i,j]$表示给定图从第$i$行开始连续匹配$j$行所能得到的最小差距 ​ $dif[i,j,k]$表示第$i$个字符图的第j行与给定图的第k行的差距 ​ $b[i]:=min(b[i+19]+c[i,19],b[i+20]+c[i,20],b[i+21]+c[i,21])$ ​ j=19：枚举字母。设表示字符图前行匹配的差距，表示后行匹配的差距，则$c[i,j]:=min(pre[k]+tail[19-k]).$ ​ j=20：直接枚举字符，统计即可。 ​ j=21：与j=19相仿。 ​ 对于其中涉及到的统计问题，可以从dif[i,j,k]直接获得，避免了很多重复计算 ​ 应该不会有这么坑的题再出现了吧。 USACO5.4.3题意给定一个无向图，问字典序最小的最小点割集。 原题USACO5.4.3 - Telecowmunication SAMPLE INPUT (file telecow.in) 1233 2 1 21 32 3 SAMPLE OUTPUT (file telecow.out) 1213 做法考虑把每个点拆成2份，中间连一条边，权值为1. 当然，1号点和n号点权值无穷大 对于外面的边，权值为无穷大。 然后跑最小割（SAP）。","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO5.4.2","slug":"OI/USACO/training/Section5/USACO5.4/USACO5.4.2/USACO5-4-2","date":"2017-08-18T06:20:20.000Z","updated":"2017-08-18T06:32:48.721Z","comments":true,"path":"2017/08/18/OI/USACO/training/Section5/USACO5.4/USACO5.4.2/USACO5-4-2/","link":"","permalink":"http://yoursite.com/2017/08/18/OI/USACO/training/Section5/USACO5.4/USACO5.4.2/USACO5-4-2/","excerpt":"","text":"题意图像识别：给定_,a,b,……z的完整图像，然后给出一个破损的图像 每个完整字符长 20 行。 输入文件包含一个或多个可能损坏的字符图案。一个字符图案可能以这些方式被损坏。 最多有一行可能被复制了（就接在原来那一行的下面） 最多有一行可能丢失了 有些“0”可能被改成“1” 有些“1”可能被改成“0” 不会有任何一个字符图案既多余了一行并且又丢失了一行。在测试数据的任何一个字符图案中，“0”和“1”的被改变率不超过 30%。 原题USACO5.4.2-Character Recognition 给出输入问题http://train.usaco.org/usaco/font.in 做法一脸懵逼Orz 第一次接触到类似的题目Orz 可不可以枚举每一个答案 然后枚举是哪一行删除，哪一行复制，然后计算匹配率QAQ 这样的话 复杂度是$O(2727272020)$……好像不会超 可是怎么根据匹配率搞？","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO5.3","slug":"OI/USACO/training/Section5/USACO5.3/USACO5.3","date":"2017-08-17T04:41:43.000Z","updated":"2017-08-19T05:09:47.438Z","comments":true,"path":"2017/08/17/OI/USACO/training/Section5/USACO5.3/USACO5.3/","link":"","permalink":"http://yoursite.com/2017/08/17/OI/USACO/training/Section5/USACO5.3/USACO5.3/","excerpt":"[TOC]","text":"[TOC] USACO5.3.2window你刚刚接手一项窗体界面工程。窗体界面还算简单，而且幸运的是，你不必显示实际的窗体。有 5 种基本操作： 创建一个新窗体 将窗体置顶 将窗体置底 删除一个窗体 输出窗体可见部分的百分比（就是，不被其它窗体覆盖的部分）。 原题USACO5.3.2-Window 做法这题采用模拟大法 如何模拟 我们可以用一个链表存储QAQ。 保存底窗体，顶窗体。 同时保存前面的那个窗体，后面的那个窗体。 支持这些操作。 1、Remove 删除其中一个窗体 1234567void remove(int x)&#123; if (x == -1) return; if (x != tail) pre[nxt[x]] = pre[x]; if (x != head) nxt[pre[x]] = nxt[x]; if (x == tail) tail = pre[x]; if (x == head) head = nxt[x];&#125; 2、Addhead 在头加上一个窗体（用于置底操作） 1234567void Addhead(int x)&#123; pre[x] = -1; nxt[x] = head; if (head!=-1) pre[head] = x; head = x; if (tail==-1) tail = x;&#125; 3、Addtail 在尾部加上一个窗体（用于置顶操作） 1234567void Addtail(int x)&#123; nxt[x] = -1; pre[x] = tail; if (tail!=-1) nxt[tail] = x; tail = x; if (head==-1) head = x;&#125; ★顺着next指针寻找，利用漂浮法，矩阵切割，从而得到可以见到的面积。 12345678910111213141516171819202122int dfs(int l,int r,int u,int d,int n)&#123; while ((n != -1) &amp;&amp; ((l &gt;= R[n]) || (r &lt;= L[n]) || (u &gt;= D[n]) || (d &lt;= U[n]))) n = nxt[n]; if (n == -1) return (r-l) * (d-u); int rec = 0; if (l &lt; L[n])&#123; rec += dfs(l,L[n],u,d,nxt[n]); l = L[n]; &#125; if (r &gt; R[n])&#123; rec += dfs(R[n],r,u,d,nxt[n]); r = R[n]; &#125; if (u &lt; U[n])&#123; rec += dfs(l,r,u,U[n],nxt[n]); u = U[n]; &#125; if (d &gt; D[n])&#123; rec += dfs(l,r,D[n],d,nxt[n]); d = D[n]; &#125; return rec;&#125; USACO5.3.3题意给定一个有向图，然后在一些点上立flag，这些flag可以通过有向边传递 1、问使得所有点都被弄上flag最少要立多少flag 2、问最少加多少边使得这个图强连通 原题USACO5.3.3-schlnet 做法很显然的做法 先强连通分量缩点，缩完点后，求有多少个没有入度，那么就是结果1 第二问显然就是没有出度的分量和没有入度的分量之中取一个较大的。 注意只有一个强连通分量的特判QAQ 1A USACO5.3.4题意一个N N的矩阵中有T个点有树，(xi,yi)有一棵树，然后在NN的范围内，问最大的没有树的正方形的边长是多少。(N&lt;=1000,T&lt;=10000) 原题USACO5.3.4-bigbrn Big BarnA Special TreatFarmer John wants to place a big square barn on his square farm. He hates to cut down trees on his farm and wants to find a location for his barn that enables him to build it only on land that is already clear of trees. For our purposes, his land is divided into N x N parcels. The input contains a list of parcels that contain trees. Your job is to determine and report the largest possible square barn that can be placed on his land without having to clear away trees. The barn sides must be parallel to the horizontal or vertical axis. EXAMPLE Consider the following grid of Farmer John’s land where .&#39; represents a parcel with no trees and#’ represents a parcel with trees: 123456789 1 2 3 4 5 6 7 81 . . . . . . . .2 . # . . . # . .3 . . . . . . . .4 . . . . . . . .5 . . . . . . . .6 . . # . . . . .7 . . . . . . . .8 . . . . . . . . The largest barn is 5 x 5 and can be placed in either of two locations in the lower right part of the grid. PROGRAM NAME: bigbrn INPUT FORMAT Line 1: Two integers: N (1 &lt;= N &lt;= 1000), the number of parcels on a side, and T (1 &lt;= T &lt;= 10,000) the number of parcels with treesLines 2..T+1: Two integers (1 &lt;= each integer &lt;= N), the row and column of a tree parcelSAMPLE INPUT (file bigbrn.in) 8 32 22 66 3OUTPUT FORMAT The output file should consist of exactly one line, the maximum side length of John’s barn. SAMPLE OUTPUT (file bigbrn.out) 5 做法考虑枚举每一个点作为右下角的点，然后看能往左上角扩展多少。 考虑用f[i,j]表示第i行，第j列的答案 如果(i,j)是’#’，那么f[i,j] = 0 否则 f[i,j] = min( f[i,j-1],f[i-1,j],f[i-1,j-1]) + 1 为什么是这样的呢？ 首先f[i-1,j-1]是比较好理解的 假设f[i-1,j-1] = x 那么还需要横着和竖着的两条都是x得到。 那么好理解了吧QAQ","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO5.2.1","slug":"OI/USACO/training/Section5/USACO5.2.1/snail","date":"2017-08-14T09:20:40.000Z","updated":"2017-08-18T03:26:29.368Z","comments":true,"path":"2017/08/14/OI/USACO/training/Section5/USACO5.2.1/snail/","link":"","permalink":"http://yoursite.com/2017/08/14/OI/USACO/training/Section5/USACO5.2.1/snail/","excerpt":"题意有一个N*N的方格(N&lt;=120)，上面有B（B&lt;=200）个障碍，你从(1,1)出发，一开始可以向右或下走，一直碰到障碍，然后选择转90度再走，走到障碍，一直走，直到走的过程中经过了原来走过的格子。问最多能走过过多少格子","text":"题意有一个N*N的方格(N&lt;=120)，上面有B（B&lt;=200）个障碍，你从(1,1)出发，一开始可以向右或下走，一直碰到障碍，然后选择转90度再走，走到障碍，一直走，直到走的过程中经过了原来走过的格子。问最多能走过过多少格子 原题Snail TrailsAll Ireland Contest Sally Snail likes to stroll on a N x N square grid (1 &lt;n &lt;= 120). She always starts in the upper left corner of the grid. The grid has empty squares (denoted below by ‘.’) and a number (B) of barriers (denoted below by `#’). Here is a depiction of a grid including a demonstration of the grid labelling algorithm: 123456789 A B C D E F G H1 S . . . . . # .2 . . . . # . . .3 . . . . . . . .4 . . . . . . . .5 . . . . . # . .6 # . . . . . . .7 . . . . . . . .8 . . . . . . . . Sally travels vertically (up or down) or horizontally (left or right). Sally can travel either down or right from her starting location, which is always A1. Sally travels as long as she can in her chosen direction. She stops and turns 90 degrees whenever she encounters the edge of the board or one of the barriers. She can not leave the grid or enter a space with a barrier. Additionally, Sally can not re-cross any square she has already traversed. She stops her traversal altogether any time she can no longer make a move. Here is one sample traversal on the sample grid above: 123456789 A B C D E F G H1 S---------+ # .2 . . . . # | . .3 . . . . . | . .4 . . . . . +---+5 . . . . . # . |6 # . . . . . . |7 +-----------+ |8 +-------------+ Sally traversed right, down, right, down, left, up, and right. She could not continue since she encountered a square already visited. Things might have gone differently if she had chosen to turn back toward our left when she encountered the barrier at F5. Your task is to determine and print the largest possible number of squares that Sally can visit if she chooses her turns wisely. Be sure to count square A1 as one of the visited squares. PROGRAM NAME: snailINPUT FORMATThe first line of the input has N, the dimension of the square, and B, the number of barriers (1 &lt;= B &lt;= 200). The subsequent B lines contain the locations of the barriers. The sample input file below describes the sample grid above. The sample output file below is supposed to describe the traversal shown above. Note that when N &gt; 26 then the input file can not specify barriers to the right of column Z. SAMPLE INPUT (file snail.in)123458 4E2A6G1F5 OUTPUT FORMATThe output file should consist of exactly one line, the largest possible number of squares that Sally can visit. SAMPLE OUTPUT (file snail.out)133 Using this traversal: 123456789 A B C D E F G H1 S . . . . . # .2 | . . . # . . .3 | . . . +-----+4 | . . . | . . |5 +-------+ # . |6 # . . . . . . |7 +------------ |8 +-------------+ 做法这题的做法的本质就是一个DFS的搜索。 走还是转。 然后弄一个数组保存哪些格子走过了。 输入比较繁琐。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*ID:cqz15311LANG:C++PROG:snail*/#include&lt;bits/stdc++.h&gt;const int maxn = 125;using namespace std;const int dx[4] = &#123;-1, 0,0,1&#125;;const int dy[4] = &#123; 0,-1,1,0&#125;;#define UP 0#define LEFT 1#define RIGHT 2#define DOWN 3bool vis[maxn][maxn];bool f[maxn][maxn];char s[5];int n,B,Ans;int getnum()&#123; int a = 0; for (int i=1;s[i];i++) a = a*10+s[i]-48; return a;&#125;void PT()&#123; for (int i=0;i&lt;=n+1;i++)&#123; for (int j=0;j&lt;=n+1;j++)&#123; if (vis[i][j]) putchar('V'); else if (f[i][j]) putchar('#'); else putchar('.'); &#125; puts(\"\"); &#125; puts(\"\");&#125;void dfs(int x,int y,int fx,int cnt)&#123; int _x,_y;// printf(\"X = %d %d %d\\n\",x,y,fx); if (f[x][y] || vis[x][y]) return; if (cnt &gt; Ans) Ans = cnt; vis[x][y] = true;// printf(\"%d %d\\n\",x,y);// PT(); _x = x + dx[fx]; _y = y + dy[fx]; if (f[_x][_y])&#123; for (int d=0;d&lt;4;d++) dfs(x + dx[d ],y+dy[d ],d ,cnt+1); &#125;//前面是障碍 else dfs(x + dx[fx],y+dy[fx],fx,cnt+1); vis[x][y] = false;&#125;int main()&#123; freopen(\"snail.in\",\"r\",stdin); freopen(\"snail.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;B); memset(f,0,sizeof(f)); for (int i=1;i&lt;=n;i++) f[0][i] = f[n+1][i] = 1; for (int i=1;i&lt;=n;i++) f[i][0] = f[i][n+1] = 1; for (int i=1;i&lt;=B;i++)&#123; scanf(\"%s\",&amp;s); f[getnum()][s[0] - 'A' + 1] = 1; &#125; Ans = 0; memset(vis,false,sizeof(vis)); dfs(1,1,RIGHT,1); dfs(1,1,DOWN,1); printf(\"%d\\n\",Ans); fclose(stdin); fclose(stdout);&#125; 速度还是很快的 Executing… Test 1: TEST OK [0.014 secs, 4208 KB] Test 2: TEST OK [0.014 secs, 4208 KB] Test 3: TEST OK [0.014 secs, 4208 KB] Test 4: TEST OK [0.014 secs, 4208 KB] Test 5: TEST OK [0.014 secs, 4208 KB] Test 6: TEST OK [0.014 secs, 4208 KB] Test 7: TEST OK [0.014 secs, 4208 KB] Test 8: TEST OK [0.014 secs, 4208 KB] Test 9: TEST OK [0.014 secs, 4208 KB] Test 10: TEST OK [0.014 secs, 4208 KB] Test 11: TEST OK [0.014 secs, 4208 KB] Test 12: TEST OK [0.112 secs, 4208 KB] All tests OK.YOUR PROGRAM (‘snail’) WORKED FIRST TIME! That’s fantastic– and a rare thing. Please accept these special automatedcongratulations.","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"}]},{"title":"USACO5.1.3","slug":"OI/USACO/training/Section5/USACO5.1.3/theme","date":"2017-08-14T07:10:03.000Z","updated":"2017-08-18T03:26:38.673Z","comments":true,"path":"2017/08/14/OI/USACO/training/Section5/USACO5.1.3/theme/","link":"","permalink":"http://yoursite.com/2017/08/14/OI/USACO/training/Section5/USACO5.1.3/theme/","excerpt":"Musical Themes题意 ​ 给定一个长度为N（N&lt;=5000)的数字串(0~88)，问最长的一个子串，使得除了这个子串外，还有一个与该子串重合位置的另一个长度相同子串的对应位置都是该子串的对应位置增加","text":"Musical Themes题意 ​ 给定一个长度为N（N&lt;=5000)的数字串(0~88)，问最长的一个子串，使得除了这个子串外，还有一个与该子串重合位置的另一个长度相同子串的对应位置都是该子串的对应位置增加 原题Brian Dean A musical melody is represented as a sequence of N (1 &lt;= N &lt;= 5000) notes that are integers in the range 1..88, each representing a key on the piano. It is unfortunate but true that this representation of melodies ignores the notion of musical timing; but, this programming task is about notes and not timings. Many composers structure their music around a repeating “theme”, which, being a subsequence of an entire melody, is a sequence of integers in our representation. A subsequence of a melody is a theme if it: is at least five notes long appears (potentially transposed – see below) again somewhere else in the piece of music is disjoint from (i.e., non-overlapping with) at least one of its other appearance(s) Transposed means that a constant positive or negative value is added to every note value in the theme subsequence. Given a melody, compute the length (number of notes) of the longest theme. One second time limit for this problem’s solutions! PROGRAM NAME: themeINPUT FORMATThe first line of the input file contains the integer N. Each subsequent line (except potentially the last) contains 20 integers representing the sequence of notes. The last line contains the remainder of the notes, potentially fewer than 20. SAMPLE INPUT (file theme.in)1233025 27 30 34 39 45 52 60 69 79 69 60 52 45 39 34 30 26 22 1882 78 74 70 66 67 64 60 65 80 OUTPUT FORMATThe output file should contain a single line with a single integer that represents the length of the longest theme. If there are no themes, output 0. SAMPLE OUTPUT (file theme.out)15 [The five-long theme is the last five notes of the first line and the first five notes of the second] 做法做法很多。 下面给出我的做法。 第一想法是哈希。 从而想到了二分答案。 加入现在知道了长度D，只是问存不存在2个长度为D的串可能。 那么存不存在呢？ 如果简单的哈希，难的就是因为有可能转调 经过思考，查询一些题解，找到了一个好的方法 ——转自nocow—— ​ 这个题考虑到相同的旋律之间的差是常数，可以把读入的序列变换一下。就是每个元素与其前一个元素做差。例如原序列 {3,5,7,3,4,4,6,8,4}，做差后是{2,2,-4,1,0,2,2,-4}。这样就可以在变换后的序列中直接查找最长的重复序列即可。上述例子中是2,2,-4，长度为3，对应原序列中3,5,7,3，长度为4。 上述转化后我们就可以通过寻找最长重复串来做到。 做法1 ​ 可以通过上述转化后，以每一个为截开的位置，跑KMP。(N^2) 做法2 ​ 还是我刚才那个想法，每次二分后O(N)扫描，得到这个点以及这个点一直到前面总D个长度的哈希值——如果哈希值相同，很大可能是和前面的重复的，然后D+1就是最终的答案。(N log N) ​ 我后来写这种做法遇到了好多坑——建议大家多练习一下hash的题目，特别是应该多取几个模数，当然我取了2个bit。具体的细节很繁琐，可以看一下代码。 ​ 虽然速度比较快，但是我不推荐这种做法，更简单的做法往下看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/*ID:cqz15311LANG:C++PROG:theme*/#include&lt;bits/stdc++.h&gt;const int Mod = (1e6+7);//好像1e7就超空间了.const int bit1 = 17;const int bit2 = 23;//但位17好像第八个点过了，第九个点WA了//其实可以多重哈希，多取几个模数。//我弄了2个bit就能过USACO所有数据了——其实最好还是取模数，代码改改少 //其实如果是17，3之类的我试了一下是WA的，懒惰就改数字，其实最好是改模数//这题坑了我好久，但是说到底还是Hash的题目做得少。//或者说，以前做hash的题目都不卡单hash的。const int maxn = 5005;using namespace std;typedef long long LL;int Hash1[Mod],Hash2[Mod];LL f1[maxn],f2[maxn],a[maxn];LL Pow1[maxn],Pow2[maxn];int n,L,R,Mid;bool check(int Len)&#123; LL rec1 = 0,rec2 = 0; for (int i=1;i&lt;=Len;i++) rec1 = (rec1 * bit1 + a[i]) % Mod,rec2 = (rec2 * bit2 + a[i]) % Mod; f1[Len] = rec1; f2[Len] = rec2; for (int i=Len+1;i&lt;=n;i++)&#123; rec1 = (((rec1 - Pow1[Len-1] * a[i - Len]) % Mod + Mod) % Mod * bit1 + a[i]) % Mod; rec2 = (((rec2 - Pow2[Len-1] * a[i - Len]) % Mod + Mod) % Mod * bit2 + a[i]) % Mod; f1[i] = rec1; //注意是Len-1不是Len——卡了N久 f2[i] = rec2; &#125; bool flag = false; for (int i=Len;i&lt;=n;i++)&#123; if (Hash1[f1[i]] == -1) Hash1[f1[i]] = i; if (Hash2[f2[i]] == -1) Hash2[f2[i]] = i; if ((Hash1[f1[i]] &lt; i - Len/*+1*/) &amp;&amp; (Hash2[f2[i]] &lt; i - Len)) flag = true; /*不能加一，因为差分过的最后一个等于前面最前面的一个*/ &#125; for (int i=Len;i&lt;=n;i++)&#123; Hash1[f1[i]] = -1; Hash2[f2[i]] = -1; &#125; if (flag) return true; else return false;&#125;int main()&#123; freopen(\"theme.in\",\"r\",stdin); freopen(\"theme.out\",\"w\",stdout); Pow1[0] = 1,Pow2[0] = 1; memset(Hash1,-1,sizeof(Hash1)); memset(Hash2,-1,sizeof(Hash2)); for (int i=1;i&lt;=5000;i++)Pow1[i] = Pow1[i-1] * bit1 % Mod; for (int i=1;i&lt;=5000;i++)Pow2[i] = Pow2[i-1] * bit2 % Mod; scanf(\"%d\",&amp;n); a[0] = 0; for (int i=0;i&lt;n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; for (int i=n-1;i&gt;=1;i--)&#123; a[i] = a[i] - a[i-1]; a[i] = (a[i] % Mod + Mod) % Mod; &#125;//a0没用 n--; L = 1; R = n; while (L &lt; R)&#123; Mid = (L + R + 1) &gt;&gt; 1; if (check(Mid))&#123; L = Mid; &#125; else R = Mid - 1; &#125; if (L+1 &lt; 5) puts(\"0\"); else printf(\"%d\\n\",L + 1); fclose(stdin); fclose(stdout); return 0;&#125; 算法3 考虑用DP[i,j]表示左边匹配到i，右边匹配到j的最大匹配数。——直接跑，都不用转化…… Let theme(i,j) be the length of the longest theme which occurs starting at both note i and j. Note that if note[i+1]-note[i] == note[j+1]-note[j], than theme(i,j) = 1+theme(i+1,j+1). Otherwise, theme(i,j) = 1. Thus, we order the search in such a way that theme(i,j) is tested immediately after theme(i+1,j+1), keeping track of the length of the current theme, as well as the length of the longest theme found so far. http://train.usaco.org/usacoanal2?a=2ocZH3qaoaJ&amp;S=theme 12345678910111213141516171819202122232425262728293031323334353637#include &lt;fstream.h&gt;int n;int note[5000];int main () &#123; ifstream filein (\"theme.in\"); filein &gt;&gt; n; for (int i = 0; i &lt; n; ++i) filein &gt;&gt; note[i]; filein.close (); int longest = 1; for (int i = 1; i &lt; n; ++i) &#123; int length = 1; for (int j = n - i - 1 - 1; j &gt;= 0; --j) &#123; if (note[j] - note[j + 1] == note[j + i] - note[j + i + 1]) &#123; ++length; if (length &gt; i) length = i; if (longest &lt; length) longest = length; &#125; else &#123; length = 1; &#125; &#125; &#125; ofstream fileout (\"theme.out\"); fileout &lt;&lt; ((longest &gt;= 5) ? longest : 0) &lt;&lt; endl; fileout.close (); exit (0);&#125; 算法4+ ​ 一些我听说过的名词：好像也只是听说过——————后缀数组。后缀自动机。……","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"},{"name":"差分","slug":"差分","permalink":"http://yoursite.com/tags/差分/"}]},{"title":"USACO5.1.2","slug":"OI/USACO/training/Section5/USACO5.1.2/starry","date":"2017-08-14T04:49:06.000Z","updated":"2017-08-18T03:26:49.399Z","comments":true,"path":"2017/08/14/OI/USACO/training/Section5/USACO5.1.2/starry/","link":"","permalink":"http://yoursite.com/2017/08/14/OI/USACO/training/Section5/USACO5.1.2/starry/","excerpt":"Starry Night给定H*W的一幅图，让你给图中的一些极大联通快（8联通）编号，已知如果两个联通快经过旋转，对称等可以相同，说明两个联通快是同一个编号的。","text":"Starry Night给定H*W的一幅图，让你给图中的一些极大联通快（8联通）编号，已知如果两个联通快经过旋转，对称等可以相同，说明两个联通快是同一个编号的。 原题：——大家仔细理解一下样例 Starry NightIOI 98 High up in the night sky, the shining stars appear in clusters of various shapes. A cluster is a non-empty group of neighbouring stars, adjacent in horizontal, vertical or diagonal direction. A cluster cannot be a part of a larger cluster. Clusters may be similar. Two clusters are similar if they have the same shape and number of stars, irrespective of their orientation. In general, the number of possible orientations for a cluster is eight, as Figure 1 exemplifies. Figure 1. Eight similar clusters The night sky is represented by a sky map, which is a two-dimensional matrix of 0’s and 1’s. A cell contains the digit 1 if it has a star, and the digit 0 otherwise. Given a sky map, mark all the clusters with lower case letters. Similar clusters must be marked with the same letter; non-similar clusters must be marked with different letters. You mark a cluster with a lower case letter by replacing every 1 in the cluster by that lower case letter. PROGRAM NAME: starryINPUT FORMATThe first two lines contain, respectively, the width W and the height H of a sky map. The sky map is given in the following H lines, of W characters each. SAMPLE INPUT (file starry.in)12345678910111213141516172315100010000000000100000000111110001111100010110101000000010001000111111000000000101010001011110000011101000100000000000001001011111000000000100000010000000000000000010100000011111001000000001000000100010011111000000011101010101000100000010011010001000000000010001110111110000000001000011100000001000000000100010000100010010100000001110001000111000 In this case, the sky map has width 23 and height 15. Just to make it clearer, notice that this input file corresponds to the following picture of the sky. Figure 2. Picture of the sky OUTPUT FORMATThe output file contains the same map as the input file, except that the clusters are marked as described in Task. There will generally be more than one way to label the clusters with letters. Your program should choose the labeling such that if the entire output file is read as a string, this string will be minimal in the lexicographical ordering. SAMPLE OUTPUT (file starry.out)123456789101112131415a000a0000000000b00000000aaaaa000ccccc000d0dd0d0a0000000c000c000dddddd000000000c0b0c000d0dddd00000eee0c000c0000000000000e00e0ccccc000000000b000000e00000000000000000b0f000000ccccc00a00000000f000000c000c00aaaaa0000000ddd0c0b0c0a000a000000b00dd0c000c0000000000g000ddd0ccccc000000000g0000ddd0000000e000000000b000d0000f000e00e0b0000000ddd000f000eee000 This is one possible result for the sample input above. Notice that this output file corresponds to the following picture. Figure 3. Picture with the clusters marked Constraints0 &lt;= W (width of the sky map) &lt;= 100 0 &lt;= H (height of the sky map) &lt;= 100 0 &lt;= Number of clusters &lt;= 500 0 &lt;= Number of non-similar clusters &lt;= 26 (a..z) 1 &lt;= Number of stars per cluster &lt;= 160 做法显然，我们可以求出每一个联通快——通过floodfill。那么问题就是哪些联通快是同构的。 容易想到哈希，如果两个联通块完全相同，我们可以通过最左上角的坐标和一些来进行Hash。 那么如果要满足旋转，对称怎么办。 大家想一下，怎么样的一个Hash可以满足？ 可能还有别的做法，但是我写此文时只想到这个。 考虑旋转对称之后，对于联通块的某一个对应的格子，它的周围8个是类似的。 可以考虑把每一个联通快的每一个是1的根据8*8范围内的1来进行Hash——可以累加或者怎么样的。 当然，可以多取几个模数来保证正确性。——反例总是有的。 发现，W*H&lt;=10000，所以是不会超时的。 下面给出我的哈希函数 123456789101112131415161718const int P[5][5] = &#123;&#123;659 ,2017,4049,2017,659 &#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;4049,3359,1 ,3359,4049&#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;659 ,2017,4049,2017,659 &#125;&#125;;int Val(int x,int y)&#123; int ans = 0; for (int i=-2;i&lt;=2;i++)&#123; for (int j=-2;j&lt;=2;j++)&#123; if ((x + i &lt; 0) || (x + i &gt;= H) || (y + j &lt; 0) || (y + j &gt;= W))continue; if (Ans[x+i][y+j] == -1)&#123; ans = ans + P[i+2][j+2]; &#125; &#125; &#125; return ans;&#125; 取一些大素数！这样可以让正确率增大许多。 Executing… Test 1: TEST OK [0.000 secs, 4332 KB] Test 2: TEST OK [0.000 secs, 4332 KB] Test 3: TEST OK [0.000 secs, 4332 KB] Test 4: TEST OK [0.000 secs, 4332 KB] Test 5: TEST OK [0.000 secs, 4332 KB] All tests OK. 事实上很快。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/*ID:cqz15311LANG:C++PROG:starry */#include&lt;bits/stdc++.h&gt;const int maxn = 105;using namespace std;const int dx[8] = &#123;-1,-1,-1, 0,0, 1,1,1&#125;;const int dy[8] = &#123;-1, 0, 1,-1,1,-1,0,1&#125;; struct Q&#123; int x,y; Q(int _x = 0,int _y = 0)&#123; x = _x; y = _y; &#125;&#125;q[maxn*maxn];char a[maxn][maxn];bool vis[maxn][maxn];int Ans[maxn][maxn];int front,rear;int W,H;void floodfill(int sx,int sy)&#123; int x,y,_x,_y;// puts(\"\"); front = rear = 0; q[rear++] = Q(sx,sy); Ans[sx][sy] = -1; while (front &lt; rear)&#123; x = q[front] . x; y = q[front] . y; front++; for (int d=0;d&lt;8;d++)&#123; _x = x + dx[d]; _y = y + dy[d]; if ((_x &lt; 0) || (_y &lt; 0) || (_x &gt;= H) || (_y &gt;= W) || (a[_x][_y] == 0) || Ans[_x][_y] == -1) continue; Ans[_x][_y] = -1; q[rear++] = Q(_x,_y); &#125; &#125;&#125;const int P[5][5] = &#123;&#123;659 ,2017,4049,2017,659 &#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;4049,3359,1 ,3359,4049&#125;, &#123;2017,3169,3359,3169,2017&#125;, &#123;659 ,2017,4049,2017,659 &#125;&#125;;int Val(int x,int y)&#123; int ans = 0; for (int i=-2;i&lt;=2;i++)&#123; for (int j=-2;j&lt;=2;j++)&#123; if ((x + i &lt; 0) || (x + i &gt;= H) || (y + j &lt; 0) || (y + j &gt;= W))continue; if (Ans[x+i][y+j] == -1)&#123; ans = ans + P[i+2][j+2]; &#125; &#125; &#125; return ans;&#125;int get_hash(int sx,int sy)&#123; int x,y,_x,_y; int rec = 0; front = rear = 0; q[rear++] = Q(sx,sy); vis[sx][sy] = true; while (front &lt; rear)&#123; x = q[front] . x; y = q[front] . y; rec = rec + Val(x,y); front++; for (int d=0;d&lt;8;d++)&#123; _x = x + dx[d]; _y = y + dy[d]; if ((_x &lt; 0) || (_y &lt; 0) || (_x &gt;= H) || (_y &gt;= W)) continue; if (Ans[_x][_y] == -1 &amp;&amp; !vis[_x][_y])&#123; vis[_x][_y] = true; q[rear++] = Q(_x,_y); &#125; &#125; &#125; return rec;&#125;void Filled(int sx,int sy,int Addval)&#123; int x,y,_x,_y; front = rear = 0; Ans[sx][sy] = Addval; q[rear++] = Q(sx,sy); while (front &lt; rear)&#123; x = q[front] . x; y = q[front] . y; front++; for (int d=0;d&lt;8;d++)&#123; _x = x + dx[d]; _y = y + dy[d]; if ((_x &lt; 0) || (_y &lt; 0) || (_x &gt;= H) || (_y &gt;= W) || Ans[_x][_y] != -1) continue; Ans[_x][_y] = Addval; q[rear++] = Q(_x,_y); &#125; &#125; &#125;int Hash[28];int find(int x)&#123; for (int i=1;i&lt;=Hash[0];i++)&#123; if (x == Hash[i]) return i + 'a' - 1; &#125; Hash[++Hash[0]] = x; return Hash[0] + 'a' - 1;&#125;int main()&#123; freopen(\"starry.in\",\"r\",stdin); freopen(\"starry.out\",\"w\",stdout); scanf(\"%d%d\",&amp;W,&amp;H); for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; a[i][j] = getchar(); while ((a[i][j] != '0') &amp;&amp; (a[i][j]!='1')) a[i][j] = getchar(); a[i][j] -= '0'; &#125; &#125; memset(Hash,0,sizeof(Hash)); memset(vis,false,sizeof(vis)); memset(Ans,0,sizeof(Ans)); for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; if (Ans[i][j] != 0 || a[i][j] == 0) continue; floodfill(i,j); //把当前联通块全部求出来，标记为-1 int Tmp = find(get_hash(i,j)); Filled(i,j,Tmp); &#125; &#125; for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; if (Ans[i][j] == 0) putchar('0'); else printf(\"%c\",Ans[i][j]); &#125; puts(\"\"); &#125; fclose(stdin); fclose(stdout); return 0;&#125;","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"hash","slug":"hash","permalink":"http://yoursite.com/tags/hash/"}]},{"title":"USACO5.1.1","slug":"OI/USACO/training/Section5/USACO5.1.1/fc","date":"2017-08-14T01:17:49.000Z","updated":"2017-08-18T03:26:59.328Z","comments":true,"path":"2017/08/14/OI/USACO/training/Section5/USACO5.1.1/fc/","link":"","permalink":"http://yoursite.com/2017/08/14/OI/USACO/training/Section5/USACO5.1.1/fc/","excerpt":"Fencing the Cows 给你一些点，问包围这些点的最小花费是多少。","text":"Fencing the Cows 给你一些点，问包围这些点的最小花费是多少。 本题的实质是求一个凸包 为什么是凸包？ 很显然地发现，如果存在A-&gt;B-&gt;C，其中B是凹的，那么不如A-&gt;C来得赚。 凸包是什么？请大家自行Baidu Or Google 下面给出凸包的求法： 首先明确什么是叉积 对于点A，点B，它们的叉积就是 |A| |B| sin(α)① 其中|A|表示A的长度，α表示A到B的夹角 我们可以通过α的正负来判断A和B相对于原点的位置（顺时针or逆时针） 然而，叉积还有另外一个公式 A.x B.y - A.y B.x② 123double Cross(Point a,Point b,Point c)&#123;//这里以c为源点 return (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);&#125; 这个证明不给出，主要是通过单位向量之间的转换得到。 那么我们可以通过公式②的正负性得到点之间的位置。 凸包因为是凸多边形，对于相邻的3个点A，B，C（按照逆时针排序） 必然满足相对于A来说，C在B的顺时针方向。 而且我们还知道，凸包的顶点一定是给定的点中的。 因此可以整理出下面的算法框架 $选择最左的，如果相同选择最下面的——这个点一定是凸包中的点 ——好处很多，下面有提到 1234567int k = 0;for (int i=1;i&lt;n;i++)&#123; if ((P[i].x &lt; P[k].x) || (fabs(P[i].x-P[k].x)&lt;eps) &amp;&amp; (P[i].y &lt; P[k].y))&#123; k = i; &#125;&#125;tmp = P[k];P[k] = P[0];P[0] = tmp; $把其它的点与这个点之间，按照极角排序 1234bool cmp(Point a,Point b)&#123; return Cross(a,b,p[0]) &gt; 0; //大于0表示a在b的顺时针方向，所以a应该排在b的前面 &#125; $逆时针一个点一个点考虑，要满足上面提到的性质——用一个栈维护 12345678910top = 0;Stack[top] . x = P[0].x;Stack[top] . y = P[0].y;top++;for (int i=1;i&lt;n;i++)&#123; while ((top &gt;= 2) &amp;&amp; (Cross(P[i],Stack[top-1],Stack[top-2]) &gt; 0)) top--; Stack[top] . x = P[i].x; Stack[top] . y = P[i].y; top++;&#125; $直到考虑完所有点结束（不用重新考虑0号点) 大家可以考虑一下为什么不用重新考虑 上面的性质可以用一个栈来维护。 那么凸包的周长就是所有凸包上的点之间的距离和 123456double Ans = 0;for (int i=1;i&lt;top;i++)&#123; Ans = Ans + dis(Stack[i-1],Stack[i]);&#125;Ans = Ans + dis(Stack[top-1],Stack[0]);printf(\"%.2lf\\n\",Ans); 做法虽然有点繁琐，但代码很好理解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*ID:cqz15311LANG:C++PROG:fc*/#include&lt;bits/stdc++.h&gt;const double eps = 1e-8;using namespace std;struct Point&#123; double x,y;&#125;tmp,P[10005],Stack[10005];int n; double Cross(Point a,Point b,Point c)&#123;//这里以c为源点 return (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);&#125;bool cmp(Point a,Point b)&#123; return Cross(a,b,P[0]) &gt; 0; //大于0表示a在b的顺时针方向，所以a应该排在b的前面 &#125;void init()&#123; freopen(\"fc.in\",\"r\",stdin); freopen(\"fc.out\",\"w\",stdout); scanf(\"%d\",&amp;n); for (int i=0;i&lt;n;i++)&#123; scanf(\"%lf%lf\",&amp;P[i].x,&amp;P[i].y); &#125; int k = 0; for (int i=1;i&lt;n;i++)&#123; if ((P[i].x &lt; P[k].x) || (fabs(P[i].x-P[k].x)&lt;eps) &amp;&amp; (P[i].y &lt; P[k].y))&#123; k = i; &#125; &#125; tmp = P[k];P[k] = P[0];P[0] = tmp; sort(P+1,P+n,cmp);&#125;int top;void solve()&#123; top = 0; Stack[top] . x = P[0].x; Stack[top] . y = P[0].y; top++; for (int i=1;i&lt;n;i++)&#123; while ((top &gt;= 2) &amp;&amp; (Cross(P[i],Stack[top-1],Stack[top-2]) &gt; 0)) top--; Stack[top] . x = P[i].x; Stack[top] . y = P[i].y; top++; &#125;&#125;double dis(Point a,Point b)&#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;void Write()&#123; double Ans = 0; for (int i=1;i&lt;top;i++)&#123; Ans = Ans + dis(Stack[i-1],Stack[i]); &#125; Ans = Ans + dis(Stack[top-1],Stack[0]); printf(\"%.2lf\\n\",Ans); fclose(stdin); fclose(stdout);&#125;int main()&#123; init(); solve(); Write(); return 0;&#125;","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"},{"name":"计算几何","slug":"计算几何","permalink":"http://yoursite.com/tags/计算几何/"}]},{"title":"USACO4.4.3","slug":"OI/USACO/training/Section4/4/USACO4.4.3-frameup/frameup","date":"2017-08-12T10:25:32.000Z","updated":"2017-08-18T03:27:11.092Z","comments":true,"path":"2017/08/12/OI/USACO/training/Section4/4/USACO4.4.3-frameup/frameup/","link":"","permalink":"http://yoursite.com/2017/08/12/OI/USACO/training/Section4/4/USACO4.4.3-frameup/frameup/","excerpt":"Frame up题意： 有一些框架，大小在H*W以内，依次放入这些框架在一个格子内，得到一副图，给你这幅图，问放框架的顺序。 保证矩形的每条边都有一部分是可见的。","text":"Frame up题意： 有一些框架，大小在H*W以内，依次放入这些框架在一个格子内，得到一副图，给你这幅图，问放框架的顺序。 保证矩形的每条边都有一部分是可见的。 原题 Consider the following five picture frames shown on an 9 x 8 array: 123456789........ ........ ........ ........ .CCC....EEEEEE.. ........ ........ ..BBBB.. .C.C....E....E.. DDDDDD.. ........ ..B..B.. .C.C....E....E.. D....D.. ........ ..B..B.. .CCC....E....E.. D....D.. ....AAAA ..B..B.. ........E....E.. D....D.. ....A..A ..BBBB.. ........E....E.. DDDDDD.. ....A..A ........ ........E....E.. ........ ....AAAA ........ ........EEEEEE.. ........ ........ ........ ........ 1 2 3 4 5Now place all five picture frames on top of one another starting with 1 at the bottom and ending up with 5 on top. If any part of a frame covers another frame, it hides that part of the frame below. Viewing the stack of five frames we see the following. .CCC... ECBCBB.. DCBCDB.. DCCC.B.. D.B.ABAA D.BBBB.A DDDDAD.A E...AAAA EEEEEE.. Given a picture like this, determine the order of the frames stacked from bottom to top. Here are the rules for this challenge: The width of the frame is always exactly 1 character and the sides are never shorter than 3 characters.It is possible to see at least one part of each of the four sides of a frame. A corner is part of two sides.The frames will be lettered with capital letters, and no two frames will be assigned the same letter.PROGRAM NAME: frameup INPUT FORMAT Line 1: Two space-separated integers: the height H (3 &lt;= H &lt;=30) and the width W (3 &lt;= W &lt;= 30).Line 2..H+1: H lines, each with a string W characters wide.SAMPLE INPUT (file frameup.in) 123456789109 8.CCC....ECBCBB..DCBCDB..DCCC.B..D.B.ABAAD.BBBB.ADDDDAD.AE...AAAAEEEEEE.. OUTPUT FORMAT Print the letters of the frames in the order they were stacked from bottom to top. If there are multiple possibilities for an ordering, list all such possibilities – in alphabetical order – on successive lines. There will always be at least one legal ordering. SAMPLE OUTPUT (file frameup.out) EDABC 做法: 注意到题目保证 ​ 矩形的每条边都有一部分是可见的。 ​ 而且N&lt;=26（不然无法保存） 而且矩形的每一条边的长度为1，我们可以很显然地得到一个矩形的范围。 （通过枚举每一个N，然后得到其最左在什么地方出现，最上在什么地方出现，最右在什么地方出现，最下在什么地方出现） 那么如果在这个矩形边上的可见的，说明那个编号的矩形是当前矩形之后才摁上去的。 从而可以考虑到拓扑排序,怎么做呢？设当前处理到的矩形为i,编号为j的矩形在i的边上，而且是可见的，那么相当于从i到j有一条又向边。 通过一次拓扑排序，就可以得到结果了。 注意，该题中的字母可能不连续。 具体实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*ID:cqz15311LANG:C++PROG:frameup*/#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge&#123; int from,to,nxt;&#125;edge[31*31*31*31];//邻接矩阵就行了，我是不是太浪费了 int first[255];int H,W,In[255],nume,Len;char a[31][31];bool find(char x)&#123; for (int i=0;i&lt;H;i++)&#123; for (int j=0;j&lt;W;j++)&#123; if (a[i][j] == x) return true; &#125; &#125; return false;&#125;void add_edge(int a,int b)&#123;// printf(\"%c--&gt;%c\\n\",a,b);// if (b == 'E') printf(\"ADDing%c\\n\",a); edge[nume] . from = a; edge[nume] . to = b; edge[nume] . nxt = first[a]; first[a] = nume++; In[b]++;&#125;int cnt;bool vis[255];char ans[255];bool found[255];void dfs(int x)&#123; if (x == Len+1)&#123; for (int i=1;i&lt;=Len;i++) putchar(ans[i]); puts(\"\"); return ; &#125; for (int i='A';i&lt;='Z';i++)&#123; if (found[i] &amp;&amp; !vis[i] &amp;&amp; In[i] == 0)&#123; vis[i] = true; ans[x] = i; for (int e=first[i];e!=-1;e=edge[e].nxt) In[edge[e].to]--; dfs(x+1); for (int e=first[i];e!=-1;e=edge[e].nxt) In[edge[e].to]++; vis[i] =false; ans[x] = -1; &#125; &#125; //一位一位按照字典序枚举，得到一个解就输出，是满足字典序的。 &#125;int main()&#123; freopen(\"frameup.in\",\"r\",stdin); freopen(\"frameup.out\",\"w\",stdout); scanf(\"%d%d\",&amp;H,&amp;W); for (int i=0;i&lt;H;i++)&#123; scanf(\"%s\",&amp;a[i]); &#125; nume = 0; Len = 0; memset(found,false,sizeof(found)); memset(first,-1,sizeof(first)); for (int c='A';c&lt;='Z';c++)&#123; if (find(c))&#123;//可能不连续，所以要判断c是否存在 found[c] = true; Len++; int L,R,U,D; L = W; R = -1; U = H; D = -1; for (int i=0;i&lt;H;i++) for (int j=0;j&lt;W;j++) if (a[i][j] == c) L = min(L,j),R = max(R,j),U = min(U,i),D = max(D,i); for (int i=L;i&lt;=R;i++)&#123; if (a[U][i] != '.' &amp;&amp; a[U][i] != c) add_edge(c,a[U][i]); if (a[D][i] != '.' &amp;&amp; a[D][i] != c) add_edge(c,a[D][i]); &#125; for (int i=U;i&lt;=D;i++)&#123; if (a[i][L] != '.' &amp;&amp; a[i][L] != c) add_edge(c,a[i][L]); if (a[i][R] != '.' &amp;&amp; a[i][R] != c) add_edge(c,a[i][R]); &#125; //注意不能自己向自己连边 &#125; &#125; memset(vis,false,sizeof(vis)); dfs(1); fclose(stdin); fclose(stdout); return 0;&#125; 呼&amp;把第四章刷完了。","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO4.4.1","slug":"OI/USACO/training/Section4/4/USACO4.4.1-shuttle/shuttle","date":"2017-08-11T13:04:04.000Z","updated":"2017-08-18T03:27:29.107Z","comments":true,"path":"2017/08/11/OI/USACO/training/Section4/4/USACO4.4.1-shuttle/shuttle/","link":"","permalink":"http://yoursite.com/2017/08/11/OI/USACO/training/Section4/4/USACO4.4.1-shuttle/shuttle/","excerpt":"Shuttle Puzzle题意：给定n，当n=3的时候，表示从WWW_BBB到BBB_WWW的最少操作步数。每次可以将某一个W或者B移动到空格位置，但是距离得小于等于2。 n&lt;=12","text":"Shuttle Puzzle题意：给定n，当n=3的时候，表示从WWW_BBB到BBB_WWW的最少操作步数。每次可以将某一个W或者B移动到空格位置，但是距离得小于等于2。 n&lt;=12 这题搜索似乎要超时。 下面给出原题： USACO4.4.1 Shuttle PuzzleTraditionalThe Shuttle Puzzle of size 3 consists of 3 white marbles, 3 black marbles, and a strip of wood with 7 holes. The marbles of the same color are placed in the holes at the opposite ends of the strip, leaving the center hole empty. INITIAL STATE: WWW_BBBGOAL STATE: BBB_WWWTo solve the shuttle puzzle, use only two types of moves. Move 1 marble 1 space (into the empty hole) or jump 1 marble over 1 marble of the opposite color (into the empty hole). You may not back up, and you may not jump over 2 marbles. A Shuttle Puzzle of size N consists of N white marbles and N black marbles and 2N+1 holes. Here’s one solution for the problem of size 3 showing the initial, intermediate, and end states: WWW BBBWW WBBBWWBW BBWWBWB BWWB BWBW BWBWB WBWBWBBW WBWBBWBW WBBWBWBWBWBWB WBWB BWWB BWBWWBB WBWWBBBW WWBBB WWWWrite a program that will solve the SHUTTLE PUZZLE for any size N (1 &lt;= N &lt;= 12) in the minimum number of moves and display the successive moves, 20 per line. PROGRAM NAME: shuttle INPUT FORMAT A single line with the integer N.SAMPLE INPUT (file shuttle.in) 3OUTPUT FORMAT The list of moves expressed as space-separated integers, 20 per line (except possibly the last line). Number the marbles/holes from the left, starting with one. Output the solution that would appear first among the set of minimal solutions sorted numerically (first by the first number, using the second number for ties, and so on). SAMPLE OUTPUT (file shuttle.out) 3 5 6 4 2 1 3 5 7 6 4 2 3 5 4 一下仅表示-对于Nocow内容，我的理解- 33 5 6 4 2 1 3 5 7 6 4 2 3 5 444 6 7 5 3 2 4 6 8 9 7 5 3 1 2 4 6 8 7 5 3 4 6 555 7 8 6 4 3 5 7 9 10 8 6 4 2 1 3 5 7 9 11 10 8 6 4 2 3 5 7 9 8 6 4 5 7 666 8 9 7 5 4 6 8 10 11 9 7 5 3 2 4 6 8 10 12 13 11 9 7 5 3 1 2 4 6 8 10 12 11 9 7 5 3 4 6 8 10 9 7 5 6 8 7 进行神奇的分析 把空格的位置也算上 3：4|35|642|1357|642|35|4 4：5|46|753|2468|97531|2468|753|46|5 ……聪明的你发现规律了吗？ 是的，这是一个对称的等差数列。 要证明？？http://train.usaco.org/usacoanal2?a=lNUFVam4bZA&amp;S=shuttle 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*ID:cqz15311LANG:C++PROG:shuttle*/#include&lt;bits/stdc++.h&gt; using namespace std;int n,now,len,cnt;int main()&#123; freopen(\"shuttle.in\",\"r\",stdin); freopen(\"shuttle.out\",\"w\",stdout); scanf(\"%d\",&amp;n); now = n+1; cnt = 0; for (int i=1;i&lt;=2*n+1;i++)&#123; if (i &lt;= n+1)&#123; len = i; &#125; else len = 2 * (n+1) - i; if (i &amp; 1)&#123; for (int j=1;j&lt;=len;j++)&#123; if (i!=1)&#123; cnt++; printf(\"%d\",now); if ((i == 2*n+1) &amp;&amp; (j == len)) puts(\"\"); else if (cnt % 20 == 0) puts(\"\"); else putchar(' '); &#125; now = now - 2; &#125; now+=2; if (i &lt;= n)now--; else now++; &#125; else&#123; for (int j=1;j&lt;=len;j++)&#123; cnt++; printf(\"%d\",now); if (cnt % 20 == 0) puts(\"\"); else putchar(' '); now = now + 2; &#125; now-=2; if (i &lt;= n)now++; else now--; &#125; &#125; //puts(\"\");这个不能有！害得我没有1A fclose(stdin); fclose(stdout); return 0;&#125;/*Executing... Test 1: TEST OK [0.000 secs, 4176 KB] Test 2: TEST OK [0.000 secs, 4176 KB] Test 3: TEST OK [0.000 secs, 4176 KB] Test 4: TEST OK [0.000 secs, 4176 KB] Test 5: TEST OK [0.000 secs, 4176 KB] Test 6: TEST OK [0.000 secs, 4176 KB] Test 7: TEST OK [0.000 secs, 4176 KB] Test 8: TEST OK [0.000 secs, 4176 KB] Test 9: TEST OK [0.000 secs, 4176 KB] Test 10: TEST OK [0.000 secs, 4176 KB]All tests OK.Your program ('shuttle') produced all correct answers! This is yoursubmission #2 for this problem. Congratulations!*/","categories":[],"tags":[{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"USACO4.4.2","slug":"OI/USACO/training/Section4/4/USACO4.4.2-milk6/milk6","date":"2017-08-11T12:44:20.000Z","updated":"2017-08-18T03:27:20.350Z","comments":true,"path":"2017/08/11/OI/USACO/training/Section4/4/USACO4.4.2-milk6/milk6/","link":"","permalink":"http://yoursite.com/2017/08/11/OI/USACO/training/Section4/4/USACO4.4.2-milk6/milk6/","excerpt":"Pollutant Control题意：给定一张图，每条边有流量，求一个图的最小割，并且求出字典序最小一组最小割（在满足的情况下，边越少越好）。","text":"Pollutant Control题意：给定一张图，每条边有流量，求一个图的最小割，并且求出字典序最小一组最小割（在满足的情况下，边越少越好）。 下面给出原题： USACO4.4.2 Pollutant Control Hal Burch It’s your first day in Quality Control at Merry Milk Makers, and already there’s been a catastrophe: a shipment of bad milk has been sent out. Unfortunately, you didn’t discover this until the milk was already into your delivery system on its way to stores. You know which grocer that milk was destined for, but there may be multiple ways for the milk to get to that store. The delivery system is made up of a several warehouses, with trucks running from warehouse to warehouse moving milk. While the milk will be found quickly, it is important that it does not make it to the grocer, so you must shut down enough trucks to ensure that it is impossible for the milk to get to the grocer in question. Every route costs a certain amount to shut down. Find the minimum amount that must be spent to ensure the milk does not reach its destination, along with a set of trucks to shut down that achieves this goal at that cost. PROGRAM NAME: milk6 INPUT FORMAT Line 1: Two space separated integers, N and M. N (2 &lt;= N &lt;= 32) is the number of warehouses that Merry Milk Makers has, and M (0 &lt;= M &lt;= 1000) is the number of trucks routes run. Warehouse 1 is actually the productional facility, while warehouse N is the grocer to which which the bad milk was destined. Line 2..M+1: Truck routes: three space-separated integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si,Ei &lt;= N) correspond to the pickup warehouse and dropoff warehouse for the truck route. Ci (0 &lt;= Ci &lt;= 2,000,000) is the cost of shutting down the truck route. SAMPLE INPUT (file milk6.in) 1234564 51 3 1003 2 502 4 601 2 402 3 80 OUTPUT FORMAT The first line of the output should be two integers, C and T. C is the minimum amount which must be spent in order to ensure the our milk never reaches its destination. T is the minimum number of truck routes that you plan to shut down in order to achive this goal. The next T lines sould contain a sorted list of the indexes of the truck routes that you suggest shutting down. If there are multiple sets of truck routes that achieve the goal at minimum cost, choose one that shuts down the minimum number of routes. If there are still multiple sets, choose the one whose initial routes have the smallest index. SAMPLE OUTPUT (file milk6.out) 1260 13 分析和做法： 这题只需要最大流就可以：注意到边不超过1000个，我们可以把每条边的边权改成原来的边权*1001再加上1，那么跑一编最小割，可以得到用的边最少的。因为在边权相同的情况下，1选的越少越好。 那么答案就是最小割 / 1001。 那么如何求出字典序最小的一组最小割呢？ 显然，因为要字典序最小，我们不能用普通的BFS之类的。 考虑枚举每一条边，如果删去这条边后整个图的最小割变小了，而且变小的正好等于这条边的边权，说明这条边是最小割的一部分，然后真的把这条边从原来的网络中删去。 这里有一些注意点： 1、后面都是每行输出一个答案，不是一行里面 2、要开long long，不然会爆 3、答案的maxv和maxe不要搞错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/*ID:cqz15311LANG:C++PROG:milk6 */#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL oo = 1LL&lt;&lt;50;const int maxv = 35;const int maxe = 2005;struct Edge&#123; int from,to,nxt; LL cap,flow;&#125;;struct G&#123; int nume; int first[maxv],cur[maxv],path[maxv],num[maxv+2],n; int dist[maxv]; Edge edge[maxe * 2]; LL Max_flow; void init(int n)&#123; this -&gt; n = n; nume = 0; memset(first,-1,sizeof(first)); &#125; void add_edge(int a,int b,int c)&#123; edge[nume] . from = a; edge[nume] . to = b; edge[nume] . cap = c; edge[nume] . flow = 0; edge[nume] . nxt = first[a]; first[a] = nume++; edge[nume] . from = b; edge[nume] . to = a; edge[nume] . cap = 0; edge[nume] . flow = 0; edge[nume] . nxt = first[b]; first[b] = nume++; &#125; void Reset()&#123; for (int i=0;i&lt;nume;i++) edge[i] . flow = 0; &#125; LL sap(int s,int t)&#123; Reset(); Max_flow = 0; memset(num,0,sizeof(num)); num[0] = n; memset(dist,0,sizeof(dist)); for (int i=1;i&lt;=n;i++) cur[i] = first[i]; int u = s; while (dist[s] &lt; n)&#123;// printf(\"%d\\n\",u); if (u == t)&#123; LL Min_flow = oo,break_point; //Augment for (int v=t;v!=s;v=edge[path[v]].from)&#123; if (edge[path[v]] . cap - edge[path[v]] . flow &lt; Min_flow)&#123; Min_flow = edge[path[v]] . cap - edge[path[v]] . flow; break_point = edge[path[v]] . from; &#125; &#125; Max_flow += Min_flow; for (int v=t;v!=s;v=edge[path[v]].from)&#123; edge[path[v]] . flow += Min_flow; edge[path[v]^1] .flow -= Min_flow; &#125; u = break_point; &#125; else&#123; bool found = false; for (int &amp;e = cur[u];e!=-1;e=edge[e].nxt)&#123; if ((edge[e].cap &gt; edge[e].flow) &amp;&amp; (dist[edge[e].to] + 1 == dist[u]))&#123; path[edge[e].to] = e; u = edge[e].to; found = true; break; &#125; &#125; if (!found)&#123; int tmp = n+1; for (int e=first[u];e!=-1;e=edge[e].nxt)&#123; if (edge[e].cap &gt; edge[e].flow)&#123; tmp = min(tmp,dist[edge[e].to] + 1); &#125; &#125; if (--num[dist[u]] == 0) return Max_flow; dist[u] = tmp; num[tmp]++; cur[u] = first[u]; if (u != s) u = edge[path[u]] . from; &#125; &#125; &#125; return Max_flow; &#125;&#125;G;int ans[maxe+1];int a[maxe],b[maxe];LL c[maxe];int main()&#123; freopen(\"milk6.in\",\"r\",stdin); freopen(\"milk6.out\",\"w\",stdout); int n,m; scanf(\"%d%d\",&amp;n,&amp;m); G.init(n); for (int i=0;i&lt;m;i++)&#123; scanf(\"%d%d%lld\",&amp;a[i],&amp;b[i],&amp;c[i]); c[i] = c[i] * 1001 + 1; G.add_edge(a[i],b[i],c[i]); &#125; LL Max_flow = G.sap(1,n); printf(\"%lld \",Max_flow / 1001); memset(ans,0,sizeof(ans)); for (int i=0;i&lt;m;i++)&#123; G.edge[i*2] . cap = 0; LL tmp = G.sap(1,n); if (Max_flow - tmp == c[i])&#123; ans[++ans[0]] = i+1; Max_flow -= c[i]; &#125; else G.edge[i*2] . cap = c[i]; &#125; printf(\"%d\\n\",ans[0]); if (ans[0] != 0)&#123; printf(\"%d\\n\",ans[1]); for (int i=2;i&lt;=ans[0];i++)&#123; printf(\"%d\\n\",ans[i]); &#125; &#125; fclose(stdin); fclose(stdout);&#125;/*Executing... Test 1: TEST OK [0.000 secs, 4328 KB] Test 2: TEST OK [0.000 secs, 4328 KB] Test 3: TEST OK [0.000 secs, 4328 KB] Test 4: TEST OK [0.000 secs, 4328 KB] Test 5: TEST OK [0.056 secs, 4328 KB] Test 6: TEST OK [0.000 secs, 4328 KB] Test 7: TEST OK [0.000 secs, 4328 KB] Test 8: TEST OK [0.000 secs, 4328 KB] Test 9: TEST OK [0.014 secs, 4328 KB] Test 10: TEST OK [0.154 secs, 4328 KB] Test 11: TEST OK [0.000 secs, 4328 KB] Test 12: TEST OK [0.000 secs, 4328 KB]All tests OK.*/","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"USACO","slug":"USACO","permalink":"http://yoursite.com/tags/USACO/"}]},{"title":"SAP算法总结","slug":"OI/学习/SAP算法总结","date":"2017-08-09T12:56:24.000Z","updated":"2017-08-11T12:47:47.610Z","comments":true,"path":"2017/08/09/OI/学习/SAP算法总结/","link":"","permalink":"http://yoursite.com/2017/08/09/OI/学习/SAP算法总结/","excerpt":"ISAP算法，一种最大流的优秀算法。","text":"ISAP算法，一种最大流的优秀算法。 概念1：增广路，不解释 概念2：当前弧​ 对于一个点，必然存在当前要处理的弧，一开始，最早的当前弧是它的第一条弧，然后如果下一次他要到下一条边处理，它的当前弧变成下一条边。 具体实现： ·一开始，先跑一发BFS，得到每一个点到汇点的最短距离，这里用最短距离为n+1表示与汇点不联通。 ·在满足源点到汇点联通的情况下（dist[s] != n+1)，每一个节点从那个节点的当前弧开始跑增广路，跑增广路的时候，保存其当前弧，以及整条增广路的路劲。 ·如果到了节点t，那么从节点t开始，一直到s（也就是遍历整条增广路）得到可以增广的量最少的，同时记录这条边的开始那个节点），记为Min_flow和break_point。 ·对整条增广路上的所有路劲减去Min_flow，并同时从break_point开始继续增广。 ·如果当前节点找不到一个后继节点使得dist[u] +1 = dist[nxt]，那么让dist[u]变成它后继节点的dist的最小值+1，如果没有，或者后继节点都到不了t，那么变为n+1。同时，原先那个层次的点的个数-1，当前这个层次的点的个数+1。这个点的当前弧从第一条弧重新开始（如果原先那个层次没有点，说明有断层，直接return即可） ·一直找，直到出现断层。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt; using namespace std;#define maxv 205#define maxe 205struct Edge&#123; int from,to,cap,flow,nxt; //表示从from到to有一条容量为cap，当前流量为flow的边（数组模拟链表的下一个是nxt） &#125;edge[maxe * 2];//总共有maxe条边，还有maxe条反向边 int nume,first[maxv];//边的数量和某个点开始最早的边 int dist[maxv];//当前点到汇点的dist int n,m,path[maxv],cur[maxv];//节点个数，边的个数，增广路以及当前弧 void init()&#123; nume = 0; memset(first,-1,sizeof(first));&#125;//预处理 void add_edge(int a,int b,int c)&#123; edge[nume] . from = a; edge[nume] . to = b; edge[nume] . cap = c; edge[nume] . flow = 0; edge[nume] . nxt = first[a]; first[a] = nume++; //正边 edge[nume] . from = b; edge[nume] . to = a; edge[nume] . cap = 0; edge[nume] . flow = 0; edge[nume] . nxt = first[b]; first[b] = nume++; //反向边 &#125;const int oo = 1&lt;&lt;20;int ISAP(int s,int t)&#123; int u,v,break_point; int num[maxv]; for (int i=1;i&lt;=n;i++) cur[i] = first[i]; int Ans = 0;// bfs(t);//反向BFS，可以不要。 memset(num,0,sizeof(num)); for (int i=1;i&lt;=n;i++) num[dist[i]] ++;//预处理得到每个层次的数量 u = s;//从源点开始 while (dist[s] &lt; n)&#123; if (u == t)&#123;//找到一条增广路 v = u; int Min_flow = oo; while (v!=s)&#123; int e = path[v]; if (edge[e].cap - edge[e].flow &lt; Min_flow)&#123; Min_flow = edge[e].cap - edge[e].flow; break_point = edge[e] . from; &#125; v = edge[e] . from; &#125;//遍历整个增广路，找到Min_flow和break_point Ans = Ans + Min_flow;//增加答案 v = u; while (v!=s)&#123; edge[path[v]] . flow += Min_flow; edge[path[v] ^ 1] . flow -= Min_flow; v = edge[path[v]] . from; &#125;//改变整条增广路上的flow。 u = break_point;//回到端点 &#125;//end of (u = t) else&#123; bool found = false; for (int e = cur[u];e!=-1;e=edge[e].nxt)&#123; v = edge[e].to; if ((dist[v] == dist[u] - 1) &amp;&amp; (edge[e].cap &gt; edge[e].flow))&#123; //找到一条可以走的路（满足是下一个，并且容量大于流量） path[v] = e; cur[u] = e; u = v; found = true; break; &#125; &#125; if (!found)&#123;//Retreat int tmp = n+1; for (int e=first[u];e!=-1;e=edge[e].nxt) if (edge[e].cap &gt; edge[e].flow)&#123; v = edge[e].to; tmp = min(tmp,dist[v] + 1); &#125;//得到其子节点的所有dist中最小的+1 num[dist[u]]--;//原来层次的点数-1 if ((num[dist[u]]) == 0) return Ans;//断点优化，也叫做GAP优化 dist[u] = tmp;//更新层次 num[tmp] = num[tmp] + 1;//新的层次的点数增加 cur[u] = first[u];//当前弧从头开始 if (u != s) u = edge[path[u]].from;//前面的点也要改过 &#125; &#125; &#125; return Ans;//返回结果 &#125;int main()&#123; init(); scanf(\"%d%d\",&amp;m,&amp;n); for (int i=1;i&lt;=m;i++)&#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); add_edge(a,b,c); &#125; printf(\"%d\\n\",ISAP(1,n));&#125;","categories":[],"tags":[]}]}