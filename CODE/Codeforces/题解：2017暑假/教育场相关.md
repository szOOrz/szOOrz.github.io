---
title: Codeforces-Educational-Round
tags:
 - codeforces
mathjax: true
---

这是用来教人怎么做人的。

<!--more-->

##### [Educational Codeforces Round 1](http://codeforces.com/contest/598)

> **CF598A：**求数字之和，但是要不算2的倍数

**模拟**(1A)

​	等差数列求和公式，再减去2次倍数即可。$log$的复杂度

> **CF598B：**给定一个字符串s，下标从1 - |s|。有m次操作，L R k - 表示讲[L, R]里面的字符右移k次，第R位右移一次到达第L位。问你经过m次变化后的字符串。

**模拟**(1A)

​	考虑把k先对长度取模，然后用一个辅助数组直接暴力O(len)移动再代入。

> **CF598C：**找到两个向量间夹角最小的那两个向量的位置;

**精度**(N A)

​	要用atan2高精度做，用long double做，极角排序后求角度即可。

> **CF598D：**给定一个$n \times m$的地图，有k次查询。每次查询，询问位置（x,y）的点连通块周围有多少个

**flood fill**(2A)

​	先$N \times M$把所有位置的答案算出来，然后询问直接做

> **CF598E：**一个n*m大的巧克力，你要吃k个单元的巧克力。每次切分都会有切的那条边长度平方的代价。问最小代价。

**DP**(4A)

​	考虑直接用$dp[i,j,k]$表示状态为i,j,k的时候的答案，那么只需要暴力枚举分割线，以及左边多少，右边多少，取max。注意不要数组越界



##### [Educational Codeforces Round 3](http://codeforces.com/contest/609)

> **CF609A:**给你一个m大的总内存和n个USB快闪驱动器，问你至少需要多少个USB快闪驱动器才能装满或者超过总内存。

**贪心**(1A)

​	排个序，然后贪心贪大的，看减多少次小于等于0即可。

> **CF609B:**给你一堆书和他们的种类，然后要挑两本书，他们不能是相同的种类，求有多少种挑法

**容斥**(1A)

​	考虑所有情况，减去2本数在一起的情况，注意到m<=10，比较容易。

> **CF609C:**给你n个元素的序列a[]，每次可以任选两个元素使得其中一个减1，另一个加1，付出代价为1。问你最小的代价使得序列最平衡。

**贪心**(1A)

​	考虑直接贪心做，把最后得到的那个序列通过总和，余数等算出来，然后考虑把当前排序，贪心地得到两者之间的绝对值的sum，那么最后答案就是这个sum/2

> **CF609D:**给定m个物品（编号从1-m）以及它们的种类和价格（美元和英镑），其中种类1意味着购买该物品需要美元，反之需要英镑。已知在n天里，每天都会有美元和英镑的兑换率a[i]和b[i]，意味着用a[i]个burle可以换取1美元，英镑的兑换同理。现在你手上只有s个burle，你需要在n天里购买k个物品，要求每个物品只能买一次，问你最早在第几天可以完成任务，并输出购买方案。

**二分答案，贪心**(1A)

​	考虑每种货币都在最小的同一天进行购买——在最便宜的一天购买，这样是最赚的。

​	那么我们首先二分答案，那么接下来的事情就是枚举多少个英镑去买，多少个美元去买。那么同时我们之前预处理出一个前缀Min，那么$O(1)$得到在这种情况下，要花费多少burle，如果够的，那么就返回true。

​	注意要保存一下ID。因为答案要输出购买方案。

> **CF609E：**给你一幅图，问对于每条边，包含这条边的最小生成树。

**并查集按秩合并**(5A)

​	倍增写挂了，发现这个好写多了。

​	考虑先求出原图的最小生成树——按秩合并（用$m log m$的那个算法)，考虑到边权是递增的，那么每次加入一条边，这条边连接的两个联通块，那么联通块两边的点一定会经过这条边——这是有保证的。而Max也能保证。

​	而按秩合并，可以保证树高不会超过log，所以复杂度是$O(m log m)$级别的。

​	如果不是原图的边，然后就相当于去掉路劲上最大边权的点，然后加上这条边的边权。



##### [Educational Codeforces Round 4](http://codeforces.com/contest/612)

> **CF612C：**给你一个只含有括号的字符串，你可以将一种类型的左括号改成另外一种类型，右括号改成另外一种右括号。问你最少修改多少次，才能使得这个字符串匹配，输出次数。

**栈**(1A)

​	手工模拟一个栈，如果遇到不匹配的，那么就$Ans+1$.

> **CF612D：**给出n个区间$[li,ri]$以及一个整数k，称一个数的令人满意的如果它至少被这n个区间中的k个区间覆盖，输出所有令人满意的数构成的区间 

**差分**(4A)

​	运用差分思想，考虑$l[i]$的时候+1，$r[i]$的时候-1。注意到，一个点也算是一段，所以不能所谓的离散化之类的，考虑把所有读入之后按照位置排序，在位置相同的情况下，先排加，后排减。然后前缀和一发。

> **CF612E：**定义置换的平方为1~n的排列做两次该置换得到的结果。已知一个置换的平方，求该置换。

**构造**(问$XZA$大佬的)

​	大佬说，先找循环，分成不同的循环联通块。

​	大佬还说，对于元素个数是奇数的，只需要往后移2位就行了，对于元素个数是偶数的，把相同元素个数的两两组合在一起，轮换着放——大佬说这是参考样例1的。

