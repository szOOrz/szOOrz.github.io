	考虑首先对于输入的数排序。同时如果b=min(b,c\times 5)，那么得到所有可能最后的相同的那个数（一定不会超过某个数+0,1,2,3,4,5这个范围），然后考虑枚举所有的Ans，下一步的操作是要在所有数中寻找满足条件的最小花费的k个数。
	可以把花费看作一些数，先变成对应的mod 5=r的数，然后再一直加上b。考虑到我们已经排序了，所以这个右指针（哪些是包含的）是会单调递增的。
	设x mod 5 = r;考虑预处理出每一个数到mod 5 = r的数值为t[i,r]，那么最后的最小花费必然是选出一些i，使得min(∑(t[i,r] - a[i]) * c + ∑(x - t[i,r]) / 5 * b)，考虑到x[i]和t[i,r]的余数是一样的，可以化简为
k * （x / 5 * b）   +   ∑(t[i,r] * c - a[i] * c - t[i,r] / 5 * b)
那么就是维护后面一个最大即可，每次把后面的压入堆中，每次要的时候取出堆中的前k个即可。
但这样不对的，其实我们可以考虑维护5个堆，得到这5个堆中元素和，压入一个元素，加上这个sum，如果元素个数超过k，将大的弹出来，减去这个sum。
	注意四则运算的顺序。