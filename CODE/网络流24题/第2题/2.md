---
title: 网络流练习2
date: 2017-08-10 21:12:28
tags: 网络流
---

# 最大权闭合子图

最大权闭合子图问题，有n个实验，每个实验要一些工具，每个工具需要花费，每个实验可以得到收益，求最大化收益。

<!-- more -->

W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 E={E1，E2，…，Em}，和进行这些实验需要使用的全部仪器的集合 I={I1， I2，… I n } 。实验 Ej需要用到的仪器是 I 的子集 Rj˝I。配置仪器 Ik的费用为 ck美元。实验 Ej的赞助商已同意为该实验结果支付 pj美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。  

对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。

输入描述 Input Description

第 1 行有 2 个正整数 m和 n。m 是实验数，n 是仪器数。接下来的 m 行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的 n 个数是配置每个仪器的费用。

输出描述 Output Description

第 1 行是实验编号；第 2行是仪器编号；最后一行是净收益。

样例输入 Sample Input

2 3

10 1 2

25 2 3

5 6 7

样例输出 Sample Output

1 2  

1 2 3 

17



<!-- more --> 

这题是典型的最大权闭合子图。

这题我们可以这样考虑如果全部做，不买物品，总收益为S

对于一个实验，要么是实验做（相当于花费购买器械的价格），要么是实验不做（相当于减去这个实验的收益）

然后最后我们要最大化收益，也就是使得花费最小。可以考虑到最小割——>最大流

具体这样建图（样例）：

![img](/_posts/网络流24题/第二题/图片.png) 

最后求哪些最小割我是穷举每条边重新跑的，其实没有必要，因为这题有SPJ（不一定字典序最小之类），所以一般只需要重新开始沿着没有被割的边BFS即可。

```cpp
#include<bits/stdc++.h> 
using namespace std;
const int maxv = 150;
const int maxe = 30000;
struct Edge{
	int from,to,nxt,cap,flow;
}; 

int Mark[maxv],Sum;
bool choice[maxv],C[maxv];
const int oo = 1<<25;
class Graph{
	public:
			int first[maxv],n,Max_flow,nume;
			int num[maxv],dist[maxv],cur[maxv];
			int path[maxv];
			Edge edge[maxe];
			
			void init(int n){
				this -> n = n;
				nume = 0;
				memset(first,-1,sizeof(first));
			}
			
			void add_edge(int a,int b,int c){
				edge[nume] . from  = a;
				edge[nume] .   to  = b;
				edge[nume] .  nxt  = first[a];
				edge[nume] .  cap  = c;
				edge[nume] . flow  = 0;
				first[a] = nume++;
				edge[nume] . from  = b;
				edge[nume] .   to  = a;
				edge[nume] .  nxt  = first[b];
				edge[nume] .  cap  = 0;
				edge[nume] . flow  = 0;
				first[b] = nume++;
			}
			
			void Reset(){
				for (int i=0;i<nume;i++){
					edge[i].flow = 0;
				}
			}
			
			int sap(int s,int t){
				Reset();
				Max_flow = 0;
				memset(num,0,sizeof(num));
				memset(dist,0,sizeof(dist));
				for (int i=1;i<=n;i++) cur[i] = first[i];
				int u = s;
				while (dist[s] != n+1){
					if (u == t){
						int Min_flow = oo;
						int break_point = -1;
						for (int v = u;v!=s;v=edge[path[v]].from){
							if (Min_flow >= edge[path[v]].cap - edge[path[v]].flow){
								Min_flow = edge[path[v]].cap - edge[path[v]].flow;
								break_point = edge[path[v]].from;
							}
						}
						Max_flow += Min_flow;
						for (int v = u;v!=s;v=edge[path[v]].from){
							edge[path[v]] . flow += Min_flow;
							edge[path[v] ^ 1] . flow -= Min_flow;
						}
						
												
						u = break_point;
					} else{
						bool found = false;
						for (int e = cur[u];e!=-1;e=edge[e].nxt){
							if ((dist[u] == dist[edge[e].to] + 1) && (edge[e].cap > edge[e].flow)){
								cur[u] = e;
								path[edge[e].to] = e;
								u = edge[e].to;
								found = true;
								break;
							}
						}
						if (!found){
							int tmp = n + 1;
							for (int e=first[u];e!=-1;e=edge[e].nxt)
								if (edge[e].cap > edge[e].flow){
									tmp = min(tmp,dist[edge[e].to]+1);
								}
							if (--num[dist[u]] == 0) return Max_flow;
							dist[u] = tmp;
							num[tmp]++;
							cur[u] = first[u];
							if (u!=s) u = edge[path[u]] . from;
						}
					}
				}
				return Max_flow;
			}
		;
}G;
char c = '.';
int read(int x){
	while ((!((c>='0') && (c<='9'))) && ((c!='\n') || (x == 1))) c=getchar();
	if (c == '\n') return -1;
	int a = 0;
	while ((c>='0') && (c<='9')){
		a = a * 10 + c - 48;
		c=getchar();
	}
	return a;
}
int m,n;
int Son[maxv][maxv];
int main(){
	m = read(1);n = read(1);
	Sum = 0;
	G.init(1+m+n+1);
	for (int u=1;u<=m;u++){
		Son[u][0] = 0;
		int value = read(1);
		Sum = Sum + value;
		G.add_edge(1,1+u,value);
		for (Son[u][++Son[u][0]] = read(0);Son[u][Son[u][0]]!=-1;Son[u][++Son[u][0]]=read(0)){
			G.add_edge(1+u,1+m+Son[u][Son[u][0]],oo);
		}
	}
	for (int i=1;i<=n;i++){
		int dis = read(1);
		G.add_edge(1+m+i,1+n+m+1,dis);
	}
	int Max_flow = G.sap(1,1+n+m+1);
	for (int e=G.first[1];e!=-1;e=G.edge[e].nxt)
		if ((e & 1) == 0){//如果是正向边 
		//尝试去掉这条边
		int tmp1 = G.edge[e].cap;
		G.edge[e].cap = 0;
		int tmp2 =  G.sap(1,1+n+m+1);
		G.edge[e].cap = tmp1;
		if (G.edge[e].cap - G.edge[e].flow != tmp2) choice[G.edge[e].to-1] = true;
	}
	memset(C,0,sizeof(C));
	for (int i=1;i<=m;i++){
		if (choice[i]){
			printf("%d ",i);
			for (int j=1;j<=Son[i][0];j++){
				C[Son[i][j]] = true;
			}
		}
	}
	puts("");
	for (int i=1;i<=n;i++){
		if (C[i]) printf("%d ",i);
	}
	puts("");
	printf("%d\n",Sum-Max_flow);
}

/*
2 3
10 1 2
25 2 3
5 6 7
*/
```

 

 