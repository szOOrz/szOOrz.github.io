---
title: 网络流练习1
date: 2017-08-10 20:36:55
tags: 网络流
---

# 二分图最大匹配问题

​	从前一个和谐的班级，有 nl 个是男生，有 nr 个是女生。编号分别为 1,…,nl 和 1,…,nr。

有若干个这样的条件：第 v 个男生和第 u个女生愿意结为配偶。

请问这个班级里最多产生多少对配偶？

<!-- more -->

输入格式
第一行三个正整数，nl,nr,m。

​	接下来 m 行，每行两个整数 v,u 表示第 v 个男生和第 u 个女生愿意结为配偶。保证 1≤v≤nl1≤v≤nl，1≤u≤nr1≤u≤nr，保证同一个条件不会出现两次。

输出格式
第一行一个整数，表示最多产生多少对配偶。

接下来一行 nl个整数，描述一组最优方案。第 v 个整数表示 v 号男生的配偶的编号。如果 v 号男生没配偶请输出 0。



<!-- more -->

考虑2种做法，第一种是建图+SAP，最后判断哪些边是被流满了的。

如图：

![img](\_posts\网络流24题\第一题\1.jpg)

用Dinic或者SAP，速度是比较快的，大概是sqrt(n)*m，但是代码比较长，这里推荐第二种做法：匈牙利

匈牙利算法主要是基于增广路，也就是每次经过男生~女生~男生~女生，一直到一个未匹配的女生，结束，然后两两对应匹配。时间复杂度O(n^3)——邻接表（数组模拟链表）存和邻接矩阵存差不多，下面给出邻接表的代码

```cpp
#include<bits/stdc++.h>  
const int maxv = 505;
int nl,nr,m,ans;  
int Map[maxv][maxv],link[maxv],Ans[maxv];  
bool vis[maxv];  
using namespace std;  
bool Hungary(int u){  
    for (int v=1;v<=nr;v++){  
        if (!vis[v] && Map[u][v]){  
            vis[v] = true;  
            if (link[v] == -1 || Hungary(link[v])){  
                link[v] = u;  
                return true;  
            }  
        }  
    }  
    return false;  
}  
int c,x;  
int main(){  
    memset(Map,false,sizeof(Map));  
    scanf("%d%d%d",&nl,&nr,&m);  
    for (int i=1;i<=m;i++){
    	int a,b;
    	scanf("%d%d",&a,&b);
    	Map[a][b] = true;
    }
    ans = 0;  
    memset(link,-1,sizeof(link));  
    for (int k=1;k<=nl;k++){  
        memset(vis,false,sizeof(vis));  
        if (Hungary(k)) ans++;  
    }  
    printf("%d\n",ans);
    memset(Ans,0,sizeof(Ans));
    for (int i=1;i<=nr;i++){
    	Ans[link[i]] = i;
    }
    for (int i=1;i<=nl;i++){
    	printf("%d ",Ans[i]);
    }
	return 0; 
}
```

推荐在UOJ上提交，事实上各大OJ一般都有。